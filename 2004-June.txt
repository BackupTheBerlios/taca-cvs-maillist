From xscript at gmx.net  Tue Jun  1 20:53:57 2004
From: xscript at gmx.net (Lluis)
Date: Tue, 1 Jun 2004 20:53:57 +0200
Subject: [Taca-cvs] test
Message-ID: <20040601185357.GA3585@dante.xlab.taz>

test
-- 
 "And it's much the same thing with knowledge, for whenever you learn
 something new, the whole world becomes that much richer."
 -- The Princess of Pure Reason, as told by Norton Juster in The Phantom
 Tollbooth 


From nobody at sheep.berlios.de  Tue Jun  1 20:43:41 2004
From: nobody at sheep.berlios.de (xscript)
Date: Tue, 1 Jun 2004 20:43:41 +0200
Subject: [Taca-cvs] doc text.txt,1.1.1.1,1.2
Message-ID: <200406011843.i51IhaB20552@bat.berlios.de>

Update of /cvsroot/taca/doc
In directory sheep:/tmp/cvs-serv2566

Modified Files:
	text.txt 
Log Message:
Testing autonotification

Index: text.txt
===================================================================
RCS file: /cvsroot/taca/doc/text.txt,v
retrieving revision 1.1.1.1
retrieving revision 1.2
diff -C2 -d -r1.1.1.1 -r1.2
*** text.txt	1 Jun 2004 18:28:53 -0000	1.1.1.1
--- text.txt	1 Jun 2004 18:43:33 -0000	1.2
***************
*** 1,3 ****
! 
   _________________________________
  ( 1.- Qu? i perqu? ho volem fer?  )
--- 1,3 ----
!  
   _________________________________
  ( 1.- Qu? i perqu? ho volem fer?  )



From nobody at sheep.berlios.de  Sat Jun  5 14:13:40 2004
From: nobody at sheep.berlios.de (xscript)
Date: Sat, 5 Jun 2004 14:13:40 +0200
Subject: [Taca-cvs] doc 00-index.txt,NONE,1.1 01-text.txt,NONE,1.1 02-text.txt,NONE,1.1 04-text.txt,NONE,1.1 Index.txt,1.1.1.1,NONE text.txt,1.2,NONE
Message-ID: <200406051213.i55CDeB23122@bat.berlios.de>

Update of /cvsroot/taca/doc
In directory sheep:/tmp/cvs-serv26282

Added Files:
	00-index.txt 01-text.txt 02-text.txt 04-text.txt 
Removed Files:
	Index.txt text.txt 
Log Message:
Reordering documentation text files


--- NEW FILE: 00-index.txt ---
(This appears to be a binary file; contents omitted.)

--- NEW FILE: 01-text.txt ---
(This appears to be a binary file; contents omitted.)

--- NEW FILE: 02-text.txt ---
(This appears to be a binary file; contents omitted.)

--- NEW FILE: 04-text.txt ---
(This appears to be a binary file; contents omitted.)

--- Index.txt DELETED ---

--- text.txt DELETED ---



From nobody at sheep.berlios.de  Sun Jun  6 23:37:31 2004
From: nobody at sheep.berlios.de (xscript)
Date: Sun, 6 Jun 2004 23:37:31 +0200
Subject: [Taca-cvs] doc 00-taca.bib,NONE,1.1 00-taca.tex,NONE,1.1 01.tex,NONE,1.1 02.tex,NONE,1.1 03.tex,NONE,1.1 04.tex,NONE,1.1 05.tex,NONE,1.1 esquema-supcl.dia,NONE,1.1 esquema-supcl.eps,NONE,1.1 esquema-utilcl.dia,NONE,1.1 esquema-utilcl.eps,NONE,1.1 00-index.txt,1.1,NONE 01-text.txt,1.1,NONE 02-text.txt,1.1,NONE 04-text.txt,1.1,NONE
Message-ID: <200406062137.i56LbVB02590@bat.berlios.de>

Update of /cvsroot/taca/doc
In directory sheep:/tmp/cvs-serv31535

Added Files:
	00-taca.bib 00-taca.tex 01.tex 02.tex 03.tex 04.tex 05.tex 
	esquema-supcl.dia esquema-supcl.eps esquema-utilcl.dia 
	esquema-utilcl.eps 
Removed Files:
	00-index.txt 01-text.txt 02-text.txt 04-text.txt 
Log Message:
Transition to LaTeX

--- NEW FILE: 00-taca.bib ---
@manual{Beowulf-MiniHowto,
	title = {Beowulf cluster Mini-HowTo},
	note = {http://www.fysik.dtu.dk/CAMP/cluster-howto.html}
}

@manual{Beowulf-Home,
	title = {Beowulf.org The Beowulf Cluster Site},
	note = {http://www.beowulf.org/index.html}
}

@manual{Beowulf-Howto,
	title = {Beowulf HOWTO},
	note = {http://www.faqs.org/docs/Linux-HOWTO/Beowulf-HOWTO.html}
}

@manual{Hurd-Translators,
	title = {Debian GNU/Hurd - Translators},
	note = {http://www.debian.org/ports/hurd/hurd-doc-translator}
}


--- NEW FILE: 00-taca.tex ---
\documentclass[a4paper,10pt]{report}

\usepackage[latin1]{inputenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage[catalan]{babel}

% Salto de l?nea tras t?tulo de secciones \paragraph
\makeatletter % necesario para que reconozca a '@' como car?cter normal
\renewcommand{\paragraph}{\@startsection{paragraph}{4}{\z@}{-3.25ex \@plus -1ex \@minus -.2ex}{1.5ex \@plus .2ex}{\normalfont\normalsize\bfseries}}
\makeatother % necesario para que restablezca '@' como car?cter especial


% Title Page
\author{
  Albert Farr?s Coma
  \and
  Jonathan Mart? Fraiz
  \and
  C?sar P?rez Laguna
  \and
  Llu?s Vilanova Garc?a
}

\title{
  \textbf{
  Arquitectura Transparent \\
  per a l'Administraci? de Cl?sters
  }
}


\begin{document}
\maketitle

\tableofcontents

\input{01.tex}
\input{02.tex}
\input{03.tex}
\input{04.tex}
\input{05.tex}

\pagebreak 
\addcontentsline{toc}{chapter}{Bibliografia}
\bibliographystyle{plain} 
\bibliography{00-taca}

\end{document}          

--- NEW FILE: 01.tex ---
(This appears to be a binary file; contents omitted.)

--- NEW FILE: 02.tex ---
(This appears to be a binary file; contents omitted.)

--- NEW FILE: 03.tex ---
(This appears to be a binary file; contents omitted.)

--- NEW FILE: 04.tex ---
(This appears to be a binary file; contents omitted.)

--- NEW FILE: 05.tex ---
(This appears to be a binary file; contents omitted.)

--- NEW FILE: esquema-supcl.dia ---
(This appears to be a binary file; contents omitted.)

--- NEW FILE: esquema-supcl.eps ---
%!PS-Adobe-2.0 EPSF-2.0
%%Title: esquema-supcl.dia
%%Creator: Dia v0.92.2
%%CreationDate: Sun Jun  6 01:56:35 2004
%%For: xxx
%%Orientation: Portrait
%%Magnification: 1.0000
%%BoundingBox: 0 0 929 611
%%BeginSetup
%%EndSetup
%%EndComments
%%BeginProlog
[ /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
/.notdef /.notdef /space /exclam /quotedbl /numbersign /dollar /percent /ampersand /quoteright
/parenleft /parenright /asterisk /plus /comma /hyphen /period /slash /zero /one
/two /three /four /five /six /seven /eight /nine /colon /semicolon
/less /equal /greater /question /at /A /B /C /D /E
/F /G /H /I /J /K /L /M /N /O
/P /Q /R /S /T /U /V /W /X /Y
/Z /bracketleft /backslash /bracketright /asciicircum /underscore /quoteleft /a /b /c
/d /e /f /g /h /i /j /k /l /m
/n /o /p /q /r /s /t /u /v /w
/x /y /z /braceleft /bar /braceright /asciitilde /.notdef /.notdef /.notdef
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
/space /exclamdown /cent /sterling /currency /yen /brokenbar /section /dieresis /copyright
/ordfeminine /guillemotleft /logicalnot /hyphen /registered /macron /degree /plusminus /twosuperior /threesuperior
/acute /mu /paragraph /periodcentered /cedilla /onesuperior /ordmasculine /guillemotright /onequarter /onehalf
/threequarters /questiondown /Agrave /Aacute /Acircumflex /Atilde /Adieresis /Aring /AE /Ccedilla
/Egrave /Eacute /Ecircumflex /Edieresis /Igrave /Iacute /Icircumflex /Idieresis /Eth /Ntilde
/Ograve /Oacute /Ocircumflex /Otilde /Odieresis /multiply /Oslash /Ugrave /Uacute /Ucircumflex
/Udieresis /Yacute /Thorn /germandbls /agrave /aacute /acircumflex /atilde /adieresis /aring
/ae /ccedilla /egrave /eacute /ecircumflex /edieresis /igrave /iacute /icircumflex /idieresis
/eth /ntilde /ograve /oacute /ocircumflex /otilde /odieresis /divide /oslash /ugrave
/uacute /ucircumflex /udieresis /yacute /thorn /ydieresis] /isolatin1encoding exch def
/cp {closepath} bind def
/c {curveto} bind def
/f {fill} bind def
/a {arc} bind def
/ef {eofill} bind def
/ex {exch} bind def
/gr {grestore} bind def
/gs {gsave} bind def
/sa {save} bind def
/rs {restore} bind def
/l {lineto} bind def
/m {moveto} bind def
/rm {rmoveto} bind def
/n {newpath} bind def
/s {stroke} bind def
/sh {show} bind def
/slc {setlinecap} bind def
/slj {setlinejoin} bind def
/slw {setlinewidth} bind def
/srgb {setrgbcolor} bind def
/rot {rotate} bind def
/sc {scale} bind def
/sd {setdash} bind def
/ff {findfont} bind def
/sf {setfont} bind def
/scf {scalefont} bind def
/sw {stringwidth pop} bind def
/tr {translate} bind def

/ellipsedict 8 dict def
ellipsedict /mtrx matrix put
/ellipse
{ ellipsedict begin
   /endangle exch def
   /startangle exch def
   /yrad exch def
   /xrad exch def
   /y exch def
   /x exch def   /savematrix mtrx currentmatrix def
   x y tr xrad yrad sc
   0 0 1 startangle endangle arc
   savematrix setmatrix
   end
} def

/mergeprocs {
dup length
3 -1 roll
dup
length
dup
5 1 roll
3 -1 roll
add
array cvx
dup
3 -1 roll
0 exch
putinterval
dup
4 2 roll
putinterval
} bind def
/Times-Roman-latin1
    /Times-Roman findfont
    dup length dict begin
	{1 index /FID ne {def} {pop pop} ifelse} forall
	/Encoding isolatin1encoding def
    currentdict end
definefont pop
/Times-Italic-latin1
    /Times-Italic findfont
    dup length dict begin
	{1 index /FID ne {def} {pop pop} ifelse} forall
	/Encoding isolatin1encoding def
    currentdict end
definefont pop
/Times-Bold-latin1
    /Times-Bold findfont
    dup length dict begin
	{1 index /FID ne {def} {pop pop} ifelse} forall
	/Encoding isolatin1encoding def
    currentdict end
definefont pop
/Times-BoldItalic-latin1
    /Times-BoldItalic findfont
    dup length dict begin
	{1 index /FID ne {def} {pop pop} ifelse} forall
	/Encoding isolatin1encoding def
    currentdict end
definefont pop
/AvantGarde-Book-latin1
    /AvantGarde-Book findfont
    dup length dict begin
	{1 index /FID ne {def} {pop pop} ifelse} forall
	/Encoding isolatin1encoding def
    currentdict end
definefont pop
/AvantGarde-BookOblique-latin1
    /AvantGarde-BookOblique findfont
    dup length dict begin
	{1 index /FID ne {def} {pop pop} ifelse} forall
	/Encoding isolatin1encoding def
    currentdict end
definefont pop
/AvantGarde-Demi-latin1
    /AvantGarde-Demi findfont
    dup length dict begin
	{1 index /FID ne {def} {pop pop} ifelse} forall
	/Encoding isolatin1encoding def
    currentdict end
definefont pop
/AvantGarde-DemiOblique-latin1
    /AvantGarde-DemiOblique findfont
    dup length dict begin
	{1 index /FID ne {def} {pop pop} ifelse} forall
	/Encoding isolatin1encoding def
    currentdict end
definefont pop
/Bookman-Light-latin1
    /Bookman-Light findfont
    dup length dict begin
	{1 index /FID ne {def} {pop pop} ifelse} forall
	/Encoding isolatin1encoding def
    currentdict end
definefont pop
/Bookman-LightItalic-latin1
    /Bookman-LightItalic findfont
    dup length dict begin
	{1 index /FID ne {def} {pop pop} ifelse} forall
	/Encoding isolatin1encoding def
    currentdict end
definefont pop
/Bookman-Demi-latin1
    /Bookman-Demi findfont
    dup length dict begin
	{1 index /FID ne {def} {pop pop} ifelse} forall
	/Encoding isolatin1encoding def
    currentdict end
definefont pop
/Bookman-DemiItalic-latin1
    /Bookman-DemiItalic findfont
    dup length dict begin
	{1 index /FID ne {def} {pop pop} ifelse} forall
	/Encoding isolatin1encoding def
    currentdict end
definefont pop
/Courier-latin1
    /Courier findfont
    dup length dict begin
	{1 index /FID ne {def} {pop pop} ifelse} forall
	/Encoding isolatin1encoding def
    currentdict end
definefont pop
/Courier-Oblique-latin1
    /Courier-Oblique findfont
    dup length dict begin
	{1 index /FID ne {def} {pop pop} ifelse} forall
	/Encoding isolatin1encoding def
    currentdict end
definefont pop
/Courier-Bold-latin1
    /Courier-Bold findfont
    dup length dict begin
	{1 index /FID ne {def} {pop pop} ifelse} forall
	/Encoding isolatin1encoding def
    currentdict end
definefont pop
/Courier-BoldOblique-latin1
    /Courier-BoldOblique findfont
    dup length dict begin
	{1 index /FID ne {def} {pop pop} ifelse} forall
	/Encoding isolatin1encoding def
    currentdict end
definefont pop
/Helvetica-latin1
    /Helvetica findfont
    dup length dict begin
	{1 index /FID ne {def} {pop pop} ifelse} forall
	/Encoding isolatin1encoding def
    currentdict end
definefont pop
/Helvetica-Oblique-latin1
    /Helvetica-Oblique findfont
    dup length dict begin
	{1 index /FID ne {def} {pop pop} ifelse} forall
	/Encoding isolatin1encoding def
    currentdict end
definefont pop
/Helvetica-Bold-latin1
    /Helvetica-Bold findfont
    dup length dict begin
	{1 index /FID ne {def} {pop pop} ifelse} forall
	/Encoding isolatin1encoding def
    currentdict end
definefont pop
/Helvetica-BoldOblique-latin1
    /Helvetica-BoldOblique findfont
    dup length dict begin
	{1 index /FID ne {def} {pop pop} ifelse} forall
	/Encoding isolatin1encoding def
    currentdict end
definefont pop
/Helvetica-Narrow-latin1
    /Helvetica-Narrow findfont
    dup length dict begin
	{1 index /FID ne {def} {pop pop} ifelse} forall
	/Encoding isolatin1encoding def
    currentdict end
definefont pop
/Helvetica-Narrow-Oblique-latin1
    /Helvetica-Narrow-Oblique findfont
    dup length dict begin
	{1 index /FID ne {def} {pop pop} ifelse} forall
	/Encoding isolatin1encoding def
    currentdict end
definefont pop
/Helvetica-Narrow-Bold-latin1
    /Helvetica-Narrow-Bold findfont
    dup length dict begin
	{1 index /FID ne {def} {pop pop} ifelse} forall
	/Encoding isolatin1encoding def
    currentdict end
definefont pop
/Helvetica-Narrow-BoldOblique-latin1
    /Helvetica-Narrow-BoldOblique findfont
    dup length dict begin
	{1 index /FID ne {def} {pop pop} ifelse} forall
	/Encoding isolatin1encoding def
    currentdict end
definefont pop
/NewCenturySchoolbook-Roman-latin1
    /NewCenturySchoolbook-Roman findfont
    dup length dict begin
	{1 index /FID ne {def} {pop pop} ifelse} forall
	/Encoding isolatin1encoding def
    currentdict end
definefont pop
/NewCenturySchoolbook-Italic-latin1
    /NewCenturySchoolbook-Italic findfont
    dup length dict begin
	{1 index /FID ne {def} {pop pop} ifelse} forall
	/Encoding isolatin1encoding def
    currentdict end
definefont pop
/NewCenturySchoolbook-Bold-latin1
    /NewCenturySchoolbook-Bold findfont
    dup length dict begin
	{1 index /FID ne {def} {pop pop} ifelse} forall
	/Encoding isolatin1encoding def
    currentdict end
definefont pop
/NewCenturySchoolbook-BoldItalic-latin1
    /NewCenturySchoolbook-BoldItalic findfont
    dup length dict begin
	{1 index /FID ne {def} {pop pop} ifelse} forall
	/Encoding isolatin1encoding def
    currentdict end
definefont pop
/Palatino-Roman-latin1
    /Palatino-Roman findfont
    dup length dict begin
	{1 index /FID ne {def} {pop pop} ifelse} forall
	/Encoding isolatin1encoding def
    currentdict end
definefont pop
/Palatino-Italic-latin1
    /Palatino-Italic findfont
    dup length dict begin
	{1 index /FID ne {def} {pop pop} ifelse} forall
	/Encoding isolatin1encoding def
    currentdict end
definefont pop
/Palatino-Bold-latin1
    /Palatino-Bold findfont
    dup length dict begin
	{1 index /FID ne {def} {pop pop} ifelse} forall
	/Encoding isolatin1encoding def
    currentdict end
definefont pop
/Palatino-BoldItalic-latin1
    /Palatino-BoldItalic findfont
    dup length dict begin
	{1 index /FID ne {def} {pop pop} ifelse} forall
	/Encoding isolatin1encoding def
    currentdict end
definefont pop
/Symbol-latin1
    /Symbol findfont
definefont pop
/ZapfChancery-MediumItalic-latin1
    /ZapfChancery-MediumItalic findfont
    dup length dict begin
	{1 index /FID ne {def} {pop pop} ifelse} forall
	/Encoding isolatin1encoding def
    currentdict end
definefont pop
/ZapfDingbats-latin1
    /ZapfDingbats findfont
    dup length dict begin
	{1 index /FID ne {def} {pop pop} ifelse} forall
	/Encoding isolatin1encoding def
    currentdict end
definefont pop
28.346000 -28.346000 scale
-5.800000 -31.117400 translate
%%EndProlog


0.100000 slw
[] 0 sd
[] 0 sd
0 slj
0.000000 0.000000 0.000000 srgb
n 5.850000 20.220000 m 5.850000 31.067400 l 22.350000 31.067400 l 22.350000 20.220000 l cp s
1.000000 1.000000 1.000000 srgb
n 9.075000 23.925000 1.875000 1.775000 0 360 ellipse f
0.100000 slw
[] 0 sd
[] 0 sd
0.000000 0.000000 0.000000 srgb
n 9.075000 23.925000 1.875000 1.775000 0 360 ellipse cp s
/Helvetica-latin1 ff 0.560000 scf sf
(Kernel) 8.150000 24.200000 m gs 1 -1 sc sh gr
0.100000 slw
[] 0 sd
[] 0 sd
n 14.875000 23.925000 1.825000 1.775000 0 360 ellipse cp s
/Helvetica-latin1 ff 0.560000 scf sf
(   Suport) 13.300000 23.700000 m gs 1 -1 sc sh gr
(Clustering) 13.300000 24.500000 m gs 1 -1 sc sh gr
0.100000 slw
[] 0 sd
[] 0 sd
0 slc
n 10.950000 23.925000 m 13.050000 23.925000 l s
0.100000 slw
[] 0 sd
0 slj
0 slc
n 11.750000 23.725000 m 10.950000 23.925000 l 11.750000 24.125000 l s
0.100000 slw
[] 0 sd
[] 0 sd
0 slc
n 16.700000 23.925000 m 18.000000 23.925000 l s
0.100000 slw
[] 0 sd
0 slj
0 slc
n 17.500000 23.725000 m 16.700000 23.925000 l 17.500000 24.125000 l s
0.100000 slw
[] 0 sd
[] 0 sd
n 14.875000 17.375000 1.825000 1.775000 0 360 ellipse cp s
/Helvetica-latin1 ff 0.560000 scf sf
(  Utilitats) 13.300000 17.150000 m gs 1 -1 sc sh gr
(Clustering) 13.300000 17.950000 m gs 1 -1 sc sh gr
0.100000 slw
[] 0 sd
[] 0 sd
0 slc
n 14.875000 22.150000 m 14.875000 19.150000 l s
0.100000 slw
[] 0 sd
0 slj
0 slc
n 14.675000 21.350000 m 14.875000 22.150000 l 15.075000 21.350000 l s
0.100000 slw
[] 0 sd
[] 0 sd
n 18.960000 11.545000 1.825000 1.775000 0 360 ellipse cp s
/Helvetica-latin1 ff 0.560000 scf sf
(Usuari) 18.000000 11.800000 m gs 1 -1 sc sh gr
0.100000 slw
[] 0 sd
[] 0 sd
0 slc
n 14.875000 15.600000 m 17.669500 12.800100 l s
0.100000 slw
[] 0 sd
0 slj
0 slc
n 15.298581 14.892484 m 14.875000 15.600000 l 15.581697 15.175054 l s
/Helvetica-latin1 ff 0.560000 scf sf
(Microkernel) 6.550000 21.520000 m gs 1 -1 sc sh gr
/Helvetica-latin1 ff 0.560000 scf sf
(Nucli monol?tic) 5.850000 20.220000 m gs 1 -1 sc sh gr
0.100000 slw
[] 0 sd
[] 0 sd
0 slc
n 19.825000 22.150000 m 18.960000 13.320000 l s
0.100000 slw
[] 0 sd
0 slj
0 slc
n 19.547957 21.373310 m 19.825000 22.150000 l 19.946051 21.334312 l s
0.100000 slw
[0.200000] 0 sd
[0.200000] 0 sd
0 slj
n 6.550000 21.520000 m 6.550000 26.320000 l 12.000000 26.320000 l 12.000000 21.520000 l cp s
0.100000 slw
[] 0 sd
[] 0 sd
0 slc
n 14.875000 25.700000 m 14.875000 27.070000 l s
0.100000 slw
[] 0 sd
0 slj
0 slc
n 15.075000 26.500000 m 14.875000 25.700000 l 14.675000 26.500000 l s
/Helvetica-latin1 ff 0.560000 scf sf
1.000000 0.000000 0.000000 srgb
(1) 20.250500 10.289900 m gs 1 -1 sc sh gr
/Helvetica-latin1 ff 0.560000 scf sf
(3) 10.400800 22.669900 m gs 1 -1 sc sh gr
/Helvetica-latin1 ff 0.560000 scf sf
(6) 16.165500 27.589900 m gs 1 -1 sc sh gr
/Helvetica-latin1 ff 0.560000 scf sf
(4) 16.165500 22.669900 m gs 1 -1 sc sh gr
/Helvetica-latin1 ff 0.560000 scf sf
(2) 16.165500 16.119900 m gs 1 -1 sc sh gr
0.100000 slw
[] 0 sd
[] 0 sd
0.000000 0.000000 0.000000 srgb
n 14.875000 28.845000 1.825000 1.775000 0 360 ellipse cp s
/Helvetica-latin1 ff 0.560000 scf sf
(  Control) 13.300000 28.670000 m gs 1 -1 sc sh gr
(Distribuci?) 13.300000 29.470000 m gs 1 -1 sc sh gr
0.100000 slw
[] 0 sd
[] 0 sd
n 19.825000 23.925000 1.825000 1.775000 0 360 ellipse cp s
/Helvetica-latin1 ff 0.560000 scf sf
(TACAFS) 18.801500 24.205800 m gs 1 -1 sc sh gr
/Helvetica-latin1 ff 0.560000 scf sf
1.000000 0.000000 0.000000 srgb
(5) 21.115500 22.669900 m gs 1 -1 sc sh gr
0.050000 slw
[] 0 sd
[] 0 sd
0 slj
0.000000 0.000000 0.000000 srgb
n 23.172900 20.222900 m 38.022900 20.222900 l s
n 23.172900 27.672900 m 38.022900 27.672900 l s
n 23.172900 20.722900 0.500000 0.500000 180.000000 270.000000 ellipse s
n 38.022900 20.722900 0.500000 0.500000 270.000000 360.000000 ellipse s
n 22.672900 20.722900 m 22.672900 27.172900 l s
n 38.522900 20.722900 m 38.522900 27.172900 l s
n 23.172900 27.172900 0.500000 0.500000 90.000000 180.000000 ellipse s
n 38.022900 27.172900 0.500000 0.500000 0.000000 90.000000 ellipse s
1.000000 1.000000 1.000000 srgb
n 23.350000 21.970000 0.400000 0.400000 0 360 ellipse f
0.050000 slw
[] 0 sd
[] 0 sd
0.000000 0.000000 0.000000 srgb
n 23.350000 21.970000 0.400000 0.400000 0 360 ellipse cp s
/Helvetica-latin1 ff 0.560000 scf sf
(1) 23.172300 22.203200 m gs 1 -1 sc sh gr
/Helvetica-latin1 ff 0.560000 scf sf
(  Usuari) 23.632800 22.252800 m gs 1 -1 sc sh gr
1.000000 1.000000 1.000000 srgb
n 23.340000 22.990000 0.400000 0.400000 0 360 ellipse f
0.050000 slw
[] 0 sd
[] 0 sd
0.000000 0.000000 0.000000 srgb
n 23.340000 22.990000 0.400000 0.400000 0 360 ellipse cp s
/Helvetica-latin1 ff 0.560000 scf sf
(2) 23.154600 23.227900 m gs 1 -1 sc sh gr
/Helvetica-latin1 ff 0.560000 scf sf
(  Utilitats d'administraci? del cluster) 23.622800 23.272800 m gs 1 -1 sc sh gr
1.000000 1.000000 1.000000 srgb
n 23.340000 23.990000 0.400000 0.400000 0 360 ellipse f
0.050000 slw
[] 0 sd
[] 0 sd
0.000000 0.000000 0.000000 srgb
n 23.340000 23.990000 0.400000 0.400000 0 360 ellipse cp s
/Helvetica-latin1 ff 0.560000 scf sf
(3) 23.154600 24.235000 m gs 1 -1 sc sh gr
/Helvetica-latin1 ff 0.560000 scf sf
(  Nucli del SO) 23.622800 24.272800 m gs 1 -1 sc sh gr
1.000000 1.000000 1.000000 srgb
n 23.340000 24.990000 0.400000 0.400000 0 360 ellipse f
0.050000 slw
[] 0 sd
[] 0 sd
0.000000 0.000000 0.000000 srgb
n 23.340000 24.990000 0.400000 0.400000 0 360 ellipse cp s
/Helvetica-latin1 ff 0.560000 scf sf
(4) 23.154600 25.206700 m gs 1 -1 sc sh gr
/Helvetica-latin1 ff 0.560000 scf sf
(  Primitives de control \(migraci?, informaci?, ...\)) 23.622800 25.272800 m gs 1 -1 sc sh gr
1.000000 1.000000 1.000000 srgb
n 23.340000 26.040000 0.400000 0.400000 0 360 ellipse f
0.050000 slw
[] 0 sd
[] 0 sd
0.000000 0.000000 0.000000 srgb
n 23.340000 26.040000 0.400000 0.400000 0 360 ellipse cp s
/Helvetica-latin1 ff 0.560000 scf sf
(5) 23.154600 26.302100 m gs 1 -1 sc sh gr
/Helvetica-latin1 ff 0.560000 scf sf
(  Interf?cie de control \(TACA File System\)) 23.622800 26.322800 m gs 1 -1 sc sh gr
1.000000 1.000000 1.000000 srgb
n 23.340000 27.040000 0.400000 0.400000 0 360 ellipse f
0.050000 slw
[] 0 sd
[] 0 sd
0.000000 0.000000 0.000000 srgb
n 23.340000 27.040000 0.400000 0.400000 0 360 ellipse cp s
/Helvetica-latin1 ff 0.560000 scf sf
(6) 23.145500 27.269800 m gs 1 -1 sc sh gr
/Helvetica-latin1 ff 0.560000 scf sf
(  Control de la distribuci?) 23.622800 27.322800 m gs 1 -1 sc sh gr
/Helvetica-latin1 ff 0.560000 scf sf
(Llegenda) 29.151500 20.943200 m gs 1 -1 sc sh gr
0.050000 slw
[] 0 sd
[] 0 sd
0 slc
n 22.677600 21.072400 m 38.508200 21.072400 l s
showpage

--- NEW FILE: esquema-utilcl.dia ---
(This appears to be a binary file; contents omitted.)

--- NEW FILE: esquema-utilcl.eps ---
%!PS-Adobe-2.0 EPSF-2.0
%%Title: /home/xxx/downloads/FIB/dso/labo/P2/taca/doc/esquema-utilcl.dia
%%Creator: Dia v0.92.2
%%CreationDate: Sun Jun  6 01:56:40 2004
%%For: xxx
%%Orientation: Portrait
%%Magnification: 1.0000
%%BoundingBox: 0 0 929 611
%%BeginSetup
%%EndSetup
%%EndComments
%%BeginProlog
[ /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
/.notdef /.notdef /space /exclam /quotedbl /numbersign /dollar /percent /ampersand /quoteright
/parenleft /parenright /asterisk /plus /comma /hyphen /period /slash /zero /one
/two /three /four /five /six /seven /eight /nine /colon /semicolon
/less /equal /greater /question /at /A /B /C /D /E
/F /G /H /I /J /K /L /M /N /O
/P /Q /R /S /T /U /V /W /X /Y
/Z /bracketleft /backslash /bracketright /asciicircum /underscore /quoteleft /a /b /c
/d /e /f /g /h /i /j /k /l /m
/n /o /p /q /r /s /t /u /v /w
/x /y /z /braceleft /bar /braceright /asciitilde /.notdef /.notdef /.notdef
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
/space /exclamdown /cent /sterling /currency /yen /brokenbar /section /dieresis /copyright
/ordfeminine /guillemotleft /logicalnot /hyphen /registered /macron /degree /plusminus /twosuperior /threesuperior
/acute /mu /paragraph /periodcentered /cedilla /onesuperior /ordmasculine /guillemotright /onequarter /onehalf
/threequarters /questiondown /Agrave /Aacute /Acircumflex /Atilde /Adieresis /Aring /AE /Ccedilla
/Egrave /Eacute /Ecircumflex /Edieresis /Igrave /Iacute /Icircumflex /Idieresis /Eth /Ntilde
/Ograve /Oacute /Ocircumflex /Otilde /Odieresis /multiply /Oslash /Ugrave /Uacute /Ucircumflex
/Udieresis /Yacute /Thorn /germandbls /agrave /aacute /acircumflex /atilde /adieresis /aring
/ae /ccedilla /egrave /eacute /ecircumflex /edieresis /igrave /iacute /icircumflex /idieresis
/eth /ntilde /ograve /oacute /ocircumflex /otilde /odieresis /divide /oslash /ugrave
/uacute /ucircumflex /udieresis /yacute /thorn /ydieresis] /isolatin1encoding exch def
/cp {closepath} bind def
/c {curveto} bind def
/f {fill} bind def
/a {arc} bind def
/ef {eofill} bind def
/ex {exch} bind def
/gr {grestore} bind def
/gs {gsave} bind def
/sa {save} bind def
/rs {restore} bind def
/l {lineto} bind def
/m {moveto} bind def
/rm {rmoveto} bind def
/n {newpath} bind def
/s {stroke} bind def
/sh {show} bind def
/slc {setlinecap} bind def
/slj {setlinejoin} bind def
/slw {setlinewidth} bind def
/srgb {setrgbcolor} bind def
/rot {rotate} bind def
/sc {scale} bind def
/sd {setdash} bind def
/ff {findfont} bind def
/sf {setfont} bind def
/scf {scalefont} bind def
/sw {stringwidth pop} bind def
/tr {translate} bind def

/ellipsedict 8 dict def
ellipsedict /mtrx matrix put
/ellipse
{ ellipsedict begin
   /endangle exch def
   /startangle exch def
   /yrad exch def
   /xrad exch def
   /y exch def
   /x exch def   /savematrix mtrx currentmatrix def
   x y tr xrad yrad sc
   0 0 1 startangle endangle arc
   savematrix setmatrix
   end
} def

/mergeprocs {
dup length
3 -1 roll
dup
length
dup
5 1 roll
3 -1 roll
add
array cvx
dup
3 -1 roll
0 exch
putinterval
dup
4 2 roll
putinterval
} bind def
/Times-Roman-latin1
    /Times-Roman findfont
    dup length dict begin
	{1 index /FID ne {def} {pop pop} ifelse} forall
	/Encoding isolatin1encoding def
    currentdict end
definefont pop
/Times-Italic-latin1
    /Times-Italic findfont
    dup length dict begin
	{1 index /FID ne {def} {pop pop} ifelse} forall
	/Encoding isolatin1encoding def
    currentdict end
definefont pop
/Times-Bold-latin1
    /Times-Bold findfont
    dup length dict begin
	{1 index /FID ne {def} {pop pop} ifelse} forall
	/Encoding isolatin1encoding def
    currentdict end
definefont pop
/Times-BoldItalic-latin1
    /Times-BoldItalic findfont
    dup length dict begin
	{1 index /FID ne {def} {pop pop} ifelse} forall
	/Encoding isolatin1encoding def
    currentdict end
definefont pop
/AvantGarde-Book-latin1
    /AvantGarde-Book findfont
    dup length dict begin
	{1 index /FID ne {def} {pop pop} ifelse} forall
	/Encoding isolatin1encoding def
    currentdict end
definefont pop
/AvantGarde-BookOblique-latin1
    /AvantGarde-BookOblique findfont
    dup length dict begin
	{1 index /FID ne {def} {pop pop} ifelse} forall
	/Encoding isolatin1encoding def
    currentdict end
definefont pop
/AvantGarde-Demi-latin1
    /AvantGarde-Demi findfont
    dup length dict begin
	{1 index /FID ne {def} {pop pop} ifelse} forall
	/Encoding isolatin1encoding def
    currentdict end
definefont pop
/AvantGarde-DemiOblique-latin1
    /AvantGarde-DemiOblique findfont
    dup length dict begin
	{1 index /FID ne {def} {pop pop} ifelse} forall
	/Encoding isolatin1encoding def
    currentdict end
definefont pop
/Bookman-Light-latin1
    /Bookman-Light findfont
    dup length dict begin
	{1 index /FID ne {def} {pop pop} ifelse} forall
	/Encoding isolatin1encoding def
    currentdict end
definefont pop
/Bookman-LightItalic-latin1
    /Bookman-LightItalic findfont
    dup length dict begin
	{1 index /FID ne {def} {pop pop} ifelse} forall
	/Encoding isolatin1encoding def
    currentdict end
definefont pop
/Bookman-Demi-latin1
    /Bookman-Demi findfont
    dup length dict begin
	{1 index /FID ne {def} {pop pop} ifelse} forall
	/Encoding isolatin1encoding def
    currentdict end
definefont pop
/Bookman-DemiItalic-latin1
    /Bookman-DemiItalic findfont
    dup length dict begin
	{1 index /FID ne {def} {pop pop} ifelse} forall
	/Encoding isolatin1encoding def
    currentdict end
definefont pop
/Courier-latin1
    /Courier findfont
    dup length dict begin
	{1 index /FID ne {def} {pop pop} ifelse} forall
	/Encoding isolatin1encoding def
    currentdict end
definefont pop
/Courier-Oblique-latin1
    /Courier-Oblique findfont
    dup length dict begin
	{1 index /FID ne {def} {pop pop} ifelse} forall
	/Encoding isolatin1encoding def
    currentdict end
definefont pop
/Courier-Bold-latin1
    /Courier-Bold findfont
    dup length dict begin
	{1 index /FID ne {def} {pop pop} ifelse} forall
	/Encoding isolatin1encoding def
    currentdict end
definefont pop
/Courier-BoldOblique-latin1
    /Courier-BoldOblique findfont
    dup length dict begin
	{1 index /FID ne {def} {pop pop} ifelse} forall
	/Encoding isolatin1encoding def
    currentdict end
definefont pop
/Helvetica-latin1
    /Helvetica findfont
    dup length dict begin
	{1 index /FID ne {def} {pop pop} ifelse} forall
	/Encoding isolatin1encoding def
    currentdict end
definefont pop
/Helvetica-Oblique-latin1
    /Helvetica-Oblique findfont
    dup length dict begin
	{1 index /FID ne {def} {pop pop} ifelse} forall
	/Encoding isolatin1encoding def
    currentdict end
definefont pop
/Helvetica-Bold-latin1
    /Helvetica-Bold findfont
    dup length dict begin
	{1 index /FID ne {def} {pop pop} ifelse} forall
	/Encoding isolatin1encoding def
    currentdict end
definefont pop
/Helvetica-BoldOblique-latin1
    /Helvetica-BoldOblique findfont
    dup length dict begin
	{1 index /FID ne {def} {pop pop} ifelse} forall
	/Encoding isolatin1encoding def
    currentdict end
definefont pop
/Helvetica-Narrow-latin1
    /Helvetica-Narrow findfont
    dup length dict begin
	{1 index /FID ne {def} {pop pop} ifelse} forall
	/Encoding isolatin1encoding def
    currentdict end
definefont pop
/Helvetica-Narrow-Oblique-latin1
    /Helvetica-Narrow-Oblique findfont
    dup length dict begin
	{1 index /FID ne {def} {pop pop} ifelse} forall
	/Encoding isolatin1encoding def
    currentdict end
definefont pop
/Helvetica-Narrow-Bold-latin1
    /Helvetica-Narrow-Bold findfont
    dup length dict begin
	{1 index /FID ne {def} {pop pop} ifelse} forall
	/Encoding isolatin1encoding def
    currentdict end
definefont pop
/Helvetica-Narrow-BoldOblique-latin1
    /Helvetica-Narrow-BoldOblique findfont
    dup length dict begin
	{1 index /FID ne {def} {pop pop} ifelse} forall
	/Encoding isolatin1encoding def
    currentdict end
definefont pop
/NewCenturySchoolbook-Roman-latin1
    /NewCenturySchoolbook-Roman findfont
    dup length dict begin
	{1 index /FID ne {def} {pop pop} ifelse} forall
	/Encoding isolatin1encoding def
    currentdict end
definefont pop
/NewCenturySchoolbook-Italic-latin1
    /NewCenturySchoolbook-Italic findfont
    dup length dict begin
	{1 index /FID ne {def} {pop pop} ifelse} forall
	/Encoding isolatin1encoding def
    currentdict end
definefont pop
/NewCenturySchoolbook-Bold-latin1
    /NewCenturySchoolbook-Bold findfont
    dup length dict begin
	{1 index /FID ne {def} {pop pop} ifelse} forall
	/Encoding isolatin1encoding def
    currentdict end
definefont pop
/NewCenturySchoolbook-BoldItalic-latin1
    /NewCenturySchoolbook-BoldItalic findfont
    dup length dict begin
	{1 index /FID ne {def} {pop pop} ifelse} forall
	/Encoding isolatin1encoding def
    currentdict end
definefont pop
/Palatino-Roman-latin1
    /Palatino-Roman findfont
    dup length dict begin
	{1 index /FID ne {def} {pop pop} ifelse} forall
	/Encoding isolatin1encoding def
    currentdict end
definefont pop
/Palatino-Italic-latin1
    /Palatino-Italic findfont
    dup length dict begin
	{1 index /FID ne {def} {pop pop} ifelse} forall
	/Encoding isolatin1encoding def
    currentdict end
definefont pop
/Palatino-Bold-latin1
    /Palatino-Bold findfont
    dup length dict begin
	{1 index /FID ne {def} {pop pop} ifelse} forall
	/Encoding isolatin1encoding def
    currentdict end
definefont pop
/Palatino-BoldItalic-latin1
    /Palatino-BoldItalic findfont
    dup length dict begin
	{1 index /FID ne {def} {pop pop} ifelse} forall
	/Encoding isolatin1encoding def
    currentdict end
definefont pop
/Symbol-latin1
    /Symbol findfont
definefont pop
/ZapfChancery-MediumItalic-latin1
    /ZapfChancery-MediumItalic findfont
    dup length dict begin
	{1 index /FID ne {def} {pop pop} ifelse} forall
	/Encoding isolatin1encoding def
    currentdict end
definefont pop
/ZapfDingbats-latin1
    /ZapfDingbats findfont
    dup length dict begin
	{1 index /FID ne {def} {pop pop} ifelse} forall
	/Encoding isolatin1encoding def
    currentdict end
definefont pop
28.346000 -28.346000 scale
-5.800000 -31.117400 translate
%%EndProlog


0.100000 slw
[] 0 sd
[] 0 sd
0 slj
0.000000 0.000000 0.000000 srgb
n 5.850000 20.220000 m 5.850000 31.067400 l 22.350000 31.067400 l 22.350000 20.220000 l cp s
1.000000 1.000000 1.000000 srgb
n 9.075000 23.925000 1.875000 1.775000 0 360 ellipse f
0.100000 slw
[] 0 sd
[] 0 sd
0.000000 0.000000 0.000000 srgb
n 9.075000 23.925000 1.875000 1.775000 0 360 ellipse cp s
/Helvetica-latin1 ff 0.560000 scf sf
(Kernel) 8.150000 24.200000 m gs 1 -1 sc sh gr
0.100000 slw
[] 0 sd
[] 0 sd
n 14.875000 23.925000 1.825000 1.775000 0 360 ellipse cp s
/Helvetica-latin1 ff 0.560000 scf sf
(   Suport) 13.300000 23.700000 m gs 1 -1 sc sh gr
(Clustering) 13.300000 24.500000 m gs 1 -1 sc sh gr
0.100000 slw
[] 0 sd
[] 0 sd
0 slc
n 10.950000 23.925000 m 13.050000 23.925000 l s
0.100000 slw
[] 0 sd
0 slj
0 slc
n 11.750000 23.725000 m 10.950000 23.925000 l 11.750000 24.125000 l s
0.100000 slw
[] 0 sd
[] 0 sd
0 slc
n 16.165500 18.630100 m 18.534500 22.669900 l s
0.100000 slw
[] 0 sd
0 slj
0 slc
n 16.742706 19.219025 m 16.165500 18.630100 l 16.397659 19.421366 l s
0.100000 slw
[] 0 sd
[] 0 sd
n 14.875000 17.375000 1.825000 1.775000 0 360 ellipse cp s
/Helvetica-latin1 ff 0.560000 scf sf
(  Utilitats) 13.300000 17.150000 m gs 1 -1 sc sh gr
(Clustering) 13.300000 17.950000 m gs 1 -1 sc sh gr
0.100000 slw
[] 0 sd
[] 0 sd
0 slc
n 14.875000 22.150000 m 14.875000 19.150000 l s
0.100000 slw
[] 0 sd
0 slj
0 slc
n 14.675000 21.350000 m 14.875000 22.150000 l 15.075000 21.350000 l s
0.100000 slw
[] 0 sd
[] 0 sd
n 18.960000 11.545000 1.825000 1.775000 0 360 ellipse cp s
/Helvetica-latin1 ff 0.560000 scf sf
(Usuari) 18.000000 11.800000 m gs 1 -1 sc sh gr
0.100000 slw
[] 0 sd
[] 0 sd
0 slc
n 14.875000 15.600000 m 17.669500 12.800100 l s
0.100000 slw
[] 0 sd
0 slj
0 slc
n 15.298581 14.892484 m 14.875000 15.600000 l 15.581697 15.175054 l s
/Helvetica-latin1 ff 0.560000 scf sf
(Microkernel) 6.550000 21.520000 m gs 1 -1 sc sh gr
/Helvetica-latin1 ff 0.560000 scf sf
(Nucli monol?tic) 5.850000 20.220000 m gs 1 -1 sc sh gr
0.100000 slw
[] 0 sd
[] 0 sd
0 slc
n 19.825000 22.150000 m 18.960000 13.320000 l s
0.100000 slw
[] 0 sd
0 slj
0 slc
n 19.547957 21.373310 m 19.825000 22.150000 l 19.946051 21.334312 l s
0.100000 slw
[0.200000] 0 sd
[0.200000] 0 sd
0 slj
n 6.550000 21.520000 m 6.550000 26.320000 l 12.000000 26.320000 l 12.000000 21.520000 l cp s
0.100000 slw
[] 0 sd
[] 0 sd
0 slc
n 14.875000 25.700000 m 14.875000 27.070000 l s
0.100000 slw
[] 0 sd
0 slj
0 slc
n 15.075000 26.500000 m 14.875000 25.700000 l 14.675000 26.500000 l s
/Helvetica-latin1 ff 0.560000 scf sf
1.000000 0.000000 0.000000 srgb
(1) 20.250500 10.289900 m gs 1 -1 sc sh gr
/Helvetica-latin1 ff 0.560000 scf sf
(3) 10.400800 22.669900 m gs 1 -1 sc sh gr
/Helvetica-latin1 ff 0.560000 scf sf
(6) 16.165500 27.589900 m gs 1 -1 sc sh gr
/Helvetica-latin1 ff 0.560000 scf sf
(4) 16.165500 22.669900 m gs 1 -1 sc sh gr
/Helvetica-latin1 ff 0.560000 scf sf
(2) 16.165500 16.119900 m gs 1 -1 sc sh gr
0.100000 slw
[] 0 sd
[] 0 sd
0.000000 0.000000 0.000000 srgb
n 14.875000 28.845000 1.825000 1.775000 0 360 ellipse cp s
/Helvetica-latin1 ff 0.560000 scf sf
(  Control) 13.300000 28.670000 m gs 1 -1 sc sh gr
(Distribuci?) 13.300000 29.470000 m gs 1 -1 sc sh gr
0.100000 slw
[] 0 sd
[] 0 sd
n 19.825000 23.925000 1.825000 1.775000 0 360 ellipse cp s
/Helvetica-latin1 ff 0.560000 scf sf
(TACAFS) 18.801500 24.205800 m gs 1 -1 sc sh gr
/Helvetica-latin1 ff 0.560000 scf sf
1.000000 0.000000 0.000000 srgb
(5) 21.115500 22.669900 m gs 1 -1 sc sh gr
0.050000 slw
[] 0 sd
[] 0 sd
0 slj
0.000000 0.000000 0.000000 srgb
n 23.172900 20.222900 m 38.022900 20.222900 l s
n 23.172900 27.672900 m 38.022900 27.672900 l s
n 23.172900 20.722900 0.500000 0.500000 180.000000 270.000000 ellipse s
n 38.022900 20.722900 0.500000 0.500000 270.000000 360.000000 ellipse s
n 22.672900 20.722900 m 22.672900 27.172900 l s
n 38.522900 20.722900 m 38.522900 27.172900 l s
n 23.172900 27.172900 0.500000 0.500000 90.000000 180.000000 ellipse s
n 38.022900 27.172900 0.500000 0.500000 0.000000 90.000000 ellipse s
1.000000 1.000000 1.000000 srgb
n 23.350000 21.970000 0.400000 0.400000 0 360 ellipse f
0.050000 slw
[] 0 sd
[] 0 sd
0.000000 0.000000 0.000000 srgb
n 23.350000 21.970000 0.400000 0.400000 0 360 ellipse cp s
/Helvetica-latin1 ff 0.560000 scf sf
(1) 23.172300 22.203200 m gs 1 -1 sc sh gr
/Helvetica-latin1 ff 0.560000 scf sf
(  Usuari) 23.632800 22.252800 m gs 1 -1 sc sh gr
1.000000 1.000000 1.000000 srgb
n 23.340000 22.990000 0.400000 0.400000 0 360 ellipse f
0.050000 slw
[] 0 sd
[] 0 sd
0.000000 0.000000 0.000000 srgb
n 23.340000 22.990000 0.400000 0.400000 0 360 ellipse cp s
/Helvetica-latin1 ff 0.560000 scf sf
(2) 23.154600 23.227900 m gs 1 -1 sc sh gr
/Helvetica-latin1 ff 0.560000 scf sf
(  Utilitats d'administraci? del cluster) 23.622800 23.272800 m gs 1 -1 sc sh gr
1.000000 1.000000 1.000000 srgb
n 23.340000 23.990000 0.400000 0.400000 0 360 ellipse f
0.050000 slw
[] 0 sd
[] 0 sd
0.000000 0.000000 0.000000 srgb
n 23.340000 23.990000 0.400000 0.400000 0 360 ellipse cp s
/Helvetica-latin1 ff 0.560000 scf sf
(3) 23.154600 24.235000 m gs 1 -1 sc sh gr
/Helvetica-latin1 ff 0.560000 scf sf
(  Nucli del SO) 23.622800 24.272800 m gs 1 -1 sc sh gr
1.000000 1.000000 1.000000 srgb
n 23.340000 24.990000 0.400000 0.400000 0 360 ellipse f
0.050000 slw
[] 0 sd
[] 0 sd
0.000000 0.000000 0.000000 srgb
n 23.340000 24.990000 0.400000 0.400000 0 360 ellipse cp s
/Helvetica-latin1 ff 0.560000 scf sf
(4) 23.154600 25.206700 m gs 1 -1 sc sh gr
/Helvetica-latin1 ff 0.560000 scf sf
(  Primitives de control \(migraci?, informaci?, ...\)) 23.622800 25.272800 m gs 1 -1 sc sh gr
1.000000 1.000000 1.000000 srgb
n 23.340000 26.040000 0.400000 0.400000 0 360 ellipse f
0.050000 slw
[] 0 sd
[] 0 sd
0.000000 0.000000 0.000000 srgb
n 23.340000 26.040000 0.400000 0.400000 0 360 ellipse cp s
/Helvetica-latin1 ff 0.560000 scf sf
(5) 23.154600 26.302100 m gs 1 -1 sc sh gr
/Helvetica-latin1 ff 0.560000 scf sf
(  Interf?cie de control \(TACA File System\)) 23.622800 26.322800 m gs 1 -1 sc sh gr
1.000000 1.000000 1.000000 srgb
n 23.340000 27.040000 0.400000 0.400000 0 360 ellipse f
0.050000 slw
[] 0 sd
[] 0 sd
0.000000 0.000000 0.000000 srgb
n 23.340000 27.040000 0.400000 0.400000 0 360 ellipse cp s
/Helvetica-latin1 ff 0.560000 scf sf
(6) 23.145500 27.269800 m gs 1 -1 sc sh gr
/Helvetica-latin1 ff 0.560000 scf sf
(  Control de la distribuci?) 23.622800 27.322800 m gs 1 -1 sc sh gr
/Helvetica-latin1 ff 0.560000 scf sf
(Llegenda) 29.151500 20.943200 m gs 1 -1 sc sh gr
0.050000 slw
[] 0 sd
[] 0 sd
0 slc
n 22.677600 21.072400 m 38.508200 21.072400 l s
showpage

--- 00-index.txt DELETED ---

--- 01-text.txt DELETED ---

--- 02-text.txt DELETED ---

--- 04-text.txt DELETED ---



From nobody at sheep.berlios.de  Mon Jun  7 19:49:29 2004
From: nobody at sheep.berlios.de (albertfc)
Date: Mon, 7 Jun 2004 19:49:29 +0200
Subject: [Taca-cvs] doc 02.tex,1.1,1.2 03.tex,1.1,1.2
Message-ID: <200406071749.i57HnTB32051@bat.berlios.de>

Update of /cvsroot/taca/doc
In directory sheep:/tmp/cvs-serv22723

Modified Files:
	02.tex 03.tex 
Log Message:
Albert: Afegida la meva part del punt 2


Index: 02.tex
===================================================================
RCS file: /cvsroot/taca/doc/02.tex,v
retrieving revision 1.1
retrieving revision 1.2
diff -C2 -d -r1.1 -r1.2
*** 02.tex	6 Jun 2004 21:37:28 -0000	1.1
--- 02.tex	7 Jun 2004 17:49:26 -0000	1.2
***************
*** 1,126 ****
! \chapter{Conceptes b?sics}
! 
! 
! \section{Clustering}
  
! \subsection{Introducci?}
  
! En termes generals un cluster ?s un grup de sistemes independents que treballen
! junts com un sistema ?nic. El client interactua amb un cluster com si f?s un
! servidor ?nic. Les configuracions de cluster s'utilitzen per a tenir
! disponibilitat i escalabilitat:
  
! \begin{description}
! \item[Disponibilitat:]
! Quan un sistema falla en el cluster, el programari del cluster respon
! distribuint el treball del sistema que ha fallat als sistemes que queden en el
! cluster.
  
! \item[Escalabilitat:]
! Quan la c?rrega general excedeix les capacitats dels sistemes en el cluster, ?s
! possible afegir sistemes addicionals al mateix. En l'actualitat, els clients que
! planegen ampliar la capacitat del seu sistema han de considerar servidors "high
! end" costosos que proporcionen espai per a CPUs, controladors i mem?ria
! addicionals. A l'utilitzar la tecnologia de clustering, els clients podran
! afegir gradualment sistemes est?ndars m?s petits, segons sigui necessari, per a
! satisfer els requeriments generals de pot?ncia de processament. 
! \end{description}
  
  
! \subsection{Diferents implementacions}
  
! A continuaci? passarem a descriure per sobre algunes de les diferents
! implementacions existents en alguns sistemes operatius, les quals representen
! diferents paradigmes.
  
  
! \subsubsection[Hola]{Linux}
  
! \begin{itemize}
! \item \textbf{OpenMosix:}
! ?s una imlpementaci? basada en la distribuci? de processos, com a modificaci?
! per al nucli, de forma que el proc?s ?s totalment transparent a l'usuari (al
! programador* de l'aplicaci?), cosa que fa molt m?s portables els programes a
! d'altres sistemes, utilitzin o no OpenMosix, i des d'aplicacions no dissenyades
! espec?ficament per a executar-se en un cluster.
  
! De totes maneres, per tal de poder paral?lelitzar les aplicacions, aquestes han
! d'haver estat ja programades amb diversos processos, ja que OpenMosix no
! paral?lelitza aplicacions, sin? que nom?s distribueix la c?rrega entre els
! diferents nodes.
  
! Per exemple, si tenim deu nodes al cluster i executem un programa (amb un sol
! proc?s), tardar? el mateix que si nom?s tingu?ssim un node; per? si executem deu
! programes d'aquests, tardaran el que si nom?s n'execut?ssim un, ja que cadascun
! s'executar? en un node.
  
! Un inconvenient, per?, ?s que tots els nodes del cluster han de tenir exactament
! el mateix nucli (sense compatibilitat de versions ni cap endavant ni cap
! enrere).
  
! Un altre dels problemes de OpenMosix, ?s que no pot migrar cap proc?s que
! comparteixi mem?ria, de forma que tampoc podr? migrar threads, ja que aquests
! comparteixen mem?ria.
  
  
! \item \textbf{Beowulf:}
! \nocite{Beowulf-Home}
! \nocite{Beowulf-Howto}
! Beowulf, segons una de les definicions que hem trobat (doncs alguns diuen que es
! pot dir que un sistema ?s Beowulf nom?s si est? contru?t de la mateixa forma que
! la m?quina original de la NASA; d'altres van cap a l'altre extrem i diuen que ?s
! un sistema Beowulf tot aquell conjunt de m?quines que corren codi paral?lel), ?s
! una arquitectura multi-computador que pot ser utilitzada per a fer computacoins
! en paral?lel. Normalment consisteix en un node servidor i un o m?s nodes
! connectats via Ethernet (o qualsevol altre xarxa), per? el millor de tot ?s que
! es pot constru?r amb hardware "normal", com per exemple qualsevol PC que pugui
! utilitzar Linux, adaptadors est?ndar d'Ethernet i switchos. Beowulf tamb?
! utilitza software "com?", com el sistema operatiu Linux, PVM (Parallel Virtual
! Machine) i MPI (Message Passing Interface). Una de les grans difer?ncies entre
! Beowulf i un cluster de estacions de treball (COW - Cluster of Workstations) ?s
! el fet de qu? Beowulf es comporta com una ?nica m?quina m?s que no mas com un
! conjunt d'estacions de treball. Els nodes de Beowulf es poden pensar com un
! paquet de CPU + mem?ria que es pot connectar al cluster, tal com una CPU o un
! m?dul de mem?ria es poden connectar a una placa base.
  
! Beowulf no ?s un paquet de software especial, una nova topologia de xarxa o
! l'?ltim hack per al kernel, sin? que ?s una tecnologia de clustering de m?quines
! Linux per a formar un supercomputador paral?lel virtual. Tot i que hi ha varis
! paquets de software com modificacions per al kernel, llibreries PVM i MPI i
! eines de configuraci? que fan l'arquitectura Beowulf m?s r?pida, m?s f?cil de
! configurar i molt m?s usable, un pot constru?r una m?quina de la classe Beowulf
! utilitzant distribucions de Linux est?ndars sense cap software addicional.
! Tenint un parell de m?quines linux en xarxa que comparteixen com a m?nim el
! /home a trav?s de NFS i es confien l'una a l'altra per executar shells remotes
! (rsh), es podria dir que es t? una m?quina Beowulf molt simple de dos nodes.
  
! Aix? doncs, est? clar que una aplicaci?, per a funcionar en una arquitectura
! Beowulf, ha d'haver estat escrita utilitzant llibreries o m?todes
! especialitzats, no transparents a l'usuari, per? ofereix m?s rendiment que, per
! exemple, OpenMosix (tot i que aquest ?ltim ?s totalment transparent a l'usuari).
  
! De totes maneres, 
  
  
! \item \textbf{...Altre soft de clustering...}
! \end{itemize} 
  
! \subsubsection{Microkernels (Mach/L4)}
  
! \subsubsection{...Altres SOs amb clustering...}
  
  
  \section{Abstraccions existents en Sistemes de Fitxers}
  
! \subsection{Translators de Hurd}
! \nocite{Hurd-Translators}
! Els translators s?n servidors de Hurd (SO basat en el micronucli gnuMach, tot i
! que s'est? migrant cap a oskit-Mach i, en un futur, cap a L4) que proporcionen
! la interf?cies b?sica del sistema de fitxers, de manera que es poden insertar
  entre el contingut real d'un fitxer (entenent com a fitxer la representaci?
! corresponent en el sistema de fitxers - inode -, doncs el fitxer real pot estar
! en una altra m?quina o, fins i tot, no ser cap fitxer, sin? la representaci?
! d'una zona de mem?ria) i l'usuari que accedeix al fitxer, de forma que
! \textit{tradueix} les peticions de l'usuari.
  
  Els translators, a m?s am?s, tenen unes propietats molt interessants, i ?s que
--- 1,203 ----
! \documentclass{letter}
  
! %%%%%%%%%% Start TeXmacs macros
! \catcode`\?=\active \def?{\`a} \catcode`\?=\active \def?{\`A}
! \catcode`\?=\active \def?{\'a} \catcode`\?=\active \def?{\'A}
! \catcode`\?=\active \def?{\"a} \catcode`\?=\active \def?{\"A}
! \catcode`\?=\active \def?{\^a} \catcode`\?=\active \def?{\^A}
! \catcode`\?=\active \def?{{\aa}} \catcode`\?=\active \def?{{\AA}}
! \catcode`\?=\active \def?{\c{c}} \catcode`\?=\active \def?{\c{C}}
! \catcode`\?=\active \def?{\`e} \catcode`\?=\active \def?{\`E}
! \catcode`\?=\active \def?{\'e} \catcode`\?=\active \def?{\'E}
! \catcode`\?=\active \def?{\"e} \catcode`\?=\active \def?{\"E}
! \catcode`\?=\active \def?{\^e} \catcode`\?=\active \def?{\^E}
! \catcode`\?=\active \def?{\`{\i}} \catcode`\?=\active \def?{\`{\I}}
! \catcode`\?=\active \def?{\'{\i}} \catcode`\?=\active \def?{\'{\I}}
! \catcode`\?=\active \def?{\"{\i}} \catcode`\?=\active \def?{\"{\I}}
! \catcode`\?=\active \def?{\^{\i}} \catcode`\?=\active \def?{\^{\I}}
! \catcode`\?=\active \def?{\`o} \catcode`\?=\active \def?{\`O}
! \catcode`\?=\active \def?{\'o} \catcode`\?=\active \def?{\'O}
! \catcode`\?=\active \def?{\"o} \catcode`\?=\active \def?{\"O}
! \catcode`\?=\active \def?{\^o} \catcode`\?=\active \def?{\^O}
! \catcode`\?=\active \def?{\`u} \catcode`\?=\active \def?{\`U}
! \catcode`\?=\active \def?{\'u} \catcode`\?=\active \def?{\'U}
! \catcode`\?=\active \def?{\"u} \catcode`\?=\active \def?{\"U}
! \catcode`\?=\active \def?{\^u} \catcode`\?=\active \def?{\^U}
! \catcode`\?=\active \def?{\'y} \catcode`\?=\active \def?{\'Y}
! \catcode`\?=\active \def?{\"y} \catcode`\?=\active \def?{\"Y}
! \catcode`\?=\active \def?{!`}
! \catcode`\?=\active \def?{?`}
! \catcode`\?=\active \def?{{\ss}}
! \newcommand{\chapter}[1]{\medskip\bigskip
  
! \noindent\textbf{\begin{center}\huge #1\end{center}}\vspace{-3ex}
  
! \noindent}
! \newcommand{\section}[1]{\medskip\bigskip
  
! \noindent\textbf{\LARGE #1}\vspace{-3ex}
  
+ \noindent}
+ \newcommand{\subsection}[1]{\medskip\bigskip
  
! \noindent\textbf{\Large #1}\vspace{-3ex}
  
! \noindent}
! \newcommand{\paragraph}[1]{\smallskip
  
+ \noindent\textbf{#1} }
+ \newcommand{\subsubsection}[1]{\medskip\bigskip
  
! \noindent\textbf{\large #1}\vspace{-3ex}
  
! \noindent}
! \newcommand{\tmstrong}[1]{\textbf{#1}}
! %%%%%%%%%% End TeXmacs macros
  
! \begin{document}
  
! \chapter{Conceptes b?sics}
  
! \section{Clustering}
  
! \subsection{Introducci?}
  
+ \paragraph{En termes generals un cluster ?s un grup de sistemes independents
+ que treballen junts com un sistema ?nic. El client interactua amb un cluster
+ com si f?s un servidor ?nic. Les configuracions de cluster s'utilitzen per a
+ tenir disponibilitat i escalabilitat:}{\begin{description}
+   \item[Disponibilitat:] Quan un sistema falla en el cluster, el programari
+   del cluster respon distribuint el treball del sistema que ha fallat als
+   sistemes que queden en el cluster.
+   
+   \item[Escalabilitat:] Quan la c?rrega general excedeix les capacitats dels
+   sistemes en el cluster, ?s possible afegir sistemes addicionals al mateix.
+   En l'actualitat, els clients que planegen ampliar la capacitat del seu
+   sistema han de considerar servidors "high end" costosos que proporcionen
+   espai per a CPUs, controladors i mem?ria addicionals. A l'utilitzar la
+   tecnologia de clustering, els clients podran afegir gradualment sistemes
+   est?ndars m?s petits, segons sigui necessari, per a satisfer els
+   requeriments generals de pot?ncia de processament.
+ \end{description}}
  
! \subsection{Diferents implementacions}
  
! A continuaci? passarem a descriure per sobre algunes de les diferents
! implementacions existents en alguns sistemes operatius, les quals representen
! diferents paradigmes.
  
! \paragraph{\subsubsection{[}Hola]Linux}{\begin{itemize}
!   \item \textbf{OpenMosix:} ?s una imlpementaci? basada en la distribuci? de
!   processos, com a modificaci? per al nucli, de forma que el proc?s ?s
!   totalment transparent a l'usuari (al programador* de l'aplicaci?), cosa que
!   fa molt m?s portables els programes a d'altres sistemes, utilitzin o no
!   OpenMosix, i des d'aplicacions no dissenyades espec?ficament per a
!   executar-se en un cluster.
!   
!   De totes maneres, per tal de poder paral?lelitzar les aplicacions, aquestes
!   han d'haver estat ja programades amb diversos processos, ja que OpenMosix no
!   paral?lelitza aplicacions, sin? que nom?s distribueix la c?rrega entre els
!   diferents nodes.
!   
!   Per exemple, si tenim deu nodes al cluster i executem un programa (amb un
!   sol proc?s), tardar? el mateix que si nom?s tingu?ssim un node; per? si
!   executem deu programes d'aquests, tardaran el que si nom?s n'execut?ssim un,
!   ja que cadascun s'executar? en un node.
!   
!   Un inconvenient, per?, ?s que tots els nodes del cluster han de tenir
!   exactament el mateix nucli (sense compatibilitat de versions ni cap endavant
!   ni cap enrere).
!   
!   Un altre dels problemes de OpenMosix, ?s que no pot migrar cap proc?s que
!   comparteixi mem?ria, de forma que tampoc podr? migrar threads, ja que
!   aquests comparteixen mem?ria.
!   
!   \item \textbf{Beowulf:} {\nocite{Beowulf-Home}} {\nocite{Beowulf-Howto}}
!   Beowulf, segons una de les definicions que hem trobat (doncs alguns diuen
!   que es pot dir que un sistema ?s Beowulf nom?s si est? contru?t de la
!   mateixa forma que la m?quina original de la NASA; d'altres van cap a l'altre
!   extrem i diuen que ?s un sistema Beowulf tot aquell conjunt de m?quines que
!   corren codi paral?lel), ?s una arquitectura multi-computador que pot ser
!   utilitzada per a fer computacoins en paral?lel. Normalment consisteix en un
!   node servidor i un o m?s nodes connectats via Ethernet (o qualsevol altre
!   xarxa), per? el millor de tot ?s que es pot constru?r amb hardware "normal",
!   com per exemple qualsevol PC que pugui utilitzar Linux, adaptadors est?ndar
!   d'Ethernet i switchos. Beowulf tamb? utilitza software "com?", com el
!   sistema operatiu Linux, PVM (Parallel Virtual Machine) i MPI (Message
!   Passing Interface). Una de les grans difer?ncies entre Beowulf i un cluster
!   de estacions de treball (COW - Cluster of Workstations) ?s el fet de qu?
!   Beowulf es comporta com una ?nica m?quina m?s que no mas com un conjunt
!   d'estacions de treball. Els nodes de Beowulf es poden pensar com un paquet
!   de CPU + mem?ria que es pot connectar al cluster, tal com una CPU o un m?dul
!   de mem?ria es poden connectar a una placa base.
!   
!   Beowulf no ?s un paquet de software especial, una nova topologia de xarxa o
!   l'?ltim hack per al kernel, sin? que ?s una tecnologia de clustering de
!   m?quines Linux per a formar un supercomputador paral?lel virtual. Tot i que
!   hi ha varis paquets de software com modificacions per al kernel, llibreries
!   PVM i MPI i eines de configuraci? que fan l'arquitectura Beowulf m?s r?pida,
!   m?s f?cil de configurar i molt m?s usable, un pot constru?r una m?quina de
!   la classe Beowulf utilitzant distribucions de Linux est?ndars sense cap
!   software addicional. Tenint un parell de m?quines linux en xarxa que
!   comparteixen com a m?nim el /home a trav?s de NFS i es confien l'una a
!   l'altra per executar shells remotes (rsh), es podria dir que es t? una
!   m?quina Beowulf molt simple de dos nodes.
!   
!   Aix? doncs, est? clar que una aplicaci?, per a funcionar en una arquitectura
!   Beowulf, ha d'haver estat escrita utilitzant llibreries o m?todes
!   especialitzats, no transparents a l'usuari, per? ofereix m?s rendiment que,
!   per exemple, OpenMosix (tot i que aquest ?ltim ?s totalment transparent a
!   l'usuari).
!   
!   De totes maneres,
!   
!   \item \textbf{...Altre soft de clustering...}
! \end{itemize}}
  
! \subsubsection{Microkernels (Mach/L4)}
  
+ No existeix cap eina suficientment madura sobre microkernels que ens ofereixi
+ tot el que tenim en altres sistemes com Linux. Tot i aix? si que es poden
+ trobar alguns projectes d'investigaci? que fan refer?ncia a la construcci? de
+ sistemes de clustering sobre microkernels. Hem trobat dos exemples:
  
! Hurricane Operating System, cl?ster experimental orientat a la investigaci? i
! la recerca. Paper ftp://ftp.cs.toronto.edu/pub/paral?lel/Tumoral \_ Untau \_
! Caboriege \_ USENIX92.ps.Z
  
! CHORUS/Fusion per SCO Sopen Menystens Software is una implementaci?
! multi-servidor per SCO UNIX. Aquest entend SCO Unix amb funcionalitats de
! temps real i clustering.
  
! \subsubsection{Altres Sistemes Operatius}
  
+ \begin{itemize}
+   \item {\tmstrong{Solaris}}: Hem trobat exemples de cl?sters de computaci?
+   constru?ts amb aquest Sistema Operatiu, per exemple, el SciClone Cluster
+   Project. El cl?ster est? format exclusivament per m?quines Sun per? no donen
+   moltes caracter?stiques del sistema operatiu, ni tampoc si han tingut que
+   desenvolupar un afegit per dona suport per clustering.
+   (http://www.compsci.wm.edu/SciClone/introduction/index.html).
+   
+   \item {\tmstrong{MacOSX:}} Utilitzant la bibloteca de processament carbonlib
+   m?s un software de clustering anomenat pooch
+   (http://daugerresearch.com/pooch/) ?s pot crear un cluster amb aquest
+   sistema operatiu. Com passa a Beowulf per Linux, aquest sistema de
+   clustering est? basat en l'?s de biblioteques de paral.leliitzaci? i per
+   tant els programes s'haur?n d'escriure penssant que s'executen en un cluster
+   no ?s transparent a l'usuari/aplicaci?.
+ \end{itemize}
  
  \section{Abstraccions existents en Sistemes de Fitxers}
  
! \subsection{Translators de Hurd} {\nocite{Hurd-Translators}} Els translators
! s?n servidors de Hurd (SO basat en el micronucli gnuMach, tot i que s'est?
! migrant cap a oskit-Mach i, en un futur, cap a L4) que proporcionen la
! interf?cies b?sica del sistema de fitxers, de manera que es poden insertar
  entre el contingut real d'un fitxer (entenent com a fitxer la representaci?
! corresponent en el sistema de fitxers - inode -, doncs el fitxer real pot
! estar en una altra m?quina o, fins i tot, no ser cap fitxer, sin? la
! representaci? d'una zona de mem?ria) i l'usuari que accedeix al fitxer, de
! forma que \textit{tradueix} les peticions de l'usuari.
  
  Els translators, a m?s am?s, tenen unes propietats molt interessants, i ?s que
***************
*** 128,145 ****
  que els pot executar qualsevol usuari, sense necessitat de tenir permisos de
  superusuari per instal?lar o modificar un translator, l'?nic que fa falta ?s
! tenir drets d'acc?s a l'inode sobre s'uneix el translator. Molts translators no
! requereixen un fitxer per a funcionar, i ?s per aix? que la informaci? sobre
! aquests es guarda a l'inode.
  
  Els translators s?n responsables de servir totes les operacions del sistema de
  fitxers que fan refer?ncia a l'inode al que s'uneix. Per aix?, al no estar
! restringits al t?pic conjunt d'objectes (fitxer de dispositiu, link, etc.), s?n
! lliures de retornar qualsevol cosa que tingui sentit per al programador. Un
! exemple podria ser un translator que es comport?s com un directori quan f?s
! accedit per \texttt{cd} o \texttt{ls} per? que al mateix temps es comport?s com
! un fitxer al ser accedit per \texttt{cat}.
! 
  
  \subsection{/proc de Linux vs. VFS de Linux}
  
! \subsection{...Altres abstraccions en SFs...}
\ No newline at end of file
--- 205,223 ----
  que els pot executar qualsevol usuari, sense necessitat de tenir permisos de
  superusuari per instal?lar o modificar un translator, l'?nic que fa falta ?s
! tenir drets d'acc?s a l'inode sobre s'uneix el translator. Molts translators
! no requereixen un fitxer per a funcionar, i ?s per aix? que la informaci?
! sobre aquests es guarda a l'inode.
  
  Els translators s?n responsables de servir totes les operacions del sistema de
  fitxers que fan refer?ncia a l'inode al que s'uneix. Per aix?, al no estar
! restringits al t?pic conjunt d'objectes (fitxer de dispositiu, link, etc.),
! s?n lliures de retornar qualsevol cosa que tingui sentit per al programador.
! Un exemple podria ser un translator que es comport?s com un directori quan f?s
! accedit per \texttt{cd} o \texttt{ls} per? que al mateix temps es comport?s
! com un fitxer al ser accedit per \texttt{cat}.
  
  \subsection{/proc de Linux vs. VFS de Linux}
  
! \subsection{...Altres abstraccions en SFs...}
! 
! \end{document}

Index: 03.tex
===================================================================
RCS file: /cvsroot/taca/doc/03.tex,v
retrieving revision 1.1
retrieving revision 1.2
diff -C2 -d -r1.1 -r1.2
*** 03.tex	6 Jun 2004 21:37:28 -0000	1.1
--- 03.tex	7 Jun 2004 17:49:26 -0000	1.2
***************
*** 1,42 ****
  \chapter{Software de clustering existent}
  
! \section{Necessitats generals}
! (qu? ens ha d'oferir la capa inferior)
! (poder migrar processos, poder veure on s?n, ...)
! (qu? nosaltres VOLEM poder fer)
  
- \section{Qu? ens ofereixen els sistemes}
- (qu? proporciona a una capa superior)
- (si ja proporciona una abstracci? semblant a la que volem...)
- (qu? nosaltres PODEM fer)
-                 
  \subsection{Linux}
  
  \subsubsection{OpenMosix}
  
! \subsubsection{Beowulf}
! \nocite{Beowulf-MiniHowto}
! Tal com s'ha explicat anteriorment, Beowulf ?s una arquitectura i no un paquet
! de software, de manera que hi ha diverses eines o distribucions que permeten
! contru?r aquesta arquitectura:
  
! \begin{itemize}
! \item Cluster Management Utility (CMU) de Compaq
! \item Projecte OSCAR (Open Source Cluster Application Resources)
! \item ROCKS Clustering Toolkit.
! \item Patagonia Cluster Project
! \item SMILE Cluster Management System (SCMS) i les seves eines per a Beowulf
! \item Projecte SCore Cluster System Software (Score)
! \item Software ALINKA Linux Clustering
! \end{itemize} 
  
- Degut a la gran varietat d'eines d'administraci? i de sistemes de comunicaci?
- que utilitzen els programadors (PVM, MPI, etc.) en aquesta arquitectura
- (precisament per ser una arquitectura i no un software concret), no ens ha estat
- possible definir les caracter?stiques concretes de Beowulf i, per tant, en la
- resta del treball ens basarem en les experi?ncies concretes d'OpenMosix i la
- teoria sobre el que ofereix un sistema de computaci? distribu?da.
  
- \subsection{Microkernels (Mach/L4)}
  
! \subsection{...}
--- 1,104 ----
+ \documentclass{letter}
+ 
+ %%%%%%%%%% Start TeXmacs macros
+ \catcode`\?=\active \def?{\`a} \catcode`\?=\active \def?{\`A}
+ \catcode`\?=\active \def?{\'a} \catcode`\?=\active \def?{\'A}
+ \catcode`\?=\active \def?{\"a} \catcode`\?=\active \def?{\"A}
+ \catcode`\?=\active \def?{\^a} \catcode`\?=\active \def?{\^A}
+ \catcode`\?=\active \def?{{\aa}} \catcode`\?=\active \def?{{\AA}}
+ \catcode`\?=\active \def?{\c{c}} \catcode`\?=\active \def?{\c{C}}
+ \catcode`\?=\active \def?{\`e} \catcode`\?=\active \def?{\`E}
+ \catcode`\?=\active \def?{\'e} \catcode`\?=\active \def?{\'E}
+ \catcode`\?=\active \def?{\"e} \catcode`\?=\active \def?{\"E}
+ \catcode`\?=\active \def?{\^e} \catcode`\?=\active \def?{\^E}
+ \catcode`\?=\active \def?{\`{\i}} \catcode`\?=\active \def?{\`{\I}}
+ \catcode`\?=\active \def?{\'{\i}} \catcode`\?=\active \def?{\'{\I}}
+ \catcode`\?=\active \def?{\"{\i}} \catcode`\?=\active \def?{\"{\I}}
+ \catcode`\?=\active \def?{\^{\i}} \catcode`\?=\active \def?{\^{\I}}
+ \catcode`\?=\active \def?{\`o} \catcode`\?=\active \def?{\`O}
+ \catcode`\?=\active \def?{\'o} \catcode`\?=\active \def?{\'O}
+ \catcode`\?=\active \def?{\"o} \catcode`\?=\active \def?{\"O}
+ \catcode`\?=\active \def?{\^o} \catcode`\?=\active \def?{\^O}
+ \catcode`\?=\active \def?{\`u} \catcode`\?=\active \def?{\`U}
+ \catcode`\?=\active \def?{\'u} \catcode`\?=\active \def?{\'U}
+ \catcode`\?=\active \def?{\"u} \catcode`\?=\active \def?{\"U}
+ \catcode`\?=\active \def?{\^u} \catcode`\?=\active \def?{\^U}
+ \catcode`\?=\active \def?{\'y} \catcode`\?=\active \def?{\'Y}
+ \catcode`\?=\active \def?{\"y} \catcode`\?=\active \def?{\"Y}
+ \catcode`\?=\active \def?{!`}
+ \catcode`\?=\active \def?{?`}
+ \catcode`\?=\active \def?{{\ss}}
+ \newcommand{\chapter}[1]{\medskip\bigskip
+ 
+ \noindent\textbf{\begin{center}\huge #1\end{center}}\vspace{-3ex}
+ 
+ \noindent}
+ \newcommand{\section}[1]{\medskip\bigskip
+ 
+ \noindent\textbf{\LARGE #1}\vspace{-3ex}
+ 
+ \noindent}
+ \newcommand{\subsection}[1]{\medskip\bigskip
+ 
+ \noindent\textbf{\Large #1}\vspace{-3ex}
+ 
+ \noindent}
+ \newcommand{\subsubsection}[1]{\medskip\bigskip
+ 
+ \noindent\textbf{\large #1}\vspace{-3ex}
+ 
+ \noindent}
+ \newcommand{\paragraph}[1]{\smallskip
+ 
+ \noindent\textbf{#1} }
+ %%%%%%%%%% End TeXmacs macros
+ 
+ \begin{document}
+ 
  \chapter{Software de clustering existent}
  
! \section{Necessitats generals} (qu? ens ha d'oferir la capa inferior) (poder
! migrar processos, poder veure on s?n, ...) (qu? nosaltres VOLEM poder fer)
! 
! \section{Qu? ens ofereixen els sistemes} (qu? proporciona a una capa superior)
! (si ja proporciona una abstracci? semblant a la que volem...) (qu? nosaltres
! PODEM fer)
  
  \subsection{Linux}
  
  \subsubsection{OpenMosix}
  
! \paragraph{\subsubsection{Beowulf} {\nocite{Beowulf-MiniHowto}} Tal com s'ha
! explicat anteriorment, Beowulf ?s una arquitectura i no un paquet de software,
! de manera que hi ha diverses eines o distribucions que permeten contru?r
! aquesta arquitectura:}{\begin{itemize}
!   \item Cluster Management Utility (CMU) de Compaq
!   
!   \item Projecte OSCAR (Open Source Cluster Application Resources)
!   
!   \item ROCKS Clustering Toolkit.
!   
!   \item Patagonia Cluster Project
!   
!   \item SMILE Cluster Management System (SCMS) i les seves eines per a Beowulf
!   
!   \item Projecte SCore Cluster System Software (Score)
!   
!   \item Software ALINKA Linux Clustering
! \end{itemize}}{Degut a la gran varietat d'eines d'administraci? i de sistemes
! de comunicaci? que utilitzen els programadors (PVM, MPI, etc.) en aquesta
! arquitectura (precisament per ser una arquitectura i no un software concret),
! no ens ha estat possible definir les caracter?stiques concretes de Beowulf i,
! per tant, en la resta del treball ens basarem en les experi?ncies concretes
! d'OpenMosix i la teoria sobre el que ofereix un sistema de computaci?
! distribu?da.}
  
! \subsection{Microkernels (Mach/L4)}
  
  
  
! \subsection{Altres Sistemes}
! 
! 
! 
! \end{document}



From nobody at sheep.berlios.de  Tue Jun  8 23:04:34 2004
From: nobody at sheep.berlios.de (xscript)
Date: Tue, 8 Jun 2004 23:04:34 +0200
Subject: [Taca-cvs] doc 03.tex,1.2,1.3
Message-ID: <200406082104.i58L4YB03540@bat.berlios.de>

Update of /cvsroot/taca/doc
In directory sheep:/tmp/cvs-serv14634

Modified Files:
	03.tex 
Log Message:
Doc 2004/06/08

Index: 03.tex
===================================================================
RCS file: /cvsroot/taca/doc/03.tex,v
retrieving revision 1.2
retrieving revision 1.3
diff -C2 -d -r1.2 -r1.3
*** 03.tex	7 Jun 2004 17:49:26 -0000	1.2
--- 03.tex	8 Jun 2004 21:04:32 -0000	1.3
***************
*** 1,102 ****
! \documentclass{letter}
  
! %%%%%%%%%% Start TeXmacs macros
! \catcode`\?=\active \def?{\`a} \catcode`\?=\active \def?{\`A}
! \catcode`\?=\active \def?{\'a} \catcode`\?=\active \def?{\'A}
! \catcode`\?=\active \def?{\"a} \catcode`\?=\active \def?{\"A}
! \catcode`\?=\active \def?{\^a} \catcode`\?=\active \def?{\^A}
! \catcode`\?=\active \def?{{\aa}} \catcode`\?=\active \def?{{\AA}}
! \catcode`\?=\active \def?{\c{c}} \catcode`\?=\active \def?{\c{C}}
! \catcode`\?=\active \def?{\`e} \catcode`\?=\active \def?{\`E}
! \catcode`\?=\active \def?{\'e} \catcode`\?=\active \def?{\'E}
! \catcode`\?=\active \def?{\"e} \catcode`\?=\active \def?{\"E}
! \catcode`\?=\active \def?{\^e} \catcode`\?=\active \def?{\^E}
! \catcode`\?=\active \def?{\`{\i}} \catcode`\?=\active \def?{\`{\I}}
! \catcode`\?=\active \def?{\'{\i}} \catcode`\?=\active \def?{\'{\I}}
! \catcode`\?=\active \def?{\"{\i}} \catcode`\?=\active \def?{\"{\I}}
! \catcode`\?=\active \def?{\^{\i}} \catcode`\?=\active \def?{\^{\I}}
! \catcode`\?=\active \def?{\`o} \catcode`\?=\active \def?{\`O}
! \catcode`\?=\active \def?{\'o} \catcode`\?=\active \def?{\'O}
! \catcode`\?=\active \def?{\"o} \catcode`\?=\active \def?{\"O}
! \catcode`\?=\active \def?{\^o} \catcode`\?=\active \def?{\^O}
! \catcode`\?=\active \def?{\`u} \catcode`\?=\active \def?{\`U}
! \catcode`\?=\active \def?{\'u} \catcode`\?=\active \def?{\'U}
! \catcode`\?=\active \def?{\"u} \catcode`\?=\active \def?{\"U}
! \catcode`\?=\active \def?{\^u} \catcode`\?=\active \def?{\^U}
! \catcode`\?=\active \def?{\'y} \catcode`\?=\active \def?{\'Y}
! \catcode`\?=\active \def?{\"y} \catcode`\?=\active \def?{\"Y}
! \catcode`\?=\active \def?{!`}
! \catcode`\?=\active \def?{?`}
! \catcode`\?=\active \def?{{\ss}}
! \newcommand{\chapter}[1]{\medskip\bigskip
  
! \noindent\textbf{\begin{center}\huge #1\end{center}}\vspace{-3ex}
  
! \noindent}
! \newcommand{\section}[1]{\medskip\bigskip
  
! \noindent\textbf{\LARGE #1}\vspace{-3ex}
  
! \noindent}
! \newcommand{\subsection}[1]{\medskip\bigskip
  
- \noindent\textbf{\Large #1}\vspace{-3ex}
  
! \noindent}
! \newcommand{\subsubsection}[1]{\medskip\bigskip
  
! \noindent\textbf{\large #1}\vspace{-3ex}
  
! \noindent}
! \newcommand{\paragraph}[1]{\smallskip
  
! \noindent\textbf{#1} }
! %%%%%%%%%% End TeXmacs macros
  
! \begin{document}
  
! \chapter{Software de clustering existent}
  
! \section{Necessitats generals} (qu? ens ha d'oferir la capa inferior) (poder
! migrar processos, poder veure on s?n, ...) (qu? nosaltres VOLEM poder fer)
  
- \section{Qu? ens ofereixen els sistemes} (qu? proporciona a una capa superior)
- (si ja proporciona una abstracci? semblant a la que volem...) (qu? nosaltres
- PODEM fer)
  
! \subsection{Linux}
  
! \subsubsection{OpenMosix}
  
- \paragraph{\subsubsection{Beowulf} {\nocite{Beowulf-MiniHowto}} Tal com s'ha
- explicat anteriorment, Beowulf ?s una arquitectura i no un paquet de software,
- de manera que hi ha diverses eines o distribucions que permeten contru?r
- aquesta arquitectura:}{\begin{itemize}
-   \item Cluster Management Utility (CMU) de Compaq
-   
-   \item Projecte OSCAR (Open Source Cluster Application Resources)
-   
-   \item ROCKS Clustering Toolkit.
-   
-   \item Patagonia Cluster Project
-   
-   \item SMILE Cluster Management System (SCMS) i les seves eines per a Beowulf
-   
-   \item Projecte SCore Cluster System Software (Score)
-   
-   \item Software ALINKA Linux Clustering
- \end{itemize}}{Degut a la gran varietat d'eines d'administraci? i de sistemes
- de comunicaci? que utilitzen els programadors (PVM, MPI, etc.) en aquesta
- arquitectura (precisament per ser una arquitectura i no un software concret),
- no ens ha estat possible definir les caracter?stiques concretes de Beowulf i,
- per tant, en la resta del treball ens basarem en les experi?ncies concretes
- d'OpenMosix i la teoria sobre el que ofereix un sistema de computaci?
- distribu?da.}
  
  \subsection{Microkernels (Mach/L4)}
  
  
  
  \subsection{Altres Sistemes}
  
  
--- 1,190 ----
! \begin{document}
  
! \chapter{Software de clustering existent}
  
! \section{Necessitats generals}
! (qu? ens ha d'oferir la capa inferior) \\
! (poder migrar processos, poder veure on s?n, ...) \\
! (qu? nosaltres VOLEM poder fer)
  
! \subsection {A nivell de cluster...}
! \begin{itemize}
! \item Consultar quantitat de nodes del cluster
! \item Consultar carrega total del cluster
! \end{itemize}
  
! \subsection {A nivell de node...}
! \begin{itemize}
! \item Quantitat de CPU's d'un node
! \item Consultar carrega del node
! \item Consultar estat de memoria
! \item Bloquejar l'arribada de nous processos remots
! \item Bloquejar la migracio de processos locals
! \item Activar/Desactivar la migraci? automatica de processos
! \item Demanar que els processos que ha creat un node i han migrat, tornin  a
! aquest node (come back home)
! \item Expulsar els "processos convidats" a casa
! \item Saber quin identificador te un node
! \item Modificar/Consultar la velocitat d'un node
! \item Consultar informacio de processos (resum de l'estat de processos locals, i
! remots)
! \item Consultar resum de l'estat del node
! \end{itemize}
  
! \subsection {A nivell de proces...}
! \begin{itemize}
! \item Moure processos d'un node a un altre
! \item Bloquejar un proces en un node concret (/proc.....lock)
! \item Crear un nou proces en una maquina (crear un fitxer)
! \item Matar un proces (esborrar un fitxer)
! \item Copiar un proces??
! \item Modificar/veure memoria del proces (/proc....mem)
! \item Consultar la linia de comandes amb la que s'ha ex/proc....cmdline)
! \item Consultar estat del proces (/proc....status)
! \item Consultar quants cops s'ha migrat el proces
! \item Consultar on s'esta computant actualment
! \item Consultar quin node el va crear
! \item Saber l'identificador de proces (ID global)
! \item Saber l'identificador local d'un proces (ex: PID)
! \item Consultar resum de us de CPU
! \item Consultar resum de us de Memoria
! \end{itemize}
  
  
! \section{Qu? ens ofereixen els sistemes}
! (qu? proporciona a una capa superior) \\
! (si ja proporciona una abstracci? semblant a la que volem...) \\
! (qu? nosaltres PODEM fer)
!                 
! \subsection{Linux}
  
! \subsubsection{OpenMosix}
  
! \paragraph{A nivell de cluster...}
! \begin{itemize}
! \item Consultar quantitat de nodes del cluster
! 	Consultant el numero de subdirectoris de tipus NODE del directori cluster.
! \item Consultar carrega total del cluster
! 	Mitjana ponderada de la carrega dels nodes que conte el cluster.
! \end{itemize}
  
! \paragraph{A nivell de node...}
! \begin{itemize}
! \item Quantitat de CPU's d'un node
! 	Consultant el fitxer /proc/hpc/nodes/\textless opMosix\_ID\textgreater/cpus
! \item Consultar carrega del node
! 	Consultant el fitxer /proc/hpc/nodes/\textless opMosix\_ID\textgreater/load
! \item Consultar estat de memoria
! 	Consultant el fitxer /proc/hpc/nodes/\textless opMosix\_ID\textgreater/mem
! \item Bloquejar l'arribada de nous processos remots (per altres nodes que no
! sigui el local??muntar /proc..admin dels altres??)
! 	Consultant el fitxer /proc/hpc/admin/block
! \item Bloquejar la migracio de processos locals
! 	Bloquejar cada proc?s del node (mirar seg?ent secci?)
! \item Activar/Desactivar la migraci? automatica de processos
! 	Modificar el fitxer /proc/hpc/admin/stay
! \item Demanar que els processos que ha creat un node i han migrat, tornin  a
! aquest node (come back home)
! 	Modificar el fitxer /proc/hpc/admin/bring (com???)
! \item Expulsar els "processos convidats" a casa
! 	Modificar el fitxer /proc/hpc/admin/expel
! \item Saber quin identificador te un node
! 	Consultar el fitxer /proc/hpc/admin/mospe (o mirar el nom del directori del
! node)
! \item Modificar/Consultar la velocitat d'un node
! 	Consultar el fitxer /proc/hpc/admin/speed
! \item Consultar informacio de processos (resum de l'estat de processos locals, i
! remots)
! 	Generar un resum consultant la informaci? de cada proc?s del node amb les
! operacions
! 	de consulta de informaci? de proces (mirar seg?ent secci?)
! \item Consultar resum de l'estat del node
! 	Generar un resum amb la informaci? sobre el node descrita a les funcionalitats
! anteriors.
! \end{itemize}
  
! \paragraph{A nivell de proces...}
! \begin{itemize}
! \item Moure processos d'un node a un altre
! 	Fer un migrate del proces que volem moure al node on ha d'anar
! 	=> Esborrar els fitxers relatius al proces del node origen
! 	=> Generar els fitxers relatius al proces al node desti
! \item Bloquejar un proces en un node concret (/proc.....lock)
! 	Modificar el fitxer /proc/[PID]/lock
! \item Crear un nou proces en una maquina (crear un fitxer)
! 	Posar en execucio el proces al node on volem que s'executi
! 	=> Generar els fitxers relatius al proces en aquest node.
! \item Matar un proces (esborrar un fitxer)
! 	Fer un "kill" del proces
! 	=> Esborrar els fitxers relatius al proces al node on s'esta executant.
! \item Copiar un proces??
! \item Modificar/veure memoria del proces (/proc....mem) (...?)
! 	Consultar el fitxer /proc/[PID]/mem
! \item Consultar la linia de comandes amb la que s'ha ex/proc....cmdline) (...?)
! 	Consultar el fitxer /proc/[PID]/cmdline
! \item Consultar estat del proces (/proc....status) (...?)
! 	Consultar el fitxer /proc/[PID]/status
! \item Consultar quants cops s'ha migrat el proces (...?)
! 	Consultar el fitxer /proc/[PID]/nmigs
! \item Consultar on s'esta computant actualment
! 	Consultar el fitxer /proc/[PID]/where (o mirar el directori pare)
! \item Consultar quin node el va crear
! 	Consultar el fitxer /proc/hpc/remote/from (de quin???)
! \item Saber l'identificador de proces (ID global) (el generem nosaltres?? cada
! cop que creem un proces??)
! \item Saber l'identificador local d'un proces (ex: PID) (...?)
! 	Consultar el directori que representa el proces a /proc/[PID]
! \item Consultar resum de us de CPU (...?)
! 	Per locals -> top -p PID
! 	Per remots -> consultar fitxer /proc/hpc/remote/stats
! \item Consultar resum de us de Memoria (...?)
! 	idem que l'anterior
! \end{itemize}
  
! \textbf{\textit{\underline{...? = volem mirar aquesta informacio de processos
! que son a altres maquines?}}} \\
  
! L'escenari sera oferir un VFS nomes al node d'entrada, i els migrate... de
! OPMosix
! no treuen la informacio dels processos de /proc...
  
  
! \subsubsection{Beowulf}
! \nocite{Beowulf-MiniHowto}
! Tal com s'ha explicat anteriorment, Beowulf ?s una arquitectura i no un paquet
! de software, de manera que hi ha diverses eines o distribucions que permeten
! contru?r aquesta arquitectura:
  
! \begin{itemize}
! \item Cluster Management Utility (CMU) de Compaq
! \item Projecte OSCAR (Open Source Cluster Application Resources)
! \item ROCKS Clustering Toolkit.
! \item Patagonia Cluster Project
! \item SMILE Cluster Management System (SCMS) i les seves eines per a Beowulf
! \item Projecte SCore Cluster System Software (Score)
! \item Software ALINKA Linux Clustering
! \end{itemize} 
! 
! Degut a la gran varietat d'eines d'administraci? i de sistemes de comunicaci?
! que utilitzen els programadors (PVM, MPI, etc.) en aquesta arquitectura
! (precisament per ser una arquitectura i no un software concret), no ens ha estat
! possible definir les caracter?stiques concretes de Beowulf i, per tant, en la
! resta del treball ens basarem en les experi?ncies concretes d'OpenMosix i la
! teoria sobre el que ofereix un sistema de computaci? distribu?da.
  
  
  \subsection{Microkernels (Mach/L4)}
+ Tal com s'ha explicat a l'apartat 2, els cl?sters existents sobre Microkernels
+ segueixen la mateixa arquitectura que BeoWulf, no existeix cap tipus d'est?ndard
+ ni d'API que ens serveixi per definir les caracter?stiques concretes de cl?sters
+ en Microkernels, ja que totes les implementacions que hem trobat s?n a nivell
+ d'investigaci? i/o recerca.
  
  
  
  \subsection{Altres Sistemes}
+ ????No s'ha trobat res????
+ 
+ Comentar-ho???????????????
  
  



From nobody at sheep.berlios.de  Tue Jun  8 23:06:39 2004
From: nobody at sheep.berlios.de (xscript)
Date: Tue, 8 Jun 2004 23:06:39 +0200
Subject: [Taca-cvs] doc 04.tex,1.1,1.2
Message-ID: <200406082106.i58L6dB03606@bat.berlios.de>

Update of /cvsroot/taca/doc
In directory sheep:/tmp/cvs-serv14772

Modified Files:
	04.tex 
Log Message:
Doc 2004/06/08

Index: 04.tex
===================================================================
RCS file: /cvsroot/taca/doc/04.tex,v
retrieving revision 1.1
retrieving revision 1.2
diff -C2 -d -r1.1 -r1.2
*** 04.tex	6 Jun 2004 21:37:28 -0000	1.1
--- 04.tex	8 Jun 2004 21:06:37 -0000	1.2
***************
*** 1,4 ****
--- 1,19 ----
  \chapter {Estudis i propostes de disseny}
  
+ \section {Disseny esquem?tic del sistema}
+ Disseny a tres capes:
+ 	Frontend	VFS
+ 	Adaptaci?	(definici? d'una interf?cie)
+ 	Backend		Clustering (implementaci? de la interf?cie depenent del sistema de
+ clustering)
+ 
+ \subsection{Frontend}
+ 
+ Implementaci? de la jerarquia generica d'administraci? a trav?s de les funcions
+ que proporciona l'abstracci?
+ (sistema de fitxers virtual) del sistema sobre el que s'executa.
+ 
+ 
+ 
  \section{Esquema del sistema de fitxers}
  
***************
*** 14,25 ****
  |-- <IDCluster>
  |   |-- admin
! |   |   |-- 
  |   |-- self
- |   |   |--
  |   |-- <IDNode>
  |   |   |-- admin
! |   |   |   |--
  |   |   `-- <IDProces>
! |   |       |-- 
  \end{verbatim} 
  
--- 29,40 ----
  |-- <IDCluster>
  |   |-- admin
! |   |   `-- ... 
  |   |-- self
  |   |-- <IDNode>
  |   |   |-- admin
! |   |   |   `-- ...
  |   |   `-- <IDProces>
! |   |       |-- from 
! |   |       `-- 
  \end{verbatim} 
  
***************
*** 28,32 ****
  Explicaci? + figura \ref{fig:esquema-utilcl} .
  
! \begin{figure}
     \centering
     \includegraphics[scale=0.4]{esquema-utilcl.eps}
--- 43,54 ----
  Explicaci? + figura \ref{fig:esquema-utilcl} .
  
! En aquest disseny es tracta d'utilitzar des del m?dul TACA les comandes que
! ofereix el software de clustering. 
! Per exemple, quan es vol migrar un proces, es a dir, es vol moure un fitxer que
! representa el proces en el sistema de fitxers que ofereix TACA, d'un node a un
! altre, el que faria el software del nostre m?dul seria utilitzar la comanda
! "migrate" de les OpenMosix Tools (utilitats clustering).
! 
! \begin{figure}[h]
     \centering
     \includegraphics[scale=0.4]{esquema-utilcl.eps}
***************
*** 39,43 ****
  Explicaci? + figura \ref{fig:esquema-supcl}.
  
! \begin{figure}
     \centering
     \includegraphics[scale=0.4]{esquema-supcl.eps}
--- 61,81 ----
  Explicaci? + figura \ref{fig:esquema-supcl}.
  
! En aquest disseny es tracta d'utilitzar des del m?dul TACA les funcions que
! ofereix la llibreria del cluster (suport clustering).
! A l'exemple d'abans, en el qual vol?em migrar un proc?s, el nostre m?dul
! utilitzaria les funcions espec?fiques per aquesta tasca que trobem a la pr?pia
! API que ens ofereix OpenMosix. Es a dir, faria servir les funcions que utilitzen
! les OpenMosix Tools.
! 
! Aquest disseny, respecte l'anterior, aporta independ?ncia respecte les OpenMosix
! Tools i efici?ncia ja que no cal que cada cop que volem fer alguna operaci?
! haguem de crear un proc?s que executi una comanda de les utilitats de
! clustering.
! 
! Per contra implica entendre les llibreries de OpenMosix i realitzar-ne una
! implementaci?, tot i que al tenir el codi font podem seguir els passos que fan
! servir aquestes llibreries.
! 
! \begin{figure}[h]
     \centering
     \includegraphics[scale=0.4]{esquema-supcl.eps}
***************
*** 47,76 ****
  
  \section{Soluci? super-guay}
! ???
! 
! \section{...}
! ???????
! 
! 
! Disseny esquem?tic del sistema
! ==============================
! 
! Disseny a tres capes:
! 
! 	Frontend	VFS
! 	Adaptaci?	(definici? d'una interf?cie)
! 	Backend		Clustering (implementaci? de la interf?cie depenent del sistema de
! clustering)
! 
! Definici? d'una jerarquia:
! 
! 
! Frontend
! --------
  
! Implementaci? de la jerarquia generica d'administraci? a trav?s de les funcions
! que proporciona l'abstracci?
! (sistema de fitxers virtual) del sistema sobre el que s'executa.
  
! - Jerarquia
  
--- 85,100 ----
  
  \section{Soluci? super-guay}
! En aquest disseny es tracta d'interectuar directament amb el nucli mitjan?ant
! elsistema de fitxers virtual /proc.
! Seguint amb l'exemple de migraci? de proc?s, en aquest cas es tractaria
! d'escriure directament les dades necess?ries al fitxer corresponent del
! directori /proc.En aquest cas escrivint el identificador de node al fitxer
! "/proc/[PID]/goto" aconseguir?em migrar el proc?s de pid=PID al node desitjat. 
  
! Aquest disseny, respecte l'anterior, aporta simplicitat i independ?ncia respecte
! les utilitats que ofereix el cluster i les llibreries. Per? per contra s'hauria
! de reescriure molt codi per exemple pel control d'errors, permisos, etc. que ja
! estan implementats a les llibreries del software de clustering.
  
! \section{...}
  



From nobody at sheep.berlios.de  Tue Jun  8 23:22:59 2004
From: nobody at sheep.berlios.de (xscript)
Date: Tue, 8 Jun 2004 23:22:59 +0200
Subject: [Taca-cvs] doc 02.tex,1.2,1.3
Message-ID: <200406082122.i58LMsB03855@bat.berlios.de>

Update of /cvsroot/taca/doc
In directory sheep:/tmp/cvs-serv15989

Modified Files:
	02.tex 
Log Message:
Doc 2004/06/08

Index: 02.tex
===================================================================
RCS file: /cvsroot/taca/doc/02.tex,v
retrieving revision 1.2
retrieving revision 1.3
diff -C2 -d -r1.2 -r1.3
*** 02.tex	7 Jun 2004 17:49:26 -0000	1.2
--- 02.tex	8 Jun 2004 21:22:52 -0000	1.3
***************
*** 1,156 ****
! \documentclass{letter}
  
! %%%%%%%%%% Start TeXmacs macros
! \catcode`\?=\active \def?{\`a} \catcode`\?=\active \def?{\`A}
! \catcode`\?=\active \def?{\'a} \catcode`\?=\active \def?{\'A}
! \catcode`\?=\active \def?{\"a} \catcode`\?=\active \def?{\"A}
! \catcode`\?=\active \def?{\^a} \catcode`\?=\active \def?{\^A}
! \catcode`\?=\active \def?{{\aa}} \catcode`\?=\active \def?{{\AA}}
! \catcode`\?=\active \def?{\c{c}} \catcode`\?=\active \def?{\c{C}}
! \catcode`\?=\active \def?{\`e} \catcode`\?=\active \def?{\`E}
! \catcode`\?=\active \def?{\'e} \catcode`\?=\active \def?{\'E}
! \catcode`\?=\active \def?{\"e} \catcode`\?=\active \def?{\"E}
! \catcode`\?=\active \def?{\^e} \catcode`\?=\active \def?{\^E}
! \catcode`\?=\active \def?{\`{\i}} \catcode`\?=\active \def?{\`{\I}}
! \catcode`\?=\active \def?{\'{\i}} \catcode`\?=\active \def?{\'{\I}}
! \catcode`\?=\active \def?{\"{\i}} \catcode`\?=\active \def?{\"{\I}}
! \catcode`\?=\active \def?{\^{\i}} \catcode`\?=\active \def?{\^{\I}}
! \catcode`\?=\active \def?{\`o} \catcode`\?=\active \def?{\`O}
! \catcode`\?=\active \def?{\'o} \catcode`\?=\active \def?{\'O}
! \catcode`\?=\active \def?{\"o} \catcode`\?=\active \def?{\"O}
! \catcode`\?=\active \def?{\^o} \catcode`\?=\active \def?{\^O}
! \catcode`\?=\active \def?{\`u} \catcode`\?=\active \def?{\`U}
! \catcode`\?=\active \def?{\'u} \catcode`\?=\active \def?{\'U}
! \catcode`\?=\active \def?{\"u} \catcode`\?=\active \def?{\"U}
! \catcode`\?=\active \def?{\^u} \catcode`\?=\active \def?{\^U}
! \catcode`\?=\active \def?{\'y} \catcode`\?=\active \def?{\'Y}
! \catcode`\?=\active \def?{\"y} \catcode`\?=\active \def?{\"Y}
! \catcode`\?=\active \def?{!`}
! \catcode`\?=\active \def?{?`}
! \catcode`\?=\active \def?{{\ss}}
! \newcommand{\chapter}[1]{\medskip\bigskip
  
! \noindent\textbf{\begin{center}\huge #1\end{center}}\vspace{-3ex}
  
! \noindent}
! \newcommand{\section}[1]{\medskip\bigskip
  
! \noindent\textbf{\LARGE #1}\vspace{-3ex}
  
! \noindent}
! \newcommand{\subsection}[1]{\medskip\bigskip
  
- \noindent\textbf{\Large #1}\vspace{-3ex}
  
! \noindent}
! \newcommand{\paragraph}[1]{\smallskip
  
- \noindent\textbf{#1} }
- \newcommand{\subsubsection}[1]{\medskip\bigskip
  
! \noindent\textbf{\large #1}\vspace{-3ex}
  
! \noindent}
! \newcommand{\tmstrong}[1]{\textbf{#1}}
! %%%%%%%%%% End TeXmacs macros
  
! \begin{document}
  
! \chapter{Conceptes b?sics}
  
! \section{Clustering}
  
! \subsection{Introducci?}
  
- \paragraph{En termes generals un cluster ?s un grup de sistemes independents
- que treballen junts com un sistema ?nic. El client interactua amb un cluster
- com si f?s un servidor ?nic. Les configuracions de cluster s'utilitzen per a
- tenir disponibilitat i escalabilitat:}{\begin{description}
-   \item[Disponibilitat:] Quan un sistema falla en el cluster, el programari
-   del cluster respon distribuint el treball del sistema que ha fallat als
-   sistemes que queden en el cluster.
-   
-   \item[Escalabilitat:] Quan la c?rrega general excedeix les capacitats dels
-   sistemes en el cluster, ?s possible afegir sistemes addicionals al mateix.
-   En l'actualitat, els clients que planegen ampliar la capacitat del seu
-   sistema han de considerar servidors "high end" costosos que proporcionen
-   espai per a CPUs, controladors i mem?ria addicionals. A l'utilitzar la
-   tecnologia de clustering, els clients podran afegir gradualment sistemes
-   est?ndars m?s petits, segons sigui necessari, per a satisfer els
-   requeriments generals de pot?ncia de processament.
- \end{description}}
  
! \subsection{Diferents implementacions}
  
! A continuaci? passarem a descriure per sobre algunes de les diferents
! implementacions existents en alguns sistemes operatius, les quals representen
! diferents paradigmes.
  
! \paragraph{\subsubsection{[}Hola]Linux}{\begin{itemize}
!   \item \textbf{OpenMosix:} ?s una imlpementaci? basada en la distribuci? de
!   processos, com a modificaci? per al nucli, de forma que el proc?s ?s
!   totalment transparent a l'usuari (al programador* de l'aplicaci?), cosa que
!   fa molt m?s portables els programes a d'altres sistemes, utilitzin o no
!   OpenMosix, i des d'aplicacions no dissenyades espec?ficament per a
!   executar-se en un cluster.
!   
!   De totes maneres, per tal de poder paral?lelitzar les aplicacions, aquestes
!   han d'haver estat ja programades amb diversos processos, ja que OpenMosix no
!   paral?lelitza aplicacions, sin? que nom?s distribueix la c?rrega entre els
!   diferents nodes.
!   
!   Per exemple, si tenim deu nodes al cluster i executem un programa (amb un
!   sol proc?s), tardar? el mateix que si nom?s tingu?ssim un node; per? si
!   executem deu programes d'aquests, tardaran el que si nom?s n'execut?ssim un,
!   ja que cadascun s'executar? en un node.
!   
!   Un inconvenient, per?, ?s que tots els nodes del cluster han de tenir
!   exactament el mateix nucli (sense compatibilitat de versions ni cap endavant
!   ni cap enrere).
!   
!   Un altre dels problemes de OpenMosix, ?s que no pot migrar cap proc?s que
!   comparteixi mem?ria, de forma que tampoc podr? migrar threads, ja que
!   aquests comparteixen mem?ria.
!   
!   \item \textbf{Beowulf:} {\nocite{Beowulf-Home}} {\nocite{Beowulf-Howto}}
!   Beowulf, segons una de les definicions que hem trobat (doncs alguns diuen
!   que es pot dir que un sistema ?s Beowulf nom?s si est? contru?t de la
!   mateixa forma que la m?quina original de la NASA; d'altres van cap a l'altre
!   extrem i diuen que ?s un sistema Beowulf tot aquell conjunt de m?quines que
!   corren codi paral?lel), ?s una arquitectura multi-computador que pot ser
!   utilitzada per a fer computacoins en paral?lel. Normalment consisteix en un
!   node servidor i un o m?s nodes connectats via Ethernet (o qualsevol altre
!   xarxa), per? el millor de tot ?s que es pot constru?r amb hardware "normal",
!   com per exemple qualsevol PC que pugui utilitzar Linux, adaptadors est?ndar
!   d'Ethernet i switchos. Beowulf tamb? utilitza software "com?", com el
!   sistema operatiu Linux, PVM (Parallel Virtual Machine) i MPI (Message
!   Passing Interface). Una de les grans difer?ncies entre Beowulf i un cluster
!   de estacions de treball (COW - Cluster of Workstations) ?s el fet de qu?
!   Beowulf es comporta com una ?nica m?quina m?s que no mas com un conjunt
!   d'estacions de treball. Els nodes de Beowulf es poden pensar com un paquet
!   de CPU + mem?ria que es pot connectar al cluster, tal com una CPU o un m?dul
!   de mem?ria es poden connectar a una placa base.
!   
!   Beowulf no ?s un paquet de software especial, una nova topologia de xarxa o
!   l'?ltim hack per al kernel, sin? que ?s una tecnologia de clustering de
!   m?quines Linux per a formar un supercomputador paral?lel virtual. Tot i que
!   hi ha varis paquets de software com modificacions per al kernel, llibreries
!   PVM i MPI i eines de configuraci? que fan l'arquitectura Beowulf m?s r?pida,
!   m?s f?cil de configurar i molt m?s usable, un pot constru?r una m?quina de
!   la classe Beowulf utilitzant distribucions de Linux est?ndars sense cap
!   software addicional. Tenint un parell de m?quines linux en xarxa que
!   comparteixen com a m?nim el /home a trav?s de NFS i es confien l'una a
!   l'altra per executar shells remotes (rsh), es podria dir que es t? una
!   m?quina Beowulf molt simple de dos nodes.
!   
!   Aix? doncs, est? clar que una aplicaci?, per a funcionar en una arquitectura
!   Beowulf, ha d'haver estat escrita utilitzant llibreries o m?todes
!   especialitzats, no transparents a l'usuari, per? ofereix m?s rendiment que,
!   per exemple, OpenMosix (tot i que aquest ?ltim ?s totalment transparent a
!   l'usuari).
!   
!   De totes maneres,
!   
!   \item \textbf{...Altre soft de clustering...}
  \end{itemize}}
  
--- 1,56 ----
! \chapter{Conceptes b?sics}
  
! \section{Clustering}
  
! \subsection{Introducci?}
  
! En termes generals un cluster ?s un grup de sistemes independents que treballen
! junts com un sistema ?nic. El client interactua amb un cluster com si f?s un
! servidor ?nic. Les configuracions de cluster s'utilitzen per a tenir
! disponibilitat i escalabilitat:
  
! \begin{description}
! \item[Disponibilitat:]
! Quan un sistema falla en el cluster, el programari del cluster respon distribuint el treball del sistema que ha fallat als sistemes que queden en el cluster.
  
! \item[Escalabilitat:]
! Quan la c?rrega general excedeix les capacitats dels sistemes en el cluster, ?s possible afegir sistemes addicionals al mateix.  En l'actualitat, els clients que planegen ampliar la capacitat del seu sistema han de considerar servidors "high end" costosos que proporcionen espai per a CPUs, controladors i mem?ria addicionals. A l'utilitzar la tecnologia de clustering, els clients podran afegir gradualment sistemes est?ndars m?s petits, segons sigui necessari, per a satisfer els requeriments generals de pot?ncia de processament.
! \end{description}
  
  
! \subsection{Diferents implementacions}
! A continuaci? passarem a descriure per sobre algunes de les diferents
! implementacions existents en alguns sistemes operatius, les quals representen
! diferents paradigmes.
  
  
! \subsubsection{Linux}
  
! \begin{itemize}
! \item \textbf{OpenMosix:}
! ?s una imlpementaci? basada en la distribuci? de processos, com a modificaci? per al nucli, de forma que el proc?s ?s totalment transparent a l'usuari (al programador* de l'aplicaci?), cosa que fa molt m?s portables els programes a d'altres sistemes, utilitzin o no OpenMosix, i des d'aplicacions no dissenyades espec?ficament per a executar-se en un cluster.
  
! De totes maneres, per tal de poder paral?lelitzar les aplicacions, aquestes han d'haver estat ja programades amb diversos processos, ja que OpenMosix no paral?lelitza aplicacions, sin? que nom?s distribueix la c?rrega entre els diferents nodes.
  
! Per exemple, si tenim deu nodes al cluster i executem un programa (amb un sol proc?s), tardar? el mateix que si nom?s tingu?ssim un node; per? si executem deu programes d'aquests, tardaran el que si nom?s n'execut?ssim un, ja que cadascun s'executar? en un node.
  
! Un inconvenient, per?, ?s que tots els nodes del cluster han de tenir exactament el mateix nucli (sense compatibilitat de versions ni cap endavant ni cap enrere).
  
! Un altre dels problemes de OpenMosix, ?s que no pot migrar cap proc?s que comparteixi mem?ria, de forma que tampoc podr? migrar threads, ja que aquests comparteixen mem?ria.
  
  
! \item \textbf{Beowulf:}
! \nocite{Beowulf-Home}
! \nocite{Beowulf-Howto}
! Beowulf, segons una de les definicions que hem trobat (doncs alguns diuen que es pot dir que un sistema ?s Beowulf nom?s si est? contru?t de la mateixa forma que la m?quina original de la NASA; d'altres van cap a l'altre extrem i diuen que ?s un sistema Beowulf tot aquell conjunt de m?quines que corren codi paral?lel), ?s una arquitectura multi-computador que pot ser utilitzada per a fer computacoins en paral?lel. Normalment consisteix en un node servidor i un o m?s nodes connectats via Ethernet (o qualsevol altre xarxa), per? el millor de tot ?s que es pot constru?r amb hardware "normal", com per exemple qualsevol PC que pugui utilitzar Linux, adaptadors est?ndar d'Ethernet i switchos. Beowulf tamb? utilitza software "com?", com el sistema operatiu Linux, PVM (Parallel Virtual Machine) i MPI (Message Passing Interface). Una de les grans difer?ncies entre Beowulf i un cluster de estacions de treball (COW - Cluster of Workstations) ?s el fet de qu? Beowulf es comporta com una ?nica m?quina m?s que no mas com un conjunt d'estacions de treball. Els nodes de Beowulf es poden pensar com un paquet de CPU + mem?ria que es pot connectar al cluster, tal com una CPU o un m?dul de mem?ria es poden connectar a una placa base.
  
! Beowulf no ?s un paquet de software especial, una nova topologia de xarxa o l'?ltim hack per al kernel, sin? que ?s una tecnologia de clustering de m?quines Linux per a formar un supercomputador paral?lel virtual. Tot i que hi ha varis paquets de software com modificacions per al kernel, llibreries PVM i MPI i eines de configuraci? que fan l'arquitectura Beowulf m?s r?pida, m?s f?cil de configurar i molt m?s usable, un pot constru?r una m?quina de la classe Beowulf utilitzant distribucions de Linux est?ndars sense cap software addicional. Tenint un parell de m?quines linux en xarxa que comparteixen com a m?nim el /home a trav?s de NFS i es confien l'una a l'altra per executar shells remotes (rsh), es podria dir que es t? una m?quina Beowulf molt simple de dos nodes.
  
! Aix? doncs, est? clar que una aplicaci?, per a funcionar en una arquitectura Beowulf, ha d'haver estat escrita utilitzant llibreries o m?todes especialitzats, no transparents a l'usuari, per? ofereix m?s rendiment que, per exemple, OpenMosix (tot i que aquest ?ltim ?s totalment transparent a l'usuari).
! 
! De totes maneres,
! 
! 
! \item \textbf{...Altre soft de clustering...}
  \end{itemize}}
  
***************
*** 170,219 ****
  temps real i clustering.
  
  \subsubsection{Altres Sistemes Operatius}
  
  \begin{itemize}
!   \item {\tmstrong{Solaris}}: Hem trobat exemples de cl?sters de computaci?
!   constru?ts amb aquest Sistema Operatiu, per exemple, el SciClone Cluster
!   Project. El cl?ster est? format exclusivament per m?quines Sun per? no donen
!   moltes caracter?stiques del sistema operatiu, ni tampoc si han tingut que
!   desenvolupar un afegit per dona suport per clustering.
!   (http://www.compsci.wm.edu/SciClone/introduction/index.html).
!   
!   \item {\tmstrong{MacOSX:}} Utilitzant la bibloteca de processament carbonlib
!   m?s un software de clustering anomenat pooch
!   (http://daugerresearch.com/pooch/) ?s pot crear un cluster amb aquest
!   sistema operatiu. Com passa a Beowulf per Linux, aquest sistema de
!   clustering est? basat en l'?s de biblioteques de paral.leliitzaci? i per
!   tant els programes s'haur?n d'escriure penssant que s'executen en un cluster
!   no ?s transparent a l'usuari/aplicaci?.
  \end{itemize}
  
  \section{Abstraccions existents en Sistemes de Fitxers}
  
! \subsection{Translators de Hurd} {\nocite{Hurd-Translators}} Els translators
! s?n servidors de Hurd (SO basat en el micronucli gnuMach, tot i que s'est?
! migrant cap a oskit-Mach i, en un futur, cap a L4) que proporcionen la
! interf?cies b?sica del sistema de fitxers, de manera que es poden insertar
! entre el contingut real d'un fitxer (entenent com a fitxer la representaci?
! corresponent en el sistema de fitxers - inode -, doncs el fitxer real pot
! estar en una altra m?quina o, fins i tot, no ser cap fitxer, sin? la
! representaci? d'una zona de mem?ria) i l'usuari que accedeix al fitxer, de
! forma que \textit{tradueix} les peticions de l'usuari.
  
! Els translators, a m?s am?s, tenen unes propietats molt interessants, i ?s que
! des del punt de vista del kernel, no s?n m?s que processos d'usuari, de forma
! que els pot executar qualsevol usuari, sense necessitat de tenir permisos de
! superusuari per instal?lar o modificar un translator, l'?nic que fa falta ?s
! tenir drets d'acc?s a l'inode sobre s'uneix el translator. Molts translators
! no requereixen un fitxer per a funcionar, i ?s per aix? que la informaci?
! sobre aquests es guarda a l'inode.
  
! Els translators s?n responsables de servir totes les operacions del sistema de
! fitxers que fan refer?ncia a l'inode al que s'uneix. Per aix?, al no estar
! restringits al t?pic conjunt d'objectes (fitxer de dispositiu, link, etc.),
! s?n lliures de retornar qualsevol cosa que tingui sentit per al programador.
! Un exemple podria ser un translator que es comport?s com un directori quan f?s
! accedit per \texttt{cd} o \texttt{ls} per? que al mateix temps es comport?s
! com un fitxer al ser accedit per \texttt{cat}.
  
  \subsection{/proc de Linux vs. VFS de Linux}
--- 70,93 ----
  temps real i clustering.
  
+ 
  \subsubsection{Altres Sistemes Operatius}
  
  \begin{itemize}
! \item {\textbf{Solaris:}}
! Hem trobat exemples de cl?sters de computaci? constru?ts amb aquest Sistema Operatiu, per exemple, el SciClone Cluster Project. El cl?ster est? format exclusivament per m?quines Sun per? no donen moltes caracter?stiques del sistema operatiu, ni tampoc si han tingut que desenvolupar un afegit per dona suport per clustering.  (http://www.compsci.wm.edu/SciClone/introduction/index.html).
! 
! \item {\textbf{MacOSX:}}
! Utilitzant la bibloteca de processament carbonlib m?s un software de clustering anomenat pooch (http://daugerresearch.com/pooch/) ?s pot crear un cluster amb aquest sistema operatiu. Com passa a Beowulf per Linux, aquest sistema de clustering est? basat en l'?s de biblioteques de paral.leliitzaci? i per tant els programes s'haur?n d'escriure penssant que s'executen en un cluster no ?s transparent a l'usuari/aplicaci?.
  \end{itemize}
  
  \section{Abstraccions existents en Sistemes de Fitxers}
  
! \subsection{Translators de Hurd}
! \nocite{Hurd-Translators}
! Els translators s?n servidors de Hurd (SO basat en el micronucli gnuMach, tot i que s'est? migrant cap a oskit-Mach i, en un futur, cap a L4) que proporcionen la interf?cies b?sica del sistema de fitxers, de manera que es poden insertar entre el contingut real d'un fitxer (entenent com a fitxer la representaci? corresponent en el sistema de fitxers - inode -, doncs el fitxer real pot estar en una altra m?quina o, fins i tot, no ser cap fitxer, sin? la representaci? d'una zona de mem?ria) i l'usuari que accedeix al fitxer, de forma que \textit{tradueix} les peticions de l'usuari.
  
! Els translators, a m?s am?s, tenen unes propietats molt interessants, i ?s que des del punt de vista del kernel, no s?n m?s que processos d'usuari, de forma que els pot executar qualsevol usuari, sense necessitat de tenir permisos de superusuari per instal?lar o modificar un translator, l'?nic que fa falta ?s tenir drets d'acc?s a l'inode sobre s'uneix el translator. Molts translators no requereixen un fitxer per a funcionar, i ?s per aix? que la informaci? sobre aquests es guarda a l'inode.
  
! Els translators s?n responsables de servir totes les operacions del sistema de fitxers que fan refer?ncia a l'inode al que s'uneix. Per aix?, al no estar restringits al t?pic conjunt d'objectes (fitxer de dispositiu, link, etc.), s?n lliures de retornar qualsevol cosa que tingui sentit per al programador.  Un exemple podria ser un translator que es comport?s com un directori quan f?s accedit per \texttt{cd} o \texttt{ls} per? que al mateix temps es comport?s com un fitxer al ser accedit per \texttt{cat}.
  
  \subsection{/proc de Linux vs. VFS de Linux}
***************
*** 221,223 ****
  \subsection{...Altres abstraccions en SFs...}
  
- \end{document}
--- 95,96 ----



From nobody at sheep.berlios.de  Tue Jun  8 23:55:46 2004
From: nobody at sheep.berlios.de (xscript)
Date: Tue, 8 Jun 2004 23:55:46 +0200
Subject: [Taca-cvs] doc 02.tex,1.3,1.4 03.tex,1.3,1.4
Message-ID: <200406082155.i58LtjB04608@bat.berlios.de>

Update of /cvsroot/taca/doc
In directory sheep:/tmp/cvs-serv18172

Modified Files:
	02.tex 03.tex 
Log Message:
Doc 2004/06/08

Index: 02.tex
===================================================================
RCS file: /cvsroot/taca/doc/02.tex,v
retrieving revision 1.3
retrieving revision 1.4
diff -C2 -d -r1.3 -r1.4
*** 02.tex	8 Jun 2004 21:22:52 -0000	1.3
--- 02.tex	8 Jun 2004 21:55:43 -0000	1.4
***************
*** 12,19 ****
  \begin{description}
  \item[Disponibilitat:]
! Quan un sistema falla en el cluster, el programari del cluster respon distribuint el treball del sistema que ha fallat als sistemes que queden en el cluster.
  
  \item[Escalabilitat:]
! Quan la c?rrega general excedeix les capacitats dels sistemes en el cluster, ?s possible afegir sistemes addicionals al mateix.  En l'actualitat, els clients que planegen ampliar la capacitat del seu sistema han de considerar servidors "high end" costosos que proporcionen espai per a CPUs, controladors i mem?ria addicionals. A l'utilitzar la tecnologia de clustering, els clients podran afegir gradualment sistemes est?ndars m?s petits, segons sigui necessari, per a satisfer els requeriments generals de pot?ncia de processament.
  \end{description}
  
--- 12,27 ----
  \begin{description}
  \item[Disponibilitat:]
! Quan un sistema falla en el cluster, el programari del cluster respon
! distribuint el treball del sistema que ha fallat als sistemes que queden en el
! cluster.
  
  \item[Escalabilitat:]
! Quan la c?rrega general excedeix les capacitats dels sistemes en el cluster, ?s
! possible afegir sistemes addicionals al mateix.  En l'actualitat, els clients
! que planegen ampliar la capacitat del seu sistema han de considerar servidors
! "high end" costosos que proporcionen espai per a CPUs, controladors i mem?ria
! addicionals. A l'utilitzar la tecnologia de clustering, els clients podran
! afegir gradualment sistemes est?ndars m?s petits, segons sigui necessari, per a
! satisfer els requeriments generals de pot?ncia de processament.
  \end{description}
  
***************
*** 29,41 ****
  \begin{itemize}
  \item \textbf{OpenMosix:}
! ?s una imlpementaci? basada en la distribuci? de processos, com a modificaci? per al nucli, de forma que el proc?s ?s totalment transparent a l'usuari (al programador* de l'aplicaci?), cosa que fa molt m?s portables els programes a d'altres sistemes, utilitzin o no OpenMosix, i des d'aplicacions no dissenyades espec?ficament per a executar-se en un cluster.
  
! De totes maneres, per tal de poder paral?lelitzar les aplicacions, aquestes han d'haver estat ja programades amb diversos processos, ja que OpenMosix no paral?lelitza aplicacions, sin? que nom?s distribueix la c?rrega entre els diferents nodes.
  
! Per exemple, si tenim deu nodes al cluster i executem un programa (amb un sol proc?s), tardar? el mateix que si nom?s tingu?ssim un node; per? si executem deu programes d'aquests, tardaran el que si nom?s n'execut?ssim un, ja que cadascun s'executar? en un node.
  
! Un inconvenient, per?, ?s que tots els nodes del cluster han de tenir exactament el mateix nucli (sense compatibilitat de versions ni cap endavant ni cap enrere).
  
! Un altre dels problemes de OpenMosix, ?s que no pot migrar cap proc?s que comparteixi mem?ria, de forma que tampoc podr? migrar threads, ja que aquests comparteixen mem?ria.
  
  
--- 37,63 ----
  \begin{itemize}
  \item \textbf{OpenMosix:}
! ?s una imlpementaci? basada en la distribuci? de processos, com a modificaci?
! per al nucli, de forma que el proc?s ?s totalment transparent a l'usuari (al
! programador* de l'aplicaci?), cosa que fa molt m?s portables els programes a
! d'altres sistemes, utilitzin o no OpenMosix, i des d'aplicacions no dissenyades
! espec?ficament per a executar-se en un cluster.
  
! De totes maneres, per tal de poder paral?lelitzar les aplicacions, aquestes han
! d'haver estat ja programades amb diversos processos, ja que OpenMosix no
! paral?lelitza aplicacions, sin? que nom?s distribueix la c?rrega entre els
! diferents nodes.
  
! Per exemple, si tenim deu nodes al cluster i executem un programa (amb un sol
! proc?s), tardar? el mateix que si nom?s tingu?ssim un node; per? si executem deu
! programes d'aquests, tardaran el que si nom?s n'execut?ssim un, ja que cadascun
! s'executar? en un node.
  
! Un inconvenient, per?, ?s que tots els nodes del cluster han de tenir exactament
! el mateix nucli (sense compatibilitat de versions ni cap endavant ni cap
! enrere).
  
! Un altre dels problemes de OpenMosix, ?s que no pot migrar cap proc?s que
! comparteixi mem?ria, de forma que tampoc podr? migrar threads, ja que aquests
! comparteixen mem?ria.
  
  
***************
*** 43,51 ****
  \nocite{Beowulf-Home}
  \nocite{Beowulf-Howto}
! Beowulf, segons una de les definicions que hem trobat (doncs alguns diuen que es pot dir que un sistema ?s Beowulf nom?s si est? contru?t de la mateixa forma que la m?quina original de la NASA; d'altres van cap a l'altre extrem i diuen que ?s un sistema Beowulf tot aquell conjunt de m?quines que corren codi paral?lel), ?s una arquitectura multi-computador que pot ser utilitzada per a fer computacoins en paral?lel. Normalment consisteix en un node servidor i un o m?s nodes connectats via Ethernet (o qualsevol altre xarxa), per? el millor de tot ?s que es pot constru?r amb hardware "normal", com per exemple qualsevol PC que pugui utilitzar Linux, adaptadors est?ndar d'Ethernet i switchos. Beowulf tamb? utilitza software "com?", com el sistema operatiu Linux, PVM (Parallel Virtual Machine) i MPI (Message Passing Interface). Una de les grans difer?ncies entre Beowulf i un cluster de estacions de treball (COW - Cluster of Workstations) ?s el fet de qu? Beowulf es comporta com una ?nica m?quina m?s que no mas com un conjunt d'estacions de treball. Els nodes de Beowulf es poden pensar com un paquet de CPU + mem?ria que es pot connectar al cluster, tal com una CPU o un m?dul de mem?ria es poden connectar a una placa base.
  
! Beowulf no ?s un paquet de software especial, una nova topologia de xarxa o l'?ltim hack per al kernel, sin? que ?s una tecnologia de clustering de m?quines Linux per a formar un supercomputador paral?lel virtual. Tot i que hi ha varis paquets de software com modificacions per al kernel, llibreries PVM i MPI i eines de configuraci? que fan l'arquitectura Beowulf m?s r?pida, m?s f?cil de configurar i molt m?s usable, un pot constru?r una m?quina de la classe Beowulf utilitzant distribucions de Linux est?ndars sense cap software addicional. Tenint un parell de m?quines linux en xarxa que comparteixen com a m?nim el /home a trav?s de NFS i es confien l'una a l'altra per executar shells remotes (rsh), es podria dir que es t? una m?quina Beowulf molt simple de dos nodes.
  
! Aix? doncs, est? clar que una aplicaci?, per a funcionar en una arquitectura Beowulf, ha d'haver estat escrita utilitzant llibreries o m?todes especialitzats, no transparents a l'usuari, per? ofereix m?s rendiment que, per exemple, OpenMosix (tot i que aquest ?ltim ?s totalment transparent a l'usuari).
  
  De totes maneres,
--- 65,100 ----
  \nocite{Beowulf-Home}
  \nocite{Beowulf-Howto}
! Beowulf, segons una de les definicions que hem trobat (doncs alguns diuen que es
! pot dir que un sistema ?s Beowulf nom?s si est? contru?t de la mateixa forma que
! la m?quina original de la NASA; d'altres van cap a l'altre extrem i diuen que ?s
! un sistema Beowulf tot aquell conjunt de m?quines que corren codi paral?lel), ?s
! una arquitectura multi-computador que pot ser utilitzada per a fer computacoins
! en paral?lel. Normalment consisteix en un node servidor i un o m?s nodes
! connectats via Ethernet (o qualsevol altre xarxa), per? el millor de tot ?s que
! es pot constru?r amb hardware "normal", com per exemple qualsevol PC que pugui
! utilitzar Linux, adaptadors est?ndar d'Ethernet i switchos. Beowulf tamb?
! utilitza software "com?", com el sistema operatiu Linux, PVM (Parallel Virtual
! Machine) i MPI (Message Passing Interface). Una de les grans difer?ncies entre
! Beowulf i un cluster de estacions de treball (COW - Cluster of Workstations) ?s
! el fet de qu? Beowulf es comporta com una ?nica m?quina m?s que no mas com un
! conjunt d'estacions de treball. Els nodes de Beowulf es poden pensar com un
! paquet de CPU + mem?ria que es pot connectar al cluster, tal com una CPU o un
! m?dul de mem?ria es poden connectar a una placa base.
  
! Beowulf no ?s un paquet de software especial, una nova topologia de xarxa o
! l'?ltim hack per al kernel, sin? que ?s una tecnologia de clustering de m?quines
! Linux per a formar un supercomputador paral?lel virtual. Tot i que hi ha varis
! paquets de software com modificacions per al kernel, llibreries PVM i MPI i
! eines de configuraci? que fan l'arquitectura Beowulf m?s r?pida, m?s f?cil de
! configurar i molt m?s usable, un pot constru?r una m?quina de la classe Beowulf
! utilitzant distribucions de Linux est?ndars sense cap software addicional.
! Tenint un parell de m?quines linux en xarxa que comparteixen com a m?nim el
! /home a trav?s de NFS i es confien l'una a l'altra per executar shells remotes
! (rsh), es podria dir que es t? una m?quina Beowulf molt simple de dos nodes.
  
! Aix? doncs, est? clar que una aplicaci?, per a funcionar en una arquitectura
! Beowulf, ha d'haver estat escrita utilitzant llibreries o m?todes
! especialitzats, no transparents a l'usuari, per? ofereix m?s rendiment que, per
! exemple, OpenMosix (tot i que aquest ?ltim ?s totalment transparent a l'usuari).
  
  De totes maneres,
***************
*** 53,57 ****
  
  \item \textbf{...Altre soft de clustering...}
! \end{itemize}}
  
  \subsubsection{Microkernels (Mach/L4)}
--- 102,106 ----
  
  \item \textbf{...Altre soft de clustering...}
! \end{itemize}
  
  \subsubsection{Microkernels (Mach/L4)}
***************
*** 75,82 ****
  \begin{itemize}
  \item {\textbf{Solaris:}}
! Hem trobat exemples de cl?sters de computaci? constru?ts amb aquest Sistema Operatiu, per exemple, el SciClone Cluster Project. El cl?ster est? format exclusivament per m?quines Sun per? no donen moltes caracter?stiques del sistema operatiu, ni tampoc si han tingut que desenvolupar un afegit per dona suport per clustering.  (http://www.compsci.wm.edu/SciClone/introduction/index.html).
  
  \item {\textbf{MacOSX:}}
! Utilitzant la bibloteca de processament carbonlib m?s un software de clustering anomenat pooch (http://daugerresearch.com/pooch/) ?s pot crear un cluster amb aquest sistema operatiu. Com passa a Beowulf per Linux, aquest sistema de clustering est? basat en l'?s de biblioteques de paral.leliitzaci? i per tant els programes s'haur?n d'escriure penssant que s'executen en un cluster no ?s transparent a l'usuari/aplicaci?.
  \end{itemize}
  
--- 124,140 ----
  \begin{itemize}
  \item {\textbf{Solaris:}}
! Hem trobat exemples de cl?sters de computaci? constru?ts amb aquest Sistema
! Operatiu, per exemple, el SciClone Cluster Project. El cl?ster est? format
! exclusivament per m?quines Sun per? no donen moltes caracter?stiques del sistema
! operatiu, ni tampoc si han tingut que desenvolupar un afegit per dona suport per
! clustering.  (http://www.compsci.wm.edu/SciClone/introduction/index.html).
  
  \item {\textbf{MacOSX:}}
! Utilitzant la bibloteca de processament carbonlib m?s un software de clustering
! anomenat pooch (http://daugerresearch.com/pooch/) ?s pot crear un cluster amb
! aquest sistema operatiu. Com passa a Beowulf per Linux, aquest sistema de
! clustering est? basat en l'?s de biblioteques de paral.leliitzaci? i per tant
! els programes s'haur?n d'escriure penssant que s'executen en un cluster no ?s
! transparent a l'usuari/aplicaci?.
  \end{itemize}
  
***************
*** 85,93 ****
  \subsection{Translators de Hurd}
  \nocite{Hurd-Translators}
! Els translators s?n servidors de Hurd (SO basat en el micronucli gnuMach, tot i que s'est? migrant cap a oskit-Mach i, en un futur, cap a L4) que proporcionen la interf?cies b?sica del sistema de fitxers, de manera que es poden insertar entre el contingut real d'un fitxer (entenent com a fitxer la representaci? corresponent en el sistema de fitxers - inode -, doncs el fitxer real pot estar en una altra m?quina o, fins i tot, no ser cap fitxer, sin? la representaci? d'una zona de mem?ria) i l'usuari que accedeix al fitxer, de forma que \textit{tradueix} les peticions de l'usuari.
  
! Els translators, a m?s am?s, tenen unes propietats molt interessants, i ?s que des del punt de vista del kernel, no s?n m?s que processos d'usuari, de forma que els pot executar qualsevol usuari, sense necessitat de tenir permisos de superusuari per instal?lar o modificar un translator, l'?nic que fa falta ?s tenir drets d'acc?s a l'inode sobre s'uneix el translator. Molts translators no requereixen un fitxer per a funcionar, i ?s per aix? que la informaci? sobre aquests es guarda a l'inode.
  
! Els translators s?n responsables de servir totes les operacions del sistema de fitxers que fan refer?ncia a l'inode al que s'uneix. Per aix?, al no estar restringits al t?pic conjunt d'objectes (fitxer de dispositiu, link, etc.), s?n lliures de retornar qualsevol cosa que tingui sentit per al programador.  Un exemple podria ser un translator que es comport?s com un directori quan f?s accedit per \texttt{cd} o \texttt{ls} per? que al mateix temps es comport?s com un fitxer al ser accedit per \texttt{cat}.
  
  \subsection{/proc de Linux vs. VFS de Linux}
--- 143,170 ----
  \subsection{Translators de Hurd}
  \nocite{Hurd-Translators}
! Els translators s?n servidors de Hurd (SO basat en el micronucli gnuMach, tot i
! que s'est? migrant cap a oskit-Mach i, en un futur, cap a L4) que proporcionen
! la interf?cies b?sica del sistema de fitxers, de manera que es poden insertar
! entre el contingut real d'un fitxer (entenent com a fitxer la representaci?
! corresponent en el sistema de fitxers - inode -, doncs el fitxer real pot estar
! en una altra m?quina o, fins i tot, no ser cap fitxer, sin? la representaci?
! d'una zona de mem?ria) i l'usuari que accedeix al fitxer, de forma que
! \textit{tradueix} les peticions de l'usuari.
  
! Els translators, a m?s am?s, tenen unes propietats molt interessants, i ?s que
! des del punt de vista del kernel, no s?n m?s que processos d'usuari, de forma
! que els pot executar qualsevol usuari, sense necessitat de tenir permisos de
! superusuari per instal?lar o modificar un translator, l'?nic que fa falta ?s
! tenir drets d'acc?s a l'inode sobre s'uneix el translator. Molts translators no
! requereixen un fitxer per a funcionar, i ?s per aix? que la informaci? sobre
! aquests es guarda a l'inode.
  
! Els translators s?n responsables de servir totes les operacions del sistema de
! fitxers que fan refer?ncia a l'inode al que s'uneix. Per aix?, al no estar
! restringits al t?pic conjunt d'objectes (fitxer de dispositiu, link, etc.), s?n
! lliures de retornar qualsevol cosa que tingui sentit per al programador.  Un
! exemple podria ser un translator que es comport?s com un directori quan f?s
! accedit per \texttt{cd} o \texttt{ls} per? que al mateix temps es comport?s com
! un fitxer al ser accedit per \texttt{cat}.
  
  \subsection{/proc de Linux vs. VFS de Linux}

Index: 03.tex
===================================================================
RCS file: /cvsroot/taca/doc/03.tex,v
retrieving revision 1.3
retrieving revision 1.4
diff -C2 -d -r1.3 -r1.4
*** 03.tex	8 Jun 2004 21:04:32 -0000	1.3
--- 03.tex	8 Jun 2004 21:55:43 -0000	1.4
***************
*** 1,4 ****
- \begin{document}
- 
  \chapter{Software de clustering existent}
  
--- 1,2 ----
***************
*** 61,65 ****
  \subsubsection{OpenMosix}
  
! \paragraph{A nivell de cluster...}
  \begin{itemize}
  \item Consultar quantitat de nodes del cluster
--- 59,64 ----
  \subsubsection{OpenMosix}
  
! \begin{enumerate}
! \item A nivell de cluster...
  \begin{itemize}
  \item Consultar quantitat de nodes del cluster
***************
*** 69,73 ****
  \end{itemize}
  
! \paragraph{A nivell de node...}
  \begin{itemize}
  \item Quantitat de CPU's d'un node
--- 68,72 ----
  \end{itemize}
  
! \item A nivell de node...
  \begin{itemize}
  \item Quantitat de CPU's d'un node
***************
*** 104,108 ****
  \end{itemize}
  
! \paragraph{A nivell de proces...}
  \begin{itemize}
  \item Moure processos d'un node a un altre
--- 103,107 ----
  \end{itemize}
  
! \item A nivell de proces...
  \begin{itemize}
  \item Moure processos d'un node a un altre
***************
*** 141,151 ****
  	idem que l'anterior
  \end{itemize}
  
! \textbf{\textit{\underline{...? = volem mirar aquesta informacio de processos
! que son a altres maquines?}}} \\
  
  L'escenari sera oferir un VFS nomes al node d'entrada, i els migrate... de
! OPMosix
! no treuen la informacio dels processos de /proc...
  
  
--- 140,151 ----
  	idem que l'anterior
  \end{itemize}
+ \end{enumerate} 
  
! \textbf{\textit{\underline{
! ...? = volem mirar aquesta informacio de processos que son a altres maquines?
! }}} \\
  
  L'escenari sera oferir un VFS nomes al node d'entrada, i els migrate... de
! OPMosix no treuen la informacio dels processos de /proc...
  
  
***************
*** 187,192 ****
  
  Comentar-ho???????????????
- 
- 
- 
- \end{document}
--- 187,188 ----



From nobody at sheep.berlios.de  Thu Jun 10 19:48:52 2004
From: nobody at sheep.berlios.de (xscript)
Date: Thu, 10 Jun 2004 19:48:52 +0200
Subject: [Taca-cvs] codi - New directory
Message-ID: <200406101748.i5AHmlB07361@bat.berlios.de>

Update of /cvsroot/taca/codi
In directory sheep:/tmp/cvs-serv14907/codi

Log Message:
Directory /cvsroot/taca/codi added to the repository




From nobody at sheep.berlios.de  Thu Jun 10 19:49:43 2004
From: nobody at sheep.berlios.de (xscript)
Date: Thu, 10 Jun 2004 19:49:43 +0200
Subject: [Taca-cvs] codi Makefile,NONE,1.1 generic.h,NONE,1.1 inode.c,NONE,1.1 linux_tacafs.c,NONE,1.1 mosix.c,NONE,1.1 rkfs.c,NONE,1.1
Message-ID: <200406101749.i5AHnhB07393@bat.berlios.de>

Update of /cvsroot/taca/codi
In directory sheep:/tmp/cvs-serv14925

Added Files:
	Makefile generic.h inode.c linux_tacafs.c mosix.c rkfs.c 
Log Message:
Ja tenim codi!


--- NEW FILE: Makefile ---
all: 
	gcc -Wall -O2 -D__KERNEL__ -DMODULE -I/lib/modules/`uname -r`/build/include -c rkfs.c mosix.c
	ld -r -o taca.o rkfs.o mosix.o

clean:
	rm -rf *.o

--- NEW FILE: generic.h ---
struct cluster_t {

	char *nom;
	struct cluster_t *next;
};

struct node_t {

	char *nom;
	struct node_t *next;
};

struct proces_t {
	
	char *nom;
	struct proces_t *next;
};



int llistar_clusters (struct cluster_t *llista);

int llistar_nodes (struct cluster_t *cluster_id, struct node_t *llista);

int liistar_procs (struct node_t *node_id, struct proces_t *lista);



int migrar (struct proces_t  *proces, struct node_t *node_desti);

/* El node pot rebre procs. nous ? */
int node_bloquejat_rebre (struct node_t *node);

/* El node pot enviar procs. nous ? */
int node_bloquejat_enviar (struct node_t *node);

/* El proces no es pot migrar */
int proces_bloquejat (struct proces_t *proc);


--- NEW FILE: inode.c ---
/*
 * Resizable simple taca filesystem for Linux.
 *
 * Copyright (C) 2000 Linus Torvalds.
 *               2000 Transmeta Corp.
 *
 * Usage limits added by David Gibson, Linuxcare Australia.
 * This file is released under the GPL.
 */

/*
 * NOTE! This filesystem is probably most useful
 * not as a real filesystem, but as an example of
 * how virtual filesystems can be written.
 *
 * It doesn't get much simpler than this. Consider
 * that this file implements the full semantics of
 * a POSIX-compliant read-write filesystem.
 *
 * Note in particular how the filesystem does not
 * need to implement any data structures of its own
 * to keep track of the virtual data: using the VFS
 * caches is sufficient.
 */

#include <linux/module.h>
#include <linux/fs.h>
#include <linux/pagemap.h>
#include <linux/init.h>
#include <linux/string.h>
#include <linux/locks.h>

#include <asm/uaccess.h>

/* some random number */
#define TACAFS_MAGIC	0x4376a3f1

static struct super_operations tacafs_ops;
static struct address_space_operations tacafs_aops;
static struct file_operations tacafs_file_operations;
static struct inode_operations tacafs_dir_inode_operations;

static int tacafs_statfs(struct super_block *sb, struct statfs *buf)
{
	buf->f_type = TACAFS_MAGIC;
	buf->f_bsize = PAGE_CACHE_SIZE;
	buf->f_namelen = 255;
	return 0;
}

/*
 * Lookup the data. This is trivial - if the dentry didn't already
 * exist, we know it is negative.
 */
static struct dentry * tacafs_lookup(struct inode *dir, struct dentry *dentry)
{
	d_add(dentry, NULL);
	return NULL;
}

/*
 * Read a page. Again trivial. If it didn't already exist
 * in the page cache, it is zero-filled.
 */
static int tacafs_readpage(struct file *file, struct page * page)
{
	if (!Page_Uptodate(page)) {
		memset(kmap(page), 0, PAGE_CACHE_SIZE);
		kunmap(page);
		flush_dcache_page(page);
		SetPageUptodate(page);
	}
	UnlockPage(page);
	return 0;
}

static int tacafs_prepare_write(struct file *file, struct page *page, unsigned offset, unsigned to)
{
	void *addr = kmap(page);
	if (!Page_Uptodate(page)) {
		memset(addr, 0, PAGE_CACHE_SIZE);
		flush_dcache_page(page);
		SetPageUptodate(page);
	}
	SetPageDirty(page);
	return 0;
}

static int tacafs_commit_write(struct file *file, struct page *page, unsigned offset, unsigned to)
{
	struct inode *inode = page->mapping->host;
	loff_t pos = ((loff_t)page->index << PAGE_CACHE_SHIFT) + to;

	kunmap(page);
	if (pos > inode->i_size)
		inode->i_size = pos;
	return 0;
}

struct inode *tacafs_get_inode(struct super_block *sb, int mode, int dev)
{
	struct inode * inode = new_inode(sb);

	if (inode) {
		inode->i_mode = mode;
		inode->i_uid = current->fsuid;
		inode->i_gid = current->fsgid;
		inode->i_blksize = PAGE_CACHE_SIZE;
		inode->i_blocks = 0;
		inode->i_rdev = NODEV;
		inode->i_mapping->a_ops = &tacafs_aops;
		inode->i_atime = inode->i_mtime = inode->i_ctime = CURRENT_TIME;
		switch (mode & S_IFMT) {
		default:
			init_special_inode(inode, mode, dev);
			break;
		case S_IFREG:
			inode->i_fop = &tacafs_file_operations;
			break;
		case S_IFDIR:
			inode->i_op = &tacafs_dir_inode_operations;
			inode->i_fop = &dcache_dir_ops;
			break;
		case S_IFLNK:
			inode->i_op = &page_symlink_inode_operations;
			break;
		}
	}
	return inode;
}

/*
 * File creation. Allocate an inode, and we're done..
 */
static int tacafs_mknod(struct inode *dir, struct dentry *dentry, int mode, int dev)
{
	struct inode * inode = tacafs_get_inode(dir->i_sb, mode, dev);
	int error = -ENOSPC;

	if (inode) {
		d_instantiate(dentry, inode);
		dget(dentry);		/* Extra count - pin the dentry in core */
		error = 0;
	}
	return error;
}

static int tacafs_mkdir(struct inode * dir, struct dentry * dentry, int mode)
{
	return tacafs_mknod(dir, dentry, mode | S_IFDIR, 0);
}

static int tacafs_create(struct inode *dir, struct dentry *dentry, int mode)
{
	return tacafs_mknod(dir, dentry, mode | S_IFREG, 0);
}

/*
 * Link a file..
 */
static int tacafs_link(struct dentry *old_dentry, struct inode * dir, struct dentry * dentry)
{
	struct inode *inode = old_dentry->d_inode;

	if (S_ISDIR(inode->i_mode))
		return -EPERM;

	inode->i_nlink++;
	atomic_inc(&inode->i_count);	/* New dentry reference */
	dget(dentry);		/* Extra pinning count for the created dentry */
	d_instantiate(dentry, inode);
	return 0;
}

static inline int tacafs_positive(struct dentry *dentry)
{
	return dentry->d_inode && !d_unhashed(dentry);
}

/*
 * Check that a directory is empty (this works
 * for regular files too, they'll just always be
 * considered empty..).
 *
 * Note that an empty directory can still have
 * children, they just all have to be negative..
 */
static int tacafs_empty(struct dentry *dentry)
{
	struct list_head *list;

	spin_lock(&dcache_lock);
	list = dentry->d_subdirs.next;

	while (list != &dentry->d_subdirs) {
		struct dentry *de = list_entry(list, struct dentry, d_child);

		if (tacafs_positive(de)) {
			spin_unlock(&dcache_lock);
			return 0;
		}
		list = list->next;
	}
	spin_unlock(&dcache_lock);
	return 1;
}

/*
 * This works for both directories and regular files.
 * (non-directories will always have empty subdirs)
 */
static int tacafs_unlink(struct inode * dir, struct dentry *dentry)
{
	int retval = -ENOTEMPTY;

	if (tacafs_empty(dentry)) {
		struct inode *inode = dentry->d_inode;

		inode->i_nlink--;
		dput(dentry);			/* Undo the count from "create" - this does all the work */
		retval = 0;
	}
	return retval;
}

#define tacafs_rmdir tacafs_unlink

/*
 * The VFS layer already does all the dentry stuff for rename,
 * we just have to decrement the usage count for the target if
 * it exists so that the VFS layer correctly free's it when it
 * gets overwritten.
 */
static int tacafs_rename(struct inode * old_dir, struct dentry *old_dentry, struct inode * new_dir,struct dentry *new_dentry)
{
	int error = -ENOTEMPTY;

	if (tacafs_empty(new_dentry)) {
		struct inode *inode = new_dentry->d_inode;
		if (inode) {
			inode->i_nlink--;
			dput(new_dentry);
		}
		error = 0;
	}
	return error;
}

static int tacafs_symlink(struct inode * dir, struct dentry *dentry, const char * symname)
{
	int error;

	error = tacafs_mknod(dir, dentry, S_IFLNK | S_IRWXUGO, 0);
	if (!error) {
		int l = strlen(symname)+1;
		struct inode *inode = dentry->d_inode;
		error = block_symlink(inode, symname, l);
	}
	return error;
}

static int tacafs_sync_file(struct file * file, struct dentry *dentry, int datasync)
{
	return 0;
}

static struct address_space_operations tacafs_aops = {
	readpage:	tacafs_readpage,
	writepage:	fail_writepage,
	prepare_write:	tacafs_prepare_write,
	commit_write:	tacafs_commit_write
};

static struct file_operations tacafs_file_operations = {
	read:		generic_file_read,
	write:		generic_file_write,
	mmap:		generic_file_mmap,
	fsync:		tacafs_sync_file,
};

static struct inode_operations tacafs_dir_inode_operations = {
	create:		tacafs_create,
	lookup:		tacafs_lookup,
	link:		tacafs_link,
	unlink:		tacafs_unlink,
	symlink:	tacafs_symlink,
	mkdir:		tacafs_mkdir,
	rmdir:		tacafs_rmdir,
	mknod:		tacafs_mknod,
	rename:		tacafs_rename,
};

static struct super_operations tacafs_ops = {
	statfs:		tacafs_statfs,
	put_inode:	force_delete,
};

static struct super_block *tacafs_read_super(struct super_block * sb, void * data, int silent)
{
	struct inode * inode;
	struct dentry * root;

	sb->s_blocksize = PAGE_CACHE_SIZE;
	sb->s_blocksize_bits = PAGE_CACHE_SHIFT;
	sb->s_magic = TACAFS_MAGIC;
	sb->s_op = &tacafs_ops;
	inode = tacafs_get_inode(sb, S_IFDIR | 0755, 0);
	if (!inode)
		return NULL;

	root = d_alloc_root(inode);
	if (!root) {
		iput(inode);
		return NULL;
	}
	sb->s_root = root;
	return sb;
}

static DECLARE_FSTYPE(tacafs_fs_type, "tacafs", tacafs_read_super, FS_LITTER);
static DECLARE_FSTYPE(rootfs_fs_type, "rootfs", tacafs_read_super, FS_NOMOUNT|FS_LITTER);

static int __init init_tacafs_fs(void)
{
	return register_filesystem(&tacafs_fs_type);
}

static void __exit exit_tacafs_fs(void)
{
	unregister_filesystem(&tacafs_fs_type);
}

module_init(init_tacafs_fs)
module_exit(exit_tacafs_fs)

int __init init_rootfs(void)
{
	return register_filesystem(&rootfs_fs_type);
}

MODULE_LICENSE("GPL");


--- NEW FILE: linux_tacafs.c ---
#define MODULE
#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/init.h>

static struct super_block *tacafs_read_super(struct super_block *, void *, int);
static int tacafs_fill_super (struct super_block *, void *, int);


static DECLARE_FSTYPE(tacafs_fs_type, "tacafs", tacafs_read_super);




struct file_system_type tacafs_fs_type = {
	.owner = THIS_MODULE,
	.name = "tacafs",
	.read_super = tacafs_read_super,
};

static struct super_operations tacafs_s_ops = {
	.statfs         = simple_statfs,	//depen de libfs
	.drop_inode     = generic_delete_inode, //depen de libfs
};





struct inode *tacafs_get_inode(struct super_block *sb, int mode, int dev)
{
	struct inode * inode = new_inode(sb);

	if (inode) {
		inode->i_mode = mode;
		inode->i_uid = current->fsuid;
		inode->i_gid = current->fsgid;
		inode->i_blksize = PAGE_CACHE_SIZE;
		inode->i_blocks = 0;
		inode->i_rdev = NODEV;
		inode->i_mapping->a_ops = &tacafs_s_aops;
		inode->i_atime = inode->i_mtime = inode->i_ctime = CURRENT_TIME;
		switch (mode & S_IFMT) {
			default:
				init_special_inode(inode, mode, dev);
				break;
			case S_IFREG:
				inode->i_fop = &tacafs_file_operations;
				break;
			case S_IFDIR:
				inode->i_op = &tacafs_dir_inode_operations;
				inode->i_fop = &dcache_dir_ops;
				break;
			case S_IFLNK:
				inode->i_op = &page_symlink_inode_operations;
				break;
		}
	}
	return inode;
}













/*
 * Operacio per llegir el superblock
 */
static struct super_block *tacafs_get_super(struct file_system_type *fst,
				int flags, const char *devname, void *data)
{
		return get_sb_single(fst, flags, data, tacafs_fill_super);
}

/* 
 * Operacio per omplir camps del superblock
 */
static int tacafs_fill_super (struct super_block *sb, void *data, int silent) {
	
tatic struct super_block *tacafs_read_super(struct super_block * sb, void * data, int silent)
{
	struct inode * inode;
	struct dentry * root;

	sb->s_blocksize = PAGE_CACHE_SIZE;
	sb->s_blocksize_bits = PAGE_CACHE_SHIFT;
	sb->s_magic = TACAFS_MAGIC;
	sb->s_op = &tacafs_s_ops;
	inode = tacafs_get_inode(sb, S_IFDIR | 0755, 0);
	if (!inode)
		return NULL;

	root = d_alloc_root(inode);
	if (!root) {
		iput(inode);
		return NULL;
	}
	sb->s_root = root;
	return sb;
}


}

static int __init init_tacafs_fs(void)
{
	        return register_filesystem(&tacafs_fs_type);
}

static void __exit exit_tacafs_fs(void)
{
	        unregister_filesystem(&tacafs_fs_type);
}

module_init(init_tacafs_fs);
module_exit(exit_tacafs_fs);

	









int init_module(void)      
{ 
	//printk(KERN_INFO "Hello, world\n"); 
	return register_filesystem(&tacafs_type);
}


struct file_system_type lfs_type = {
	.owner 	= THIS_MODULE,
	.name	= "lwnfs",
	.get_sb	= lfs_get_super,
	.kill_sb	= kill_litter_super,
};



--- NEW FILE: mosix.c ---
#include "generic.h"
#include <linux/mm.h>


//struct cluster_t clus = {.nom = "123",
//			 .next = NULL};

struct node_t n3 = {	.nom = "n3",
			.next = NULL};
struct node_t n2 = {	.nom = "n2",
			.next = &n3 };
struct node_t n1 = {	.nom = "n1",
			.next = &n2};

struct proces_t p3 = {	.nom = "proc3",
			.next = NULL};

struct proces_t p2 = {	.nom = "proc2",
			.next = &p3};
struct proces_t p1 = {	.nom = "proc1",
			.next = &p2};

int llistar_clusters (struct cluster_t *llista)
{
	//llista = (struct cluster_t *)kmalloc(sizeof(struct cluster_t) ,GFP_KERNEL);	
	llista->nom = "c1" ;
	llista->next = NULL;
	return 0;
}

int llistar_nodes (struct cluster_t *cluster_id, struct node_t *llista)
{
	//llista[0] = &n1;
	//llista[1] = &n2;
	//llista[2] = &n3;
	
}

int liistar_procs (struct node_t *node_id, struct proces_t *llista)
{
	//llista[0] = &p1;
	//llista[1] = &p2;
	//llista[2] = &p3;
}


//int migrar (struct proces_t  *proces, struct node_t *node_desti);

/* El node pot rebre procs. nous ? */
//int node_bloquejat_rebre (struct node_t *node);

/* El node pot enviar procs. nous ? */
//int node_bloquejat_enviar (struct node_t *node);

/* El proces no es pot migrar */
//int proces_bloquejat (struct proces_t *proc);


--- NEW FILE: rkfs.c ---
/**
 * Notes:
 * Implementing a small filesystem having one file
 *
 * -> What happens when we mount a file system?
 * -> What do we need to provide to the kernel so that we are mountable?
 * -> What inode, dentry and file operations do we have to support?
 */

#include <linux/kernel.h>
#include <linux/module.h>
#include <linux/version.h>
/*
  #if CONFIG_MODVERSIONS==1
  #define MODVERSIONS
  #include <linux/modversions.h>
  #endif
*/
#include <linux/fs.h>
#include <linux/sched.h>

#include <linux/mm.h>

#include "generic.h"

#define RKFS_MAGIC 0xabcd
#define FILE_INODE_NUMBER 2

static struct super_block *rkfs_read_super(struct super_block *, void *, int);
void rkfs_s_readinode( struct inode *inode );
int rkfs_s_statfs( struct super_block *sb, struct statfs *buf );
struct dentry *rkfs_i_lookup( struct inode *parent_inode, struct dentry *dentry );
ssize_t rkfs_f_read( struct file *file, char *buf, size_t max, loff_t *len );
int rkfs_f_readdir( struct file *file, void *dirent, filldir_t filldir );
ssize_t rkfs_f_write (struct file *, const char *, size_t, loff_t *);
int rkfs_f_release (struct inode *, struct file *);

/*
 * Data declarations
 */

static struct super_operations rkfs_sops = {
    read_inode: rkfs_s_readinode,
    statfs: rkfs_s_statfs
    //  put_inode: rkfs_s_putinode,
    //  delete_inode:    rkfs_s_deleteinode,
    //  statfs: rkfs_s_statfs
};

struct inode_operations rkfs_iops = {
    lookup: rkfs_i_lookup
};

struct file_operations rkfs_dir_fops = {
    read   : generic_read_dir,
    readdir: &rkfs_f_readdir
};

struct file_operations rkfs_file_fops = {
    read : &rkfs_f_read,
    write: &rkfs_f_write
    //    release: &rkfs_f_release
};

// use this macro to declare the filesystem structure
DECLARE_FSTYPE( rkfs, "rkfs", rkfs_read_super, 0 );
struct inode *rkfs_root_inode;

char file_buf[1024] = "Hello World\n";
int file_size = 12;

/*
 * File-System Operations
 */
/*
 * This will be called when the kernel is attempting to mount something. It creates a
 * super_block structure and calls our callback/function to fill it.
 */
static struct super_block *rkfs_read_super( struct super_block *sb, void *buf, int size ) {
    sb->s_blocksize = 1024;
    sb->s_blocksize_bits = 10;
    sb->s_magic = RKFS_MAGIC;
    sb->s_op = &rkfs_sops; // super block operations
    sb->s_type = &rkfs; // file_system_type

    rkfs_root_inode = iget( sb, 1 ); // allocate an inode
    rkfs_root_inode->i_op = &rkfs_iops; // set the inode ops
    rkfs_root_inode->i_mode = S_IFDIR|S_IRWXU;
    rkfs_root_inode->i_fop = &rkfs_dir_fops;

    if(!(sb->s_root = d_alloc_root(rkfs_root_inode))) {
        iput(rkfs_root_inode);
        return NULL;
    }

    printk( "rkfs: read_super returning a valid super_block\n" );
    return sb;
}

/*
 * Super-Block Operations
 */

void rkfs_s_readinode( struct inode *inode ) {
    inode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME;
    printk( "rkfs: super_operations.readinode called\n" );
}

/*
 * This will be called to get the filesystem information like size etc.
 */
int rkfs_s_statfs( struct super_block *sb, struct statfs *buf ) {
    buf->f_type = RKFS_MAGIC;
    buf->f_bsize = PAGE_SIZE/sizeof(long);
    buf->f_bfree = 0;
    buf->f_bavail = 0;
    buf->f_ffree = 0;
    buf->f_namelen = NAME_MAX;
    printk( "rkfs: super_operations.statfs called\n" );
    return 0;
}

/*
 * Inode Operations
 */

struct dentry *rkfs_i_lookup( struct inode *parent_inode, struct dentry *dentry ) {
  struct inode *file_inode;

  if( parent_inode->i_ino == rkfs_root_inode->i_ino && strlen("hello.txt") == dentry->d_name.len && !strcmp(dentry->d_name.name, "hello.txt")) {
	  // allocate an inode object
	  if(!(file_inode = iget( parent_inode->i_sb, FILE_INODE_NUMBER )))
		  return ERR_PTR(-ENOMEM);
	  file_inode->i_size = file_size;
	  file_inode->i_mode = S_IFREG|S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH;
	  file_inode->i_fop = &rkfs_file_fops;
	  //  add the inode to the dentry object
	  d_add(dentry, file_inode);
  }
  if( parent_inode->i_ino == rkfs_root_inode->i_ino && strlen("tonto") == dentry->d_name.len && !strcmp(dentry->d_name.name, "tonto")) {
	  // allocate an inode object
	  if(!(file_inode = iget( parent_inode->i_sb, 3)))
		  return ERR_PTR(-ENOMEM);
	  //file_inode->i_size = file_size;
	  file_inode->i_mode = S_IFDIR|S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH;
	  file_inode->i_fop = &rkfs_file_fops;
	  file_inode->i_op = &rkfs_iops;
	  //  add the inode to the dentry object
	  d_add(dentry, file_inode);
  }
  else {
      return ERR_PTR(-ENOENT);
  }
  printk( "rkfs: inode_operations.lookup called with dentry %s. size = %d\n", dentry->d_name.name, file_size );
  return NULL;
}

/*
 * File Operations
 */

ssize_t rkfs_f_read( struct file *file, char *buf, size_t max, loff_t *offset ) {
    int i;
    int buflen;
    if(*offset > 0)
        return 0;
    printk( "rkfs: file_operations.read called %d %d\n", max, *offset );
    buflen = file_size > max ? max : file_size;
    __generic_copy_to_user(buf, file_buf, buflen);
    //           copy_to_user(buf, file_buf, buflen);
    *offset += buflen; // advance the offset
    return buflen;
}

ssize_t rkfs_f_write (struct file *file, const char *buf, size_t maxlen, loff_t *offset) {
    int count;
    if(*offset > 0) {
        printk("Positive offset %d\n", *offset);
        return 0;
    }
    count = maxlen > sizeof(file_buf) ? sizeof(file_buf) : maxlen;
    __generic_copy_from_user(file_buf, buf, count);
        //    copy_from_user(file_buf, buf, maxlen);
    printk( "file_operations.write called with maxlen=%d, off=%d\n", maxlen, *offset );
    *offset += count;
    if(*offset > file_size)
        file_size = *offset;
    return count;
}

/*
int rkfs_f_release (struct inode *ino, struct file *file) {
    printk( "rkfs: file_operations.release called\n" );
    return 0;
}
*/

int rkfs_f_readdir( struct file *file, void *dirent, filldir_t filldir ) {
    int err;
    struct dentry *de = file->f_dentry;

    printk( "rkfs: file_operations.readdir called\n" );
    if(file->f_pos > 0 )
        return 1;
    
    if(filldir(dirent, ".", 1, file->f_pos++, de->d_inode->i_ino, DT_DIR)||
       (filldir(dirent, "..", 2, file->f_pos++, de->d_parent->d_inode->i_ino, DT_DIR)))
        return 0;
    
    if(de->d_inode->i_ino == rkfs_root_inode->i_ino) // Estem a l'arrel 
    {
	struct cluster_t *llista;
	llista = (struct cluster_t *)kmalloc(sizeof(struct cluster_t) ,GFP_KERNEL);	
	llistar_clusters(llista);

    	printk( "rkfs: file_operations.readdir called caca\n" );
	while (llista != NULL) {	
		if(filldir(dirent, llista->nom, strlen(llista->nom), file->f_pos++, 3, DT_DIR ))
	         	return 0;
		llista = llista->next;
    	printk( "rkfs: file_operations.readdir called bucle\n" );
	} 
    printk( "rkfs: file_operations.readdir calledi final\n" );
		
    }
//	    if(filldir(dirent, "hello.txt", 9, file->f_pos++, FILE_INODE_NUMBER, DT_REG ))
	    
  //  if(filldir(dirent, "hello.txt", 9, file->f_pos++, FILE_INODE_NUMBER, DT_REG ))
    //    return 0;
    /* Mostrar subdirs */
//    if(filldir(dirent, "tonto", 5, file->f_pos++, 3, DT_DIR ))
//        return 0;
    
    
    return 1;
}

int init_module(void) {
    int err;
    err = register_filesystem( &rkfs );
    return err;
}

void cleanup_module(void) {
    unregister_filesystem( &rkfs );
}

MODULE_LICENSE("GPL");



From nobody at sheep.berlios.de  Fri Jun 11 04:39:32 2004
From: nobody at sheep.berlios.de (xscript)
Date: Fri, 11 Jun 2004 04:39:32 +0200
Subject: [Taca-cvs] code - New directory
Message-ID: <200406110239.i5B2dWB18232@bat.berlios.de>

Update of /cvsroot/taca/code
In directory sheep:/tmp/cvs-serv11068/code

Log Message:
Directory /cvsroot/taca/code added to the repository




From nobody at sheep.berlios.de  Fri Jun 11 04:40:09 2004
From: nobody at sheep.berlios.de (xscript)
Date: Fri, 11 Jun 2004 04:40:09 +0200
Subject: [Taca-cvs] code/backend - New directory
Message-ID: <200406110240.i5B2e9B18250@bat.berlios.de>

Update of /cvsroot/taca/code/backend
In directory sheep:/tmp/cvs-serv11128/backend

Log Message:
Directory /cvsroot/taca/code/backend added to the repository




From nobody at sheep.berlios.de  Fri Jun 11 04:40:09 2004
From: nobody at sheep.berlios.de (xscript)
Date: Fri, 11 Jun 2004 04:40:09 +0200
Subject: [Taca-cvs] code/frontend - New directory
Message-ID: <200406110240.i5B2e9B18253@bat.berlios.de>

Update of /cvsroot/taca/code/frontend
In directory sheep:/tmp/cvs-serv11128/frontend

Log Message:
Directory /cvsroot/taca/code/frontend added to the repository




From nobody at sheep.berlios.de  Fri Jun 11 04:40:29 2004
From: nobody at sheep.berlios.de (xscript)
Date: Fri, 11 Jun 2004 04:40:29 +0200
Subject: [Taca-cvs] code/backend/openmosix - New directory
Message-ID: <200406110240.i5B2eTB18260@bat.berlios.de>

Update of /cvsroot/taca/code/backend/openmosix
In directory sheep:/tmp/cvs-serv11182/openmosix

Log Message:
Directory /cvsroot/taca/code/backend/openmosix added to the repository




From nobody at sheep.berlios.de  Fri Jun 11 04:40:53 2004
From: nobody at sheep.berlios.de (xscript)
Date: Fri, 11 Jun 2004 04:40:53 +0200
Subject: [Taca-cvs] code/backend/openmosix/2.4.22 - New directory
Message-ID: <200406110240.i5B2erB18267@bat.berlios.de>

Update of /cvsroot/taca/code/backend/openmosix/2.4.22
In directory sheep:/tmp/cvs-serv11231/2.4.22

Log Message:
Directory /cvsroot/taca/code/backend/openmosix/2.4.22 added to the repository




From nobody at sheep.berlios.de  Fri Jun 11 04:41:44 2004
From: nobody at sheep.berlios.de (xscript)
Date: Fri, 11 Jun 2004 04:41:44 +0200
Subject: [Taca-cvs] code/frontend/linux - New directory
Message-ID: <200406110241.i5B2fiB18325@bat.berlios.de>

Update of /cvsroot/taca/code/frontend/linux
In directory sheep:/tmp/cvs-serv11288/linux

Log Message:
Directory /cvsroot/taca/code/frontend/linux added to the repository




From nobody at sheep.berlios.de  Fri Jun 11 04:48:49 2004
From: nobody at sheep.berlios.de (xscript)
Date: Fri, 11 Jun 2004 04:48:49 +0200
Subject: [Taca-cvs] code Makefile,NONE,1.1 Rules.conf,NONE,1.1
Message-ID: <200406110248.i5B2mnB18503@bat.berlios.de>

Update of /cvsroot/taca/code
In directory sheep:/tmp/cvs-serv11627/code

Added Files:
	Makefile Rules.conf 
Log Message:
Reorganization of code

--- NEW FILE: Makefile ---
# See Rules.conf for configuration params

include Rules.conf

# global flags definitions
CFLAGS  += -Wall -O2 \
	   -D__KERNEL__ -DMODULE \
	   -I$(TOPDIR)/backend

#LDFLAGS += 

TOPDIR = $(shell /bin/pwd)

export CFLAGS TOPDIR # LDFLAGS

all: $(TARGET)

$(TARGET):
	make -C frontend $(FRONTEND)
	make -C backend $(BACKEND)
	$(LD) -r -o $(TARGET) frontend.o backend.o

re-$(TARGET): clean $(TARGET)

run: $(TARGET)
	insmod $(TARGET)
	if [ ! -d $(MNTPOINT) ]; then mkdir -p $(MNTPOINT); fi
	mount -t $(FSNAME) none $(MNTPOINT)

re-run: re-$(TARGET)
	umount $(MNTPOINT)
	rmmod $(FSNAME)
	make run

clean:
	make -C frontend clean
	make -C backend clean
	rm -f $(TARGET) frontend.o backend.o


--- NEW FILE: Rules.conf ---
# Plese don't edit lines marked with (!)

##############
# General conf

# Available Frontends:
# - linux.o
FRONTEND = linux.o

# Available Backends:
# - openmosix.o
BACKEND  = openmosix.o
# (!)
BACKVER  = $($(BACKEND:.o=)_VER)

TARGET   = tacafs.o
# (!)
FSNAME   = $(TARGET:.o=)
MNTPOINT = /mnt/$(FSNAME)

INCLUDEDIR = /usr/src/kernel-source-2.4.20/include

########################
# Frontend specific conf

# Linux
# (!)
LINUX_CFLAGS += -I$(INCLUDEDIR)


#######################
# Backend specific conf

# OpenMosix
openmosix_VER = 2.4.22# version to use
# (!)
OPENMOSIX_CFLAGS += -I$(INCLUDEDIR)

#########
# Exports
# (!)
export FSNAME BACKVER LINUX_CFLAGS OPENMOSIX_CFLAGS




From nobody at sheep.berlios.de  Fri Jun 11 04:48:50 2004
From: nobody at sheep.berlios.de (xscript)
Date: Fri, 11 Jun 2004 04:48:50 +0200
Subject: [Taca-cvs] code/frontend Makefile,NONE,1.1
Message-ID: <200406110248.i5B2moB18511@bat.berlios.de>

Update of /cvsroot/taca/code/frontend
In directory sheep:/tmp/cvs-serv11627/code/frontend

Added Files:
	Makefile 
Log Message:
Reorganization of code

--- NEW FILE: Makefile ---

%.o:
	make -C $* all

clean:
	$(foreach dir,$(shell find . -type d -maxdepth 1 -mindepth 1 | grep -v CVS),make -C $(dir) clean)




From nobody at sheep.berlios.de  Fri Jun 11 04:48:51 2004
From: nobody at sheep.berlios.de (xscript)
Date: Fri, 11 Jun 2004 04:48:51 +0200
Subject: [Taca-cvs] code/frontend/linux Makefile,NONE,1.1 linux.c,NONE,1.1
Message-ID: <200406110248.i5B2mpB18514@bat.berlios.de>

Update of /cvsroot/taca/code/frontend/linux
In directory sheep:/tmp/cvs-serv11627/code/frontend/linux

Added Files:
	Makefile linux.c 
Log Message:
Reorganization of code

--- NEW FILE: Makefile ---

CFLAGS += $(LINUX_CFLAGS)

TARGET = linux.o
#OBJS   = a.c b.c

all: $(TARGET)
	cp $(TARGET) $(TOPDIR)/frontend.o

#$(TARGET): $(OBJS)

clean:
	rm -f $(TARGET)


--- NEW FILE: linux.c ---
/**
 * Notes:
 * Implementing a small filesystem having one file
 *
 * -> What happens when we mount a file system?
 * -> What do we need to provide to the kernel so that we are mountable?
 * -> What inode, dentry and file operations do we have to support?
 */

#include <linux/kernel.h>
#include <linux/module.h>
#include <linux/version.h>
/*
  #if CONFIG_MODVERSIONS==1
  #define MODVERSIONS
  #include <linux/modversions.h>
  #endif
*/
#include <linux/fs.h>
#include <linux/sched.h>

#include <linux/mm.h>

#include "backend.h"

#define RKFS_MAGIC 0xabcd
#define FILE_INODE_NUMBER 2

static struct super_block *rkfs_read_super(struct super_block *, void *, int);
void rkfs_s_readinode( struct inode *inode );
int rkfs_s_statfs( struct super_block *sb, struct statfs *buf );
struct dentry *rkfs_i_lookup( struct inode *parent_inode, struct dentry *dentry );
ssize_t rkfs_f_read( struct file *file, char *buf, size_t max, loff_t *len );
int rkfs_f_readdir( struct file *file, void *dirent, filldir_t filldir );
ssize_t rkfs_f_write (struct file *, const char *, size_t, loff_t *);
int rkfs_f_release (struct inode *, struct file *);

/*
 * Data declarations
 */

static struct super_operations rkfs_sops = {
    read_inode: rkfs_s_readinode,
    statfs: rkfs_s_statfs
    //  put_inode: rkfs_s_putinode,
    //  delete_inode:    rkfs_s_deleteinode,
    //  statfs: rkfs_s_statfs
};

struct inode_operations rkfs_iops = {
    lookup: rkfs_i_lookup
};

struct file_operations rkfs_dir_fops = {
    read   : generic_read_dir,
    readdir: &rkfs_f_readdir
};

struct file_operations rkfs_file_fops = {
    read : &rkfs_f_read,
    write: &rkfs_f_write
    //    release: &rkfs_f_release
};

// use this macro to declare the filesystem structure
DECLARE_FSTYPE( rkfs, "rkfs", rkfs_read_super, 0 );
struct inode *rkfs_root_inode;

char file_buf[1024] = "Hello World\n";
int file_size = 12;

/*
 * File-System Operations
 */
/*
 * This will be called when the kernel is attempting to mount something. It creates a
 * super_block structure and calls our callback/function to fill it.
 */
static struct super_block *rkfs_read_super( struct super_block *sb, void *buf, int size ) {
    sb->s_blocksize = 1024;
    sb->s_blocksize_bits = 10;
    sb->s_magic = RKFS_MAGIC;
    sb->s_op = &rkfs_sops; // super block operations
    sb->s_type = &rkfs; // file_system_type

    rkfs_root_inode = iget( sb, 1 ); // allocate an inode
    rkfs_root_inode->i_op = &rkfs_iops; // set the inode ops
    rkfs_root_inode->i_mode = S_IFDIR|S_IRWXU;
    rkfs_root_inode->i_fop = &rkfs_dir_fops;

    if(!(sb->s_root = d_alloc_root(rkfs_root_inode))) {
        iput(rkfs_root_inode);
        return NULL;
    }

    printk( "rkfs: read_super returning a valid super_block\n" );
    return sb;
}

/*
 * Super-Block Operations
 */

void rkfs_s_readinode( struct inode *inode ) {
    inode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME;
    printk( "rkfs: super_operations.readinode called\n" );
}

/*
 * This will be called to get the filesystem information like size etc.
 */
int rkfs_s_statfs( struct super_block *sb, struct statfs *buf ) {
    buf->f_type = RKFS_MAGIC;
    buf->f_bsize = PAGE_SIZE/sizeof(long);
    buf->f_bfree = 0;
    buf->f_bavail = 0;
    buf->f_ffree = 0;
    buf->f_namelen = NAME_MAX;
    printk( "rkfs: super_operations.statfs called\n" );
    return 0;
}

/*
 * Inode Operations
 */

struct dentry *rkfs_i_lookup( struct inode *parent_inode, struct dentry *dentry ) {
  struct inode *file_inode;

  if( parent_inode->i_ino == rkfs_root_inode->i_ino && strlen("hello.txt") == dentry->d_name.len && !strcmp(dentry->d_name.name, "hello.txt")) {
	  // allocate an inode object
	  if(!(file_inode = iget( parent_inode->i_sb, FILE_INODE_NUMBER )))
		  return ERR_PTR(-ENOMEM);
	  file_inode->i_size = file_size;
	  file_inode->i_mode = S_IFREG|S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH;
	  file_inode->i_fop = &rkfs_file_fops;
	  //  add the inode to the dentry object
	  d_add(dentry, file_inode);
  }
  if( parent_inode->i_ino == rkfs_root_inode->i_ino && strlen("tonto") == dentry->d_name.len && !strcmp(dentry->d_name.name, "tonto")) {
	  // allocate an inode object
	  if(!(file_inode = iget( parent_inode->i_sb, 3)))
		  return ERR_PTR(-ENOMEM);
	  //file_inode->i_size = file_size;
	  file_inode->i_mode = S_IFDIR|S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH;
	  file_inode->i_fop = &rkfs_file_fops;
	  file_inode->i_op = &rkfs_iops;
	  //  add the inode to the dentry object
	  d_add(dentry, file_inode);
  }
  else {
      return ERR_PTR(-ENOENT);
  }
  printk( "rkfs: inode_operations.lookup called with dentry %s. size = %d\n", dentry->d_name.name, file_size );
  return NULL;
}

/*
 * File Operations
 */

ssize_t rkfs_f_read( struct file *file, char *buf, size_t max, loff_t *offset ) {
    int i;
    int buflen;
    if(*offset > 0)
        return 0;
    printk( "rkfs: file_operations.read called %d %d\n", max, *offset );
    buflen = file_size > max ? max : file_size;
    __generic_copy_to_user(buf, file_buf, buflen);
    //           copy_to_user(buf, file_buf, buflen);
    *offset += buflen; // advance the offset
    return buflen;
}

ssize_t rkfs_f_write (struct file *file, const char *buf, size_t maxlen, loff_t *offset) {
    int count;
    if(*offset > 0) {
        printk("Positive offset %d\n", *offset);
        return 0;
    }
    count = maxlen > sizeof(file_buf) ? sizeof(file_buf) : maxlen;
    __generic_copy_from_user(file_buf, buf, count);
        //    copy_from_user(file_buf, buf, maxlen);
    printk( "file_operations.write called with maxlen=%d, off=%d\n", maxlen, *offset );
    *offset += count;
    if(*offset > file_size)
        file_size = *offset;
    return count;
}

/*
int rkfs_f_release (struct inode *ino, struct file *file) {
    printk( "rkfs: file_operations.release called\n" );
    return 0;
}
*/

int rkfs_f_readdir( struct file *file, void *dirent, filldir_t filldir ) {
    int err;
    struct dentry *de = file->f_dentry;

    printk( "rkfs: file_operations.readdir called\n" );
    if(file->f_pos > 0 )
        return 1;
    
    if(filldir(dirent, ".", 1, file->f_pos++, de->d_inode->i_ino, DT_DIR)||
       (filldir(dirent, "..", 2, file->f_pos++, de->d_parent->d_inode->i_ino, DT_DIR)))
        return 0;
    
    if(de->d_inode->i_ino == rkfs_root_inode->i_ino) // Estem a l'arrel 
    {
	struct cluster_t *llista;
	llista = (struct cluster_t *)kmalloc(sizeof(struct cluster_t) ,GFP_KERNEL);	
	llistar_clusters(llista);

    	printk( "rkfs: file_operations.readdir called caca\n" );
	while (llista != NULL) {	
		if(filldir(dirent, llista->nom, strlen(llista->nom), file->f_pos++, 3, DT_DIR ))
	         	return 0;
		llista = llista->next;
    	printk( "rkfs: file_operations.readdir called bucle\n" );
	} 
    printk( "rkfs: file_operations.readdir calledi final\n" );
		
    }
//	    if(filldir(dirent, "hello.txt", 9, file->f_pos++, FILE_INODE_NUMBER, DT_REG ))
	    
  //  if(filldir(dirent, "hello.txt", 9, file->f_pos++, FILE_INODE_NUMBER, DT_REG ))
    //    return 0;
    /* Mostrar subdirs */
//    if(filldir(dirent, "tonto", 5, file->f_pos++, 3, DT_DIR ))
//        return 0;
    
    
    return 1;
}

int init_module(void) {
    int err;
    err = register_filesystem( &rkfs );
    return err;
}

void cleanup_module(void) {
    unregister_filesystem( &rkfs );
}

MODULE_LICENSE("GPL");



From nobody at sheep.berlios.de  Fri Jun 11 04:48:50 2004
From: nobody at sheep.berlios.de (xscript)
Date: Fri, 11 Jun 2004 04:48:50 +0200
Subject: [Taca-cvs] code/backend Makefile,NONE,1.1 backend.h,NONE,1.1
Message-ID: <200406110248.i5B2moB18506@bat.berlios.de>

Update of /cvsroot/taca/code/backend
In directory sheep:/tmp/cvs-serv11627/code/backend

Added Files:
	Makefile backend.h 
Log Message:
Reorganization of code

--- NEW FILE: Makefile ---

%.o:
	make -C $* $@

clean:
	$(foreach dir,$(shell find . -type d -maxdepth 1 -mindepth 1 | grep -v CVS),make -C $(dir) clean)


--- NEW FILE: backend.h ---
struct cluster_t {

	char *nom;
	struct cluster_t *next;
};

struct node_t {

	char *nom;
	struct node_t *next;
};

struct proces_t {
	
	char *nom;
	struct proces_t *next;
};



int llistar_clusters (struct cluster_t *llista);

int llistar_nodes (struct cluster_t *cluster_id, struct node_t *llista);

int liistar_procs (struct node_t *node_id, struct proces_t *lista);



int migrar (struct proces_t  *proces, struct node_t *node_desti);

/* El node pot rebre procs. nous ? */
int node_bloquejat_rebre (struct node_t *node);

/* El node pot enviar procs. nous ? */
int node_bloquejat_enviar (struct node_t *node);

/* El proces no es pot migrar */
int proces_bloquejat (struct proces_t *proc);




From nobody at sheep.berlios.de  Fri Jun 11 04:49:00 2004
From: nobody at sheep.berlios.de (xscript)
Date: Fri, 11 Jun 2004 04:49:00 +0200
Subject: [Taca-cvs] code/backend/openmosix Makefile,NONE,1.1 openmosix.c,NONE,1.1
Message-ID: <200406110249.i5B2n0B18521@bat.berlios.de>

Update of /cvsroot/taca/code/backend/openmosix
In directory sheep:/tmp/cvs-serv11627/code/backend/openmosix

Added Files:
	Makefile openmosix.c 
Log Message:
Reorganization of code

--- NEW FILE: Makefile ---

CFLAGS += $(OPENMOSIX_CFLAGS)

TARGET = openmosix.o
#OBJS   = a.c b.c

all: $(TARGET)
	cp $(TARGET) $(TOPDIR)/backend.o

#$(TARGET): $(OBJS)

clean:
	rm -f $(TARGET)


--- NEW FILE: openmosix.c ---
#include "backend.h"
#include <linux/mm.h>


//struct cluster_t clus = {.nom = "123",
//			 .next = NULL};

struct node_t n3 = {	.nom = "n3",
			.next = NULL};
struct node_t n2 = {	.nom = "n2",
			.next = &n3 };
struct node_t n1 = {	.nom = "n1",
			.next = &n2};

struct proces_t p3 = {	.nom = "proc3",
			.next = NULL};

struct proces_t p2 = {	.nom = "proc2",
			.next = &p3};
struct proces_t p1 = {	.nom = "proc1",
			.next = &p2};

int llistar_clusters (struct cluster_t *llista)
{
	//llista = (struct cluster_t *)kmalloc(sizeof(struct cluster_t) ,GFP_KERNEL);	
	llista->nom = "c1" ;
	llista->next = NULL;
	return 0;
}

int llistar_nodes (struct cluster_t *cluster_id, struct node_t *llista)
{
	//llista[0] = &n1;
	//llista[1] = &n2;
	//llista[2] = &n3;
	
}

int liistar_procs (struct node_t *node_id, struct proces_t *llista)
{
	//llista[0] = &p1;
	//llista[1] = &p2;
	//llista[2] = &p3;
}


//int migrar (struct proces_t  *proces, struct node_t *node_desti);

/* El node pot rebre procs. nous ? */
//int node_bloquejat_rebre (struct node_t *node);

/* El node pot enviar procs. nous ? */
//int node_bloquejat_enviar (struct node_t *node);

/* El proces no es pot migrar */
//int proces_bloquejat (struct proces_t *proc);




From nobody at sheep.berlios.de  Fri Jun 11 05:10:36 2004
From: nobody at sheep.berlios.de (xscript)
Date: Fri, 11 Jun 2004 05:10:36 +0200
Subject: [Taca-cvs] code Makefile,1.1,1.2
Message-ID: <200406110310.i5B3AaB18876@bat.berlios.de>

Update of /cvsroot/taca/code
In directory sheep:/tmp/cvs-serv12499

Modified Files:
	Makefile 
Log Message:
Minor fixes

Index: Makefile
===================================================================
RCS file: /cvsroot/taca/code/Makefile,v
retrieving revision 1.1
retrieving revision 1.2
diff -C2 -d -r1.1 -r1.2
*** Makefile	11 Jun 2004 02:48:47 -0000	1.1
--- Makefile	11 Jun 2004 03:10:33 -0000	1.2
***************
*** 14,25 ****
  export CFLAGS TOPDIR # LDFLAGS
  
! all: $(TARGET)
! 
! $(TARGET):
  	make -C frontend $(FRONTEND)
  	make -C backend $(BACKEND)
  	$(LD) -r -o $(TARGET) frontend.o backend.o
  
! re-$(TARGET): clean $(TARGET)
  
  run: $(TARGET)
--- 14,23 ----
  export CFLAGS TOPDIR # LDFLAGS
  
! all:
  	make -C frontend $(FRONTEND)
  	make -C backend $(BACKEND)
  	$(LD) -r -o $(TARGET) frontend.o backend.o
  
! re-all: clean all
  
  run: $(TARGET)



From nobody at sheep.berlios.de  Fri Jun 11 05:10:36 2004
From: nobody at sheep.berlios.de (xscript)
Date: Fri, 11 Jun 2004 05:10:36 +0200
Subject: [Taca-cvs] code/backend Makefile,1.1,1.2
Message-ID: <200406110310.i5B3AaB18879@bat.berlios.de>

Update of /cvsroot/taca/code/backend
In directory sheep:/tmp/cvs-serv12499/backend

Modified Files:
	Makefile 
Log Message:
Minor fixes

Index: Makefile
===================================================================
RCS file: /cvsroot/taca/code/backend/Makefile,v
retrieving revision 1.1
retrieving revision 1.2
diff -C2 -d -r1.1 -r1.2
*** Makefile	11 Jun 2004 02:48:47 -0000	1.1
--- Makefile	11 Jun 2004 03:10:34 -0000	1.2
***************
*** 1,5 ****
  
  %.o:
! 	make -C $* $@
  
  clean:
--- 1,5 ----
  
  %.o:
! 	make -C $* all
  
  clean:



From nobody at sheep.berlios.de  Fri Jun 11 05:10:36 2004
From: nobody at sheep.berlios.de (xscript)
Date: Fri, 11 Jun 2004 05:10:36 +0200
Subject: [Taca-cvs] code/backend/openmosix openmosix.c,1.1,1.2
Message-ID: <200406110310.i5B3AaB18882@bat.berlios.de>

Update of /cvsroot/taca/code/backend/openmosix
In directory sheep:/tmp/cvs-serv12499/backend/openmosix

Modified Files:
	openmosix.c 
Log Message:
Minor fixes

Index: openmosix.c
===================================================================
RCS file: /cvsroot/taca/code/backend/openmosix/openmosix.c,v
retrieving revision 1.1
retrieving revision 1.2
diff -C2 -d -r1.1 -r1.2
*** openmosix.c	11 Jun 2004 02:48:48 -0000	1.1
--- openmosix.c	11 Jun 2004 03:10:34 -0000	1.2
***************
*** 34,38 ****
  	//llista[1] = &n2;
  	//llista[2] = &n3;
! 	
  }
  
--- 34,38 ----
  	//llista[1] = &n2;
  	//llista[2] = &n3;
! 	return 0;
  }
  
***************
*** 42,45 ****
--- 42,46 ----
  	//llista[1] = &p2;
  	//llista[2] = &p3;
+ 	return 0;
  }
  



From nobody at sheep.berlios.de  Fri Jun 11 17:43:15 2004
From: nobody at sheep.berlios.de (xscript)
Date: Fri, 11 Jun 2004 17:43:15 +0200
Subject: [Taca-cvs] codi generic.h,1.1,1.2 mosix.c,1.1,1.2 rkfs.c,1.1,1.2
Message-ID: <200406111543.i5BFhFB06287@bat.berlios.de>

Update of /cvsroot/taca/codi
In directory sheep:/tmp/cvs-serv14988

Modified Files:
	generic.h mosix.c rkfs.c 
Log Message:
Ja funciona el nostre sistema de fitxers!!!!!!!!!

ole!!!!



Index: generic.h
===================================================================
RCS file: /cvsroot/taca/codi/generic.h,v
retrieving revision 1.1
retrieving revision 1.2
diff -C2 -d -r1.1 -r1.2
*** generic.h	10 Jun 2004 17:49:41 -0000	1.1
--- generic.h	11 Jun 2004 15:43:12 -0000	1.2
***************
*** 18,27 ****
  
  
! 
  int llistar_clusters (struct cluster_t *llista);
  
  int llistar_nodes (struct cluster_t *cluster_id, struct node_t *llista);
  
! int liistar_procs (struct node_t *node_id, struct proces_t *lista);
  
  
--- 18,29 ----
  
  
! int num_clusters();
  int llistar_clusters (struct cluster_t *llista);
  
+ int num_nodes(struct cluster_t *cluster_id);
  int llistar_nodes (struct cluster_t *cluster_id, struct node_t *llista);
  
! int num_procs(struct cluster_t *cluster_id, struct node_t *node_id);
! int liistar_procs (struct cluster_t *cluster_id, struct node_t *node_id, struct proces_t *lista);
  
  

Index: mosix.c
===================================================================
RCS file: /cvsroot/taca/codi/mosix.c,v
retrieving revision 1.1
retrieving revision 1.2
diff -C2 -d -r1.1 -r1.2
*** mosix.c	10 Jun 2004 17:49:41 -0000	1.1
--- mosix.c	11 Jun 2004 15:43:12 -0000	1.2
***************
*** 1,2 ****
--- 1,3 ----
+ 
  #include "generic.h"
  #include <linux/mm.h>
***************
*** 5,9 ****
  //struct cluster_t clus = {.nom = "123",
  //			 .next = NULL};
! 
  struct node_t n3 = {	.nom = "n3",
  			.next = NULL};
--- 6,10 ----
  //struct cluster_t clus = {.nom = "123",
  //			 .next = NULL};
! /*
  struct node_t n3 = {	.nom = "n3",
  			.next = NULL};
***************
*** 21,24 ****
--- 22,31 ----
  			.next = &p2};
  
+ */			
+ int num_clusters() 
+ {
+ 	return 1;
+ }
+ 
  int llistar_clusters (struct cluster_t *llista)
  {
***************
*** 29,45 ****
  }
  
  int llistar_nodes (struct cluster_t *cluster_id, struct node_t *llista)
  {
! 	//llista[0] = &n1;
! 	//llista[1] = &n2;
! 	//llista[2] = &n3;
! 	
  }
  
! int liistar_procs (struct node_t *node_id, struct proces_t *llista)
  {
! 	//llista[0] = &p1;
! 	//llista[1] = &p2;
! 	//llista[2] = &p3;
  }
  
--- 36,71 ----
  }
  
+ int num_nodes (struct cluster_t *cluster_id)
+ {
+ 	return 3;
+ }
+ 
  int llistar_nodes (struct cluster_t *cluster_id, struct node_t *llista)
  {
! 	llista[0].nom = "n0";
! 	llista[0].next = &llista[1];
! 	llista[1].nom = "n1";
! 	llista[1].next = &llista[2];
! 	llista[2].nom = "n2";
! 	llista[2].next = NULL;
! 
! 	return 0;
  }
  
! int num_procs (struct cluster_t *cluster_id, struct node_t *node_id) 
  {
! 	return 3;
! }
! 
! int llistar_procs (struct cluster_t *cluster_id, struct node_t *node_id, struct proces_t *llista)
! {
! 	llista[0].nom = "p0";
! 	llista[0].next = &llista[1];
! 	llista[1].nom = "p1";
! 	llista[1].next = &llista[2];
! 	llista[2].nom = "p2";
! 	llista[2].next = NULL;
! 
! 	return 0;
  }
  

Index: rkfs.c
===================================================================
RCS file: /cvsroot/taca/codi/rkfs.c,v
retrieving revision 1.1
retrieving revision 1.2
diff -C2 -d -r1.1 -r1.2
*** rkfs.c	10 Jun 2004 17:49:41 -0000	1.1
--- rkfs.c	11 Jun 2004 15:43:12 -0000	1.2
***************
*** 26,29 ****
--- 26,30 ----
  #define RKFS_MAGIC 0xabcd
  #define FILE_INODE_NUMBER 2
+ #define DIR_INODE_NUMBER 3
  
  static struct super_block *rkfs_read_super(struct super_block *, void *, int);
***************
*** 125,156 ****
   */
  
  struct dentry *rkfs_i_lookup( struct inode *parent_inode, struct dentry *dentry ) {
    struct inode *file_inode;
! 
!   if( parent_inode->i_ino == rkfs_root_inode->i_ino && strlen("hello.txt") == dentry->d_name.len && !strcmp(dentry->d_name.name, "hello.txt")) {
  	  // allocate an inode object
! 	  if(!(file_inode = iget( parent_inode->i_sb, FILE_INODE_NUMBER )))
  		  return ERR_PTR(-ENOMEM);
! 	  file_inode->i_size = file_size;
! 	  file_inode->i_mode = S_IFREG|S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH;
! 	  file_inode->i_fop = &rkfs_file_fops;
  	  //  add the inode to the dentry object
  	  d_add(dentry, file_inode);
    }
!   if( parent_inode->i_ino == rkfs_root_inode->i_ino && strlen("tonto") == dentry->d_name.len && !strcmp(dentry->d_name.name, "tonto")) {
! 	  // allocate an inode object
! 	  if(!(file_inode = iget( parent_inode->i_sb, 3)))
  		  return ERR_PTR(-ENOMEM);
- 	  //file_inode->i_size = file_size;
  	  file_inode->i_mode = S_IFDIR|S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH;
! 	  file_inode->i_fop = &rkfs_file_fops;
  	  file_inode->i_op = &rkfs_iops;
! 	  //  add the inode to the dentry object
  	  d_add(dentry, file_inode);
    }
    else {
        return ERR_PTR(-ENOENT);
    }
!   printk( "rkfs: inode_operations.lookup called with dentry %s. size = %d\n", dentry->d_name.name, file_size );
    return NULL;
  }
--- 126,198 ----
   */
  
+ /* Aquesta funcio genera el inode pel dentry que es vol mirar 
+  * El inode que es vol generar ?s "fill" del parent_inode
+  *
+  *
+  * TODO: comprovar que el directori on es vol entrar ?s correcte
+  */
+ 
  struct dentry *rkfs_i_lookup( struct inode *parent_inode, struct dentry *dentry ) {
    struct inode *file_inode;
!   
!   printk( "rkfs: inode_operations.lookup called with dentry %s. size = %d\n", dentry->d_name.name, file_size );
!   
!   /* Hem de generar el inode per mostrar un clusters (el dentry) 
!    * Per tant un directori
!    * */
!   if( parent_inode->i_ino == rkfs_root_inode->i_ino) {
! 	  
  	  // allocate an inode object
! 	  if(!(file_inode = iget( parent_inode->i_sb, DIR_INODE_NUMBER)))
  		  return ERR_PTR(-ENOMEM);
! 	  //file_inode->i_size = file_size;
! 	  file_inode->i_mode = S_IFDIR|S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH;
! 	  file_inode->i_fop = &rkfs_dir_fops;
! 	  file_inode->i_op = &rkfs_iops;
  	  //  add the inode to the dentry object
  	  d_add(dentry, file_inode);
+ 	  
+ 	  printk(" lookup: inode per cluster %s generat\n", dentry->d_name.name);
    }
! 
!   /* hem de generar el inode per mostrar el node */	
!   else if( dentry->d_parent->d_parent->d_inode->i_ino == rkfs_root_inode->i_ino) {
! 
! 
! 	  //allocate an inode object
! 	  if(!(file_inode = iget( parent_inode->i_sb, DIR_INODE_NUMBER)))
  		  return ERR_PTR(-ENOMEM);
  	  file_inode->i_mode = S_IFDIR|S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH;
! 	  file_inode->i_fop = &rkfs_dir_fops;
  	  file_inode->i_op = &rkfs_iops;
! 	  //add the inode to the dentry object
  	  d_add(dentry, file_inode);
+ 
+ 	  printk(" lookup: inode per node %s generat\n", dentry->d_name.name);
+ 
+ 
    }
+ 	  
+   // Hem de generar l'inode per mostrar el proces
+   else if( dentry->d_parent->d_parent->d_parent->d_inode->i_ino == rkfs_root_inode->i_ino) {
+ 
+ 	  //allocate an inode object
+ 	  if(!(file_inode = iget( parent_inode->i_sb, FILE_INODE_NUMBER)))
+ 			  return ERR_PTR(-ENOMEM);
+ 	  file_inode->i_size = file_size;
+ 	  file_inode->i_mode = S_IFREG|S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH;
+ 	  file_inode->i_fop = &rkfs_file_fops;
+ 	  //add the inode to the dentry object
+ 	  d_add(dentry, file_inode);
+ 
+ 	  printk(" lookup: inode per process %s generat\n", dentry->d_name.name);
+ 
+ 
+   }
+   
    else {
        return ERR_PTR(-ENOENT);
    }
!   
    return NULL;
  }
***************
*** 211,235 ****
      {
  	struct cluster_t *llista;
! 	llista = (struct cluster_t *)kmalloc(sizeof(struct cluster_t) ,GFP_KERNEL);	
  	llistar_clusters(llista);
  
!     	printk( "rkfs: file_operations.readdir called caca\n" );
  	while (llista != NULL) {	
! 		if(filldir(dirent, llista->nom, strlen(llista->nom), file->f_pos++, 3, DT_DIR ))
  	         	return 0;
  		llista = llista->next;
-     	printk( "rkfs: file_operations.readdir called bucle\n" );
  	} 
!     printk( "rkfs: file_operations.readdir calledi final\n" );
  		
      }
- //	    if(filldir(dirent, "hello.txt", 9, file->f_pos++, FILE_INODE_NUMBER, DT_REG ))
- 	    
-   //  if(filldir(dirent, "hello.txt", 9, file->f_pos++, FILE_INODE_NUMBER, DT_REG ))
-     //    return 0;
-     /* Mostrar subdirs */
- //    if(filldir(dirent, "tonto", 5, file->f_pos++, 3, DT_DIR ))
- //        return 0;
      
      
      return 1;
--- 253,375 ----
      {
  	struct cluster_t *llista;
! 	int num;
! 	
! 	num = num_clusters();
! 	llista = (struct cluster_t *)kmalloc(sizeof(struct cluster_t)*num ,GFP_KERNEL);	
  	llistar_clusters(llista);
  
!     	printk( " readdir: Creant clusters\n" );
  	while (llista != NULL) {	
! 		if(filldir(dirent, llista->nom, strlen(llista->nom), file->f_pos++, DIR_INODE_NUMBER, DT_DIR ))
  	         	return 0;
  		llista = llista->next;
  	} 
! 	printk(" readdir: Directoris per clusters creats\n");
! 	kfree(llista);
  		
      }
      
+     
+     else if(de->d_parent->d_inode->i_ino == rkfs_root_inode->i_ino) // Estem a un cluster 
+     {
+ 	struct cluster_t *llista;
+ 	struct node_t *llista1;
+ 	int num;
+ 	int i=0;
+ 	
+ 	printk(" readdir: Llistant nodes del cluster %s\n", de->d_name.name);
+ 
+ 	
+ 	// Obtenim tots els clusters i busquem en quin estem
+ 	num = num_clusters();
+ 	llista = (struct cluster_t *)kmalloc(sizeof(struct cluster_t)*num ,GFP_KERNEL);	
+ 	llistar_clusters(llista);
+ 	
+ 	while (llista != NULL && i==0) {	
+ 		
+ 		printk(" readdir: Busquem el cluster\n");
+ 		
+ 		if (!strcmp(de->d_name.name, llista->nom)) i=1;
+ 		else llista = llista->next;
+ 	} 
+ 
+ 	// Llistem tots els nodes del cluster
+ 	num = num_nodes(llista);	
+ 	llista1 = (struct node_t *)kmalloc(sizeof(struct node_t)*num ,GFP_KERNEL);
+ 	llistar_nodes(llista,llista1);
+ 
+ 	while (llista1 != NULL) {
+ 		
+ 		printk(" readdir: Creem els directoris pels nodes\n");
+ 		
+ 		if(filldir(dirent, llista1->nom, strlen(llista1->nom), file->f_pos++, DIR_INODE_NUMBER, DT_DIR ))
+ 			return 0;
+ 		llista1 = llista1->next;
+ 	}
+     	
+ 	printk(" readdir: Directoris per nodes creats\n");
+     	
+ 	
+ 	kfree(llista);
+ 	kfree(llista1);
+ 	}
+     
+     else if(de->d_parent->d_parent->d_inode->i_ino == rkfs_root_inode->i_ino) // Estem a un node 
+     {
+ 	struct cluster_t *llista;
+ 	struct node_t *llista1;
+ 	struct proces_t *llista2;
+ 	int num;
+ 	int i=0;
+ 	
+ 	printk(" readdir: Llistant procs del node %s\n", de->d_name.name);
+ 
+ 	
+ 	// Obtenim tots els clusters i busquem en quin estem
+ 	num = num_clusters();
+ 	llista = (struct cluster_t *)kmalloc(sizeof(struct cluster_t)*num ,GFP_KERNEL);	
+ 	llistar_clusters(llista);
+ 	
+ 	while (llista != NULL && i==0) {	
+ 		
+ 		printk(" readdir: Busquem el cluster\n");
+ 		
+ 		if (!strcmp(de->d_parent->d_name.name, llista->nom)) i=1;
+ 		else llista = llista->next;
+ 	} 
+ 
+ 	// Obtenim  tots els nodes del cluster i busquem en quin estem
+ 	i = 0; 
+ 	num = num_nodes(llista);	
+ 	llista1 = (struct node_t *)kmalloc(sizeof(struct node_t)*num ,GFP_KERNEL);
+ 	llistar_nodes(llista,llista1);
+ 
+ 	while (llista1 != NULL && i==0) {
+ 		
+ 		printk(" readdir: Busquem el node\n");
+ 		
+ 		if (!strcmp(de->d_name.name, llista1->nom)) i=1;
+ 		else llista1 = llista1->next;
+ 	}
+     	
+ 	
+ 	// LListem els processos del cluster
+ 	num = num_procs(llista,llista1);	
+ 	llista2 = (struct proces_t *)kmalloc(sizeof(struct proces_t)*num ,GFP_KERNEL);
+ 	llistar_procs(llista,llista1,llista2);
+ 
+ 	while (llista2 != NULL) {
+ 		if(filldir(dirent, llista2->nom, strlen(llista2->nom), file->f_pos++, FILE_INODE_NUMBER, DT_REG ))
+ 			return 0;
+ 		llista2 = llista2->next;
+ 	}
+ 	
+ 	printk(" readdir: Fitxers per processos creats\n");
+     	
+ 	
+ 	kfree(llista);
+ 	kfree(llista1);
+ 	kfree(llista2);	
+     }
      
      return 1;



From nobody at sheep.berlios.de  Fri Jun 11 22:05:44 2004
From: nobody at sheep.berlios.de (xscript)
Date: Fri, 11 Jun 2004 22:05:44 +0200
Subject: [Taca-cvs] code/frontend/linux linux.c,1.1,1.2
Message-ID: <200406112005.i5BK5iB12670@bat.berlios.de>

Update of /cvsroot/taca/code/frontend/linux
In directory sheep:/tmp/cvs-serv20677

Modified Files:
	linux.c 
Log Message:
Backport del curro d'avui al directori 'code'

Index: linux.c
===================================================================
RCS file: /cvsroot/taca/code/frontend/linux/linux.c,v
retrieving revision 1.1
retrieving revision 1.2
diff -C2 -d -r1.1 -r1.2
*** linux.c	11 Jun 2004 02:48:48 -0000	1.1
--- linux.c	11 Jun 2004 20:05:41 -0000	1.2
***************
*** 26,29 ****
--- 26,30 ----
  #define RKFS_MAGIC 0xabcd
  #define FILE_INODE_NUMBER 2
+ #define DIR_INODE_NUMBER 3
  
  static struct super_block *rkfs_read_super(struct super_block *, void *, int);
***************
*** 125,156 ****
   */
  
  struct dentry *rkfs_i_lookup( struct inode *parent_inode, struct dentry *dentry ) {
    struct inode *file_inode;
! 
!   if( parent_inode->i_ino == rkfs_root_inode->i_ino && strlen("hello.txt") == dentry->d_name.len && !strcmp(dentry->d_name.name, "hello.txt")) {
  	  // allocate an inode object
! 	  if(!(file_inode = iget( parent_inode->i_sb, FILE_INODE_NUMBER )))
  		  return ERR_PTR(-ENOMEM);
! 	  file_inode->i_size = file_size;
! 	  file_inode->i_mode = S_IFREG|S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH;
! 	  file_inode->i_fop = &rkfs_file_fops;
  	  //  add the inode to the dentry object
  	  d_add(dentry, file_inode);
    }
!   if( parent_inode->i_ino == rkfs_root_inode->i_ino && strlen("tonto") == dentry->d_name.len && !strcmp(dentry->d_name.name, "tonto")) {
! 	  // allocate an inode object
! 	  if(!(file_inode = iget( parent_inode->i_sb, 3)))
  		  return ERR_PTR(-ENOMEM);
- 	  //file_inode->i_size = file_size;
  	  file_inode->i_mode = S_IFDIR|S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH;
! 	  file_inode->i_fop = &rkfs_file_fops;
  	  file_inode->i_op = &rkfs_iops;
! 	  //  add the inode to the dentry object
  	  d_add(dentry, file_inode);
    }
    else {
        return ERR_PTR(-ENOENT);
    }
!   printk( "rkfs: inode_operations.lookup called with dentry %s. size = %d\n", dentry->d_name.name, file_size );
    return NULL;
  }
--- 126,198 ----
   */
  
+ /* Aquesta funcio genera el inode pel dentry que es vol mirar 
+  * El inode que es vol generar ?s "fill" del parent_inode
+  *
+  *
+  * TODO: comprovar que el directori on es vol entrar ?s correcte
+  */
+ 
  struct dentry *rkfs_i_lookup( struct inode *parent_inode, struct dentry *dentry ) {
    struct inode *file_inode;
!   
!   printk( "rkfs: inode_operations.lookup called with dentry %s. size = %d\n", dentry->d_name.name, file_size );
!   
!   /* Hem de generar el inode per mostrar un clusters (el dentry) 
!    * Per tant un directori
!    * */
!   if( parent_inode->i_ino == rkfs_root_inode->i_ino) {
! 	  
  	  // allocate an inode object
! 	  if(!(file_inode = iget( parent_inode->i_sb, DIR_INODE_NUMBER)))
  		  return ERR_PTR(-ENOMEM);
! 	  //file_inode->i_size = file_size;
! 	  file_inode->i_mode = S_IFDIR|S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH;
! 	  file_inode->i_fop = &rkfs_dir_fops;
! 	  file_inode->i_op = &rkfs_iops;
  	  //  add the inode to the dentry object
  	  d_add(dentry, file_inode);
+ 	  
+ 	  printk(" lookup: inode per cluster %s generat\n", dentry->d_name.name);
    }
! 
!   /* hem de generar el inode per mostrar el node */	
!   else if( dentry->d_parent->d_parent->d_inode->i_ino == rkfs_root_inode->i_ino) {
! 
! 
! 	  //allocate an inode object
! 	  if(!(file_inode = iget( parent_inode->i_sb, DIR_INODE_NUMBER)))
  		  return ERR_PTR(-ENOMEM);
  	  file_inode->i_mode = S_IFDIR|S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH;
! 	  file_inode->i_fop = &rkfs_dir_fops;
  	  file_inode->i_op = &rkfs_iops;
! 	  //add the inode to the dentry object
  	  d_add(dentry, file_inode);
+ 
+ 	  printk(" lookup: inode per node %s generat\n", dentry->d_name.name);
+ 
+ 
    }
+ 	  
+   // Hem de generar l'inode per mostrar el proces
+   else if( dentry->d_parent->d_parent->d_parent->d_inode->i_ino == rkfs_root_inode->i_ino) {
+ 
+ 	  //allocate an inode object
+ 	  if(!(file_inode = iget( parent_inode->i_sb, FILE_INODE_NUMBER)))
+ 			  return ERR_PTR(-ENOMEM);
+ 	  file_inode->i_size = file_size;
+ 	  file_inode->i_mode = S_IFREG|S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH;
+ 	  file_inode->i_fop = &rkfs_file_fops;
+ 	  //add the inode to the dentry object
+ 	  d_add(dentry, file_inode);
+ 
+ 	  printk(" lookup: inode per process %s generat\n", dentry->d_name.name);
+ 
+ 
+   }
+   
    else {
        return ERR_PTR(-ENOENT);
    }
!   
    return NULL;
  }
***************
*** 211,235 ****
      {
  	struct cluster_t *llista;
! 	llista = (struct cluster_t *)kmalloc(sizeof(struct cluster_t) ,GFP_KERNEL);	
  	llistar_clusters(llista);
  
!     	printk( "rkfs: file_operations.readdir called caca\n" );
  	while (llista != NULL) {	
! 		if(filldir(dirent, llista->nom, strlen(llista->nom), file->f_pos++, 3, DT_DIR ))
  	         	return 0;
  		llista = llista->next;
-     	printk( "rkfs: file_operations.readdir called bucle\n" );
  	} 
!     printk( "rkfs: file_operations.readdir calledi final\n" );
  		
      }
- //	    if(filldir(dirent, "hello.txt", 9, file->f_pos++, FILE_INODE_NUMBER, DT_REG ))
- 	    
-   //  if(filldir(dirent, "hello.txt", 9, file->f_pos++, FILE_INODE_NUMBER, DT_REG ))
-     //    return 0;
-     /* Mostrar subdirs */
- //    if(filldir(dirent, "tonto", 5, file->f_pos++, 3, DT_DIR ))
- //        return 0;
      
      
      return 1;
--- 253,375 ----
      {
  	struct cluster_t *llista;
! 	int num;
! 	
! 	num = num_clusters();
! 	llista = (struct cluster_t *)kmalloc(sizeof(struct cluster_t)*num ,GFP_KERNEL);	
  	llistar_clusters(llista);
  
!     	printk( " readdir: Creant clusters\n" );
  	while (llista != NULL) {	
! 		if(filldir(dirent, llista->nom, strlen(llista->nom), file->f_pos++, DIR_INODE_NUMBER, DT_DIR ))
  	         	return 0;
  		llista = llista->next;
  	} 
! 	printk(" readdir: Directoris per clusters creats\n");
! 	kfree(llista);
  		
      }
      
+     
+     else if(de->d_parent->d_inode->i_ino == rkfs_root_inode->i_ino) // Estem a un cluster 
+     {
+ 	struct cluster_t *llista;
+ 	struct node_t *llista1;
+ 	int num;
+ 	int i=0;
+ 	
+ 	printk(" readdir: Llistant nodes del cluster %s\n", de->d_name.name);
+ 
+ 	
+ 	// Obtenim tots els clusters i busquem en quin estem
+ 	num = num_clusters();
+ 	llista = (struct cluster_t *)kmalloc(sizeof(struct cluster_t)*num ,GFP_KERNEL);	
+ 	llistar_clusters(llista);
+ 	
+ 	while (llista != NULL && i==0) {	
+ 		
+ 		printk(" readdir: Busquem el cluster\n");
+ 		
+ 		if (!strcmp(de->d_name.name, llista->nom)) i=1;
+ 		else llista = llista->next;
+ 	} 
+ 
+ 	// Llistem tots els nodes del cluster
+ 	num = num_nodes(llista);	
+ 	llista1 = (struct node_t *)kmalloc(sizeof(struct node_t)*num ,GFP_KERNEL);
+ 	llistar_nodes(llista,llista1);
+ 
+ 	while (llista1 != NULL) {
+ 		
+ 		printk(" readdir: Creem els directoris pels nodes\n");
+ 		
+ 		if(filldir(dirent, llista1->nom, strlen(llista1->nom), file->f_pos++, DIR_INODE_NUMBER, DT_DIR ))
+ 			return 0;
+ 		llista1 = llista1->next;
+ 	}
+     	
+ 	printk(" readdir: Directoris per nodes creats\n");
+     	
+ 	
+ 	kfree(llista);
+ 	kfree(llista1);
+ 	}
+     
+     else if(de->d_parent->d_parent->d_inode->i_ino == rkfs_root_inode->i_ino) // Estem a un node 
+     {
+ 	struct cluster_t *llista;
+ 	struct node_t *llista1;
+ 	struct proces_t *llista2;
+ 	int num;
+ 	int i=0;
+ 	
+ 	printk(" readdir: Llistant procs del node %s\n", de->d_name.name);
+ 
+ 	
+ 	// Obtenim tots els clusters i busquem en quin estem
+ 	num = num_clusters();
+ 	llista = (struct cluster_t *)kmalloc(sizeof(struct cluster_t)*num ,GFP_KERNEL);	
+ 	llistar_clusters(llista);
+ 	
+ 	while (llista != NULL && i==0) {	
+ 		
+ 		printk(" readdir: Busquem el cluster\n");
+ 		
+ 		if (!strcmp(de->d_parent->d_name.name, llista->nom)) i=1;
+ 		else llista = llista->next;
+ 	} 
+ 
+ 	// Obtenim  tots els nodes del cluster i busquem en quin estem
+ 	i = 0; 
+ 	num = num_nodes(llista);	
+ 	llista1 = (struct node_t *)kmalloc(sizeof(struct node_t)*num ,GFP_KERNEL);
+ 	llistar_nodes(llista,llista1);
+ 
+ 	while (llista1 != NULL && i==0) {
+ 		
+ 		printk(" readdir: Busquem el node\n");
+ 		
+ 		if (!strcmp(de->d_name.name, llista1->nom)) i=1;
+ 		else llista1 = llista1->next;
+ 	}
+     	
+ 	
+ 	// LListem els processos del cluster
+ 	num = num_procs(llista,llista1);	
+ 	llista2 = (struct proces_t *)kmalloc(sizeof(struct proces_t)*num ,GFP_KERNEL);
+ 	llistar_procs(llista,llista1,llista2);
+ 
+ 	while (llista2 != NULL) {
+ 		if(filldir(dirent, llista2->nom, strlen(llista2->nom), file->f_pos++, FILE_INODE_NUMBER, DT_REG ))
+ 			return 0;
+ 		llista2 = llista2->next;
+ 	}
+ 	
+ 	printk(" readdir: Fitxers per processos creats\n");
+     	
+ 	
+ 	kfree(llista);
+ 	kfree(llista1);
+ 	kfree(llista2);	
+     }
      
      return 1;



From nobody at sheep.berlios.de  Fri Jun 11 22:07:37 2004
From: nobody at sheep.berlios.de (xscript)
Date: Fri, 11 Jun 2004 22:07:37 +0200
Subject: [Taca-cvs] code/backend backend.h,1.1,1.2
Message-ID: <200406112007.i5BK7bB12712@bat.berlios.de>

Update of /cvsroot/taca/code/backend
In directory sheep:/tmp/cvs-serv20896/backend

Modified Files:
	backend.h 
Log Message:
Backport del curro d'avui al directori 'code'

Index: backend.h
===================================================================
RCS file: /cvsroot/taca/code/backend/backend.h,v
retrieving revision 1.1
retrieving revision 1.2
diff -C2 -d -r1.1 -r1.2
*** backend.h	11 Jun 2004 02:48:47 -0000	1.1
--- backend.h	11 Jun 2004 20:07:34 -0000	1.2
***************
*** 18,27 ****
  
  
! 
  int llistar_clusters (struct cluster_t *llista);
  
  int llistar_nodes (struct cluster_t *cluster_id, struct node_t *llista);
  
! int liistar_procs (struct node_t *node_id, struct proces_t *lista);
  
  
--- 18,29 ----
  
  
! int num_clusters();
  int llistar_clusters (struct cluster_t *llista);
  
+ int num_nodes(struct cluster_t *cluster_id);
  int llistar_nodes (struct cluster_t *cluster_id, struct node_t *llista);
  
! int num_procs(struct cluster_t *cluster_id, struct node_t *node_id);
! int llistar_procs (struct cluster_t *cluster_id, struct node_t *node_id, struct proces_t *lista);
  
  



From nobody at sheep.berlios.de  Fri Jun 11 22:07:37 2004
From: nobody at sheep.berlios.de (xscript)
Date: Fri, 11 Jun 2004 22:07:37 +0200
Subject: [Taca-cvs] code/backend/openmosix openmosix.c,1.2,1.3
Message-ID: <200406112007.i5BK7bB12715@bat.berlios.de>

Update of /cvsroot/taca/code/backend/openmosix
In directory sheep:/tmp/cvs-serv20896/backend/openmosix

Modified Files:
	openmosix.c 
Log Message:
Backport del curro d'avui al directori 'code'

Index: openmosix.c
===================================================================
RCS file: /cvsroot/taca/code/backend/openmosix/openmosix.c,v
retrieving revision 1.2
retrieving revision 1.3
diff -C2 -d -r1.2 -r1.3
*** openmosix.c	11 Jun 2004 03:10:34 -0000	1.2
--- openmosix.c	11 Jun 2004 20:07:35 -0000	1.3
***************
*** 1,2 ****
--- 1,3 ----
+ 
  #include "backend.h"
  #include <linux/mm.h>
***************
*** 5,9 ****
  //struct cluster_t clus = {.nom = "123",
  //			 .next = NULL};
! 
  struct node_t n3 = {	.nom = "n3",
  			.next = NULL};
--- 6,10 ----
  //struct cluster_t clus = {.nom = "123",
  //			 .next = NULL};
! /*
  struct node_t n3 = {	.nom = "n3",
  			.next = NULL};
***************
*** 21,24 ****
--- 22,31 ----
  			.next = &p2};
  
+ */			
+ int num_clusters() 
+ {
+ 	return 1;
+ }
+ 
  int llistar_clusters (struct cluster_t *llista)
  {
***************
*** 29,45 ****
  }
  
  int llistar_nodes (struct cluster_t *cluster_id, struct node_t *llista)
  {
! 	//llista[0] = &n1;
! 	//llista[1] = &n2;
! 	//llista[2] = &n3;
  	return 0;
  }
  
! int liistar_procs (struct node_t *node_id, struct proces_t *llista)
  {
! 	//llista[0] = &p1;
! 	//llista[1] = &p2;
! 	//llista[2] = &p3;
  	return 0;
  }
--- 36,70 ----
  }
  
+ int num_nodes (struct cluster_t *cluster_id)
+ {
+ 	return 3;
+ }
+ 
  int llistar_nodes (struct cluster_t *cluster_id, struct node_t *llista)
  {
! 	llista[0].nom = "n0";
! 	llista[0].next = &llista[1];
! 	llista[1].nom = "n1";
! 	llista[1].next = &llista[2];
! 	llista[2].nom = "n2";
! 	llista[2].next = NULL;
! 
  	return 0;
  }
  
! int num_procs (struct cluster_t *cluster_id, struct node_t *node_id) 
  {
! 	return 3;
! }
! 
! int llistar_procs (struct cluster_t *cluster_id, struct node_t *node_id, struct proces_t *llista)
! {
! 	llista[0].nom = "p0";
! 	llista[0].next = &llista[1];
! 	llista[1].nom = "p1";
! 	llista[1].next = &llista[2];
! 	llista[2].nom = "p2";
! 	llista[2].next = NULL;
! 
  	return 0;
  }



From nobody at sheep.berlios.de  Mon Jun 14 17:00:25 2004
From: nobody at sheep.berlios.de (xscript)
Date: Mon, 14 Jun 2004 17:00:25 +0200
Subject: [Taca-cvs] codi mosix.c,1.2,1.3
Message-ID: <200406141500.i5EF0PB06769@bat.berlios.de>

Update of /cvsroot/taca/codi
In directory sheep:/tmp/cvs-serv25712/codi

Modified Files:
	mosix.c 
Log Message:



Index: mosix.c
===================================================================
RCS file: /cvsroot/taca/codi/mosix.c,v
retrieving revision 1.2
retrieving revision 1.3
diff -C2 -d -r1.2 -r1.3
*** mosix.c	11 Jun 2004 15:43:12 -0000	1.2
--- mosix.c	14 Jun 2004 15:00:23 -0000	1.3
***************
*** 2,26 ****
  #include "generic.h"
  #include <linux/mm.h>
  
  
! //struct cluster_t clus = {.nom = "123",
! //			 .next = NULL};
! /*
! struct node_t n3 = {	.nom = "n3",
! 			.next = NULL};
! struct node_t n2 = {	.nom = "n2",
! 			.next = &n3 };
! struct node_t n1 = {	.nom = "n1",
! 			.next = &n2};
! 
! struct proces_t p3 = {	.nom = "proc3",
! 			.next = NULL};
  
- struct proces_t p2 = {	.nom = "proc2",
- 			.next = &p3};
- struct proces_t p1 = {	.nom = "proc1",
- 			.next = &p2};
  
- */			
  int num_clusters() 
  {
--- 2,11 ----
  #include "generic.h"
  #include <linux/mm.h>
+ #include <linux/proc_fs.h>
  
  
! struct proc_dir_entry* cerca_proc(struct proc_dir_entry *parent, char *nom);
  
  
  int num_clusters() 
  {
***************
*** 38,53 ****
  int num_nodes (struct cluster_t *cluster_id)
  {
! 	return 3;
  }
  
  int llistar_nodes (struct cluster_t *cluster_id, struct node_t *llista)
  {
! 	llista[0].nom = "n0";
! 	llista[0].next = &llista[1];
! 	llista[1].nom = "n1";
! 	llista[1].next = &llista[2];
! 	llista[2].nom = "n2";
! 	llista[2].next = NULL;
! 
  	return 0;
  }
--- 23,69 ----
  int num_nodes (struct cluster_t *cluster_id)
  {
! 	
! 	struct proc_dir_entry *aux = proc_root.subdir;
! 	int res = 0;
! 	
! 	// Busquem el proc_dir_entry de /proc/hpc
! 	aux = cerca_proc(&proc_root,"hpc");
! 	
! 	// Entrem al directori nodes
! 	aux = cerca_proc(aux,"nodes");
! 	
! 	// Comptem els nodes que te
! 	aux = aux->subdir;
! 	
! 	while (aux != NULL ) {
! 		res++;
! 		aux = aux->next;
! 	}
! 
! 	return res;
  }
  
  int llistar_nodes (struct cluster_t *cluster_id, struct node_t *llista)
  {
! 	struct proc_dir_entry *aux = proc_root.subdir;
! 	int i;
! 	
! 	// Busquem el proc_dir_entry de /proc/hpc
! 	aux = cerca_proc(&proc_root,"hpc");
! 	
! 	// Entrem al directori nodes
! 	aux = cerca_proc(aux,"nodes");
! 	
! 	// Assignem els nomos dels nodes que te
! 	aux = aux->subdir;
! 	i=0;
! 	while (aux != NULL ) {		
! 		llista[i].nom=aux->name;
! 		if (aux->next==NULL)
! 			llista[i].next=NULL;
! 		else llista[i].next=&llista[i+1];
! 		aux = aux->next;
! 	}
! 	
  	return 0;
  }
***************
*** 82,83 ****
--- 98,117 ----
  //int proces_bloquejat (struct proces_t *proc);
  
+ 
+ 
+ // Funcions auxiliars
+ 
+ // Funcio que donat un directori pare i un nom, retorna el proc_dir_entry corresponent
+ // al subdirectori de nom = <nom>
+ struct proc_dir_entry* cerca_proc(struct proc_dir_entry *parent, char *nom) {	
+ 	
+ 	int trobat = 0;
+ 	struct proc_dir_entry *aux = parent->subdir; 
+ 	
+ 	while (aux != NULL && trobat==0) {
+ 		if (!strcmp(aux->name,nom)) trobat = 1;
+ 		else aux = aux->next;
+ 	}
+ 	
+ 	return aux;
+ }



From nobody at sheep.berlios.de  Mon Jun 14 17:54:54 2004
From: nobody at sheep.berlios.de (xscript)
Date: Mon, 14 Jun 2004 17:54:54 +0200
Subject: [Taca-cvs] codi mosix.c,1.3,1.4 rkfs.c,1.2,1.3
Message-ID: <200406141554.i5EFssB08939@bat.berlios.de>

Update of /cvsroot/taca/codi
In directory sheep:/tmp/cvs-serv28346/codi

Modified Files:
	mosix.c rkfs.c 
Log Message:
Hasta aqui hemos llegado, acceder a algo que se genera dinamicamente es un
poco dificil :-S.
Lluis: El directori "code" no compila, per aixo hem seguit fent servir el 
directori "codi"...ho sento.



Index: mosix.c
===================================================================
RCS file: /cvsroot/taca/codi/mosix.c,v
retrieving revision 1.3
retrieving revision 1.4
diff -C2 -d -r1.3 -r1.4
*** mosix.c	14 Jun 2004 15:00:23 -0000	1.3
--- mosix.c	14 Jun 2004 15:54:51 -0000	1.4
***************
*** 24,29 ****
  {
  	
! 	struct proc_dir_entry *aux = proc_root.subdir;
  	int res = 0;
  	
  	// Busquem el proc_dir_entry de /proc/hpc
--- 24,31 ----
  {
  	
! 	struct proc_dir_entry *aux;
  	int res = 0;
+ 
+ 	printk (" **mosix.c: num_nodes\n");
  	
  	// Busquem el proc_dir_entry de /proc/hpc
***************
*** 40,44 ****
  		aux = aux->next;
  	}
! 
  	return res;
  }
--- 42,47 ----
  		aux = aux->next;
  	}
! 	
! 	printk("  ** mosix.c:  El numero de nodes es: %d\n",res);
  	return res;
  }
***************
*** 46,52 ****
  int llistar_nodes (struct cluster_t *cluster_id, struct node_t *llista)
  {
! 	struct proc_dir_entry *aux = proc_root.subdir;
  	int i;
  	
  	// Busquem el proc_dir_entry de /proc/hpc
  	aux = cerca_proc(&proc_root,"hpc");
--- 49,58 ----
  int llistar_nodes (struct cluster_t *cluster_id, struct node_t *llista)
  {
! 
! 	struct proc_dir_entry *aux;
  	int i;
  	
+ 	printk (" ** mosix.c: llistar_nodes\n");
+ 	
  	// Busquem el proc_dir_entry de /proc/hpc
  	aux = cerca_proc(&proc_root,"hpc");
***************
*** 55,62 ****
  	aux = cerca_proc(aux,"nodes");
  	
! 	// Assignem els nomos dels nodes que te
  	aux = aux->subdir;
  	i=0;
  	while (aux != NULL ) {		
  		llista[i].nom=aux->name;
  		if (aux->next==NULL)
--- 61,69 ----
  	aux = cerca_proc(aux,"nodes");
  	
! 	// Assignem els noms dels nodes que te
  	aux = aux->subdir;
  	i=0;
  	while (aux != NULL ) {		
+ 		printk("  ** mosix.c: llistar_nodes -> generando nodo:%s\n", aux->name);
  		llista[i].nom=aux->name;
  		if (aux->next==NULL)
***************
*** 110,117 ****
--- 117,127 ----
  	
  	while (aux != NULL && trobat==0) {
+ 		printk("  ** mosix.c: cerca_proc Estoy en:%s\n",aux->name);
  		if (!strcmp(aux->name,nom)) trobat = 1;
  		else aux = aux->next;
  	}
  	
+ 	if (aux==NULL) printk("  ** mosix.c : cerca_proc -> Ha pasado algo mu malo!\n");
+ 	else printk("  ** mosix.c : cerca_proc -> directorio buscado:%s, encontrado:%s\n",nom,aux->name);
  	return aux;
  }

Index: rkfs.c
===================================================================
RCS file: /cvsroot/taca/codi/rkfs.c,v
retrieving revision 1.2
retrieving revision 1.3
diff -C2 -d -r1.2 -r1.3
*** rkfs.c	11 Jun 2004 15:43:12 -0000	1.2
--- rkfs.c	14 Jun 2004 15:54:51 -0000	1.3
***************
*** 256,270 ****
  	
  	num = num_clusters();
! 	llista = (struct cluster_t *)kmalloc(sizeof(struct cluster_t)*num ,GFP_KERNEL);	
! 	llistar_clusters(llista);
  
!     	printk( " readdir: Creant clusters\n" );
! 	while (llista != NULL) {	
! 		if(filldir(dirent, llista->nom, strlen(llista->nom), file->f_pos++, DIR_INODE_NUMBER, DT_DIR ))
! 	         	return 0;
! 		llista = llista->next;
! 	} 
! 	printk(" readdir: Directoris per clusters creats\n");
! 	kfree(llista);
  		
      }
--- 256,274 ----
  	
  	num = num_clusters();
! 	if (num > 0) {
! 		llista = (struct cluster_t *)kmalloc(sizeof(struct cluster_t)*num ,GFP_KERNEL);	
! 		llistar_clusters(llista);
  
!     		printk( " readdir: Creant clusters\n" );
! 		while (llista != NULL) {	
! 			if(filldir(dirent, llista->nom, strlen(llista->nom), file->f_pos++, DIR_INODE_NUMBER, DT_DIR ))
! 	        	 	return 0;
! 			llista = llista->next;
! 		} 
! 		printk(" readdir: Directoris per clusters creats\n");
! 		kfree(llista);
! 	}
! 	else printk(" readdir: No hi ha clusters a mostrar\n");
!     
  		
      }
***************
*** 283,317 ****
  	// Obtenim tots els clusters i busquem en quin estem
  	num = num_clusters();
! 	llista = (struct cluster_t *)kmalloc(sizeof(struct cluster_t)*num ,GFP_KERNEL);	
! 	llistar_clusters(llista);
  	
! 	while (llista != NULL && i==0) {	
! 		
! 		printk(" readdir: Busquem el cluster\n");
  		
! 		if (!strcmp(de->d_name.name, llista->nom)) i=1;
! 		else llista = llista->next;
! 	} 
  
! 	// Llistem tots els nodes del cluster
! 	num = num_nodes(llista);	
! 	llista1 = (struct node_t *)kmalloc(sizeof(struct node_t)*num ,GFP_KERNEL);
! 	llistar_nodes(llista,llista1);
  
! 	while (llista1 != NULL) {
  		
! 		printk(" readdir: Creem els directoris pels nodes\n");
  		
! 		if(filldir(dirent, llista1->nom, strlen(llista1->nom), file->f_pos++, DIR_INODE_NUMBER, DT_DIR ))
! 			return 0;
! 		llista1 = llista1->next;
! 	}
!     	
! 	printk(" readdir: Directoris per nodes creats\n");
      	
! 	
! 	kfree(llista);
! 	kfree(llista1);
  	}
      
      else if(de->d_parent->d_parent->d_inode->i_ino == rkfs_root_inode->i_ino) // Estem a un node 
--- 287,330 ----
  	// Obtenim tots els clusters i busquem en quin estem
  	num = num_clusters();
! 	if (num>0) {
! 		llista = (struct cluster_t *)kmalloc(sizeof(struct cluster_t)*num ,GFP_KERNEL);	
! 		llistar_clusters(llista);
  	
! 		while (llista != NULL && i==0) {	
! 			
! 			printk(" readdir: Busquem el cluster\n");
  		
! 			if (!strcmp(de->d_name.name, llista->nom)) i=1;
! 			else llista = llista->next;
! 		} 
  
! 	
! 		// Llistem tots els nodes del cluster
! 		num = num_nodes(llista);	
! 		if (num>0) {
! 			llista1 = (struct node_t *)kmalloc(sizeof(struct node_t)*num ,GFP_KERNEL);
! 			llistar_nodes(llista,llista1);
  
! 			while (llista1 != NULL) {
  		
! 				printk(" readdir: Creem els directoris pels nodes\n");
  		
! 				if(filldir(dirent, llista1->nom, strlen(llista1->nom), file->f_pos++, DIR_INODE_NUMBER, DT_DIR ))
! 					return 0;
! 				llista1 = llista1->next;
! 			}
      	
! 			printk(" readdir: Directoris per nodes creats\n");
!     			kfree(llista);
! 			kfree(llista1);
! 		}
! 		else {
! 			printk (" readdir: No hi ha nodes a mostrar\n");
! 			kfree(llista);
! 		}
  	}
+ 	else printk (" readdir: No hi ha clusters amb nodes a mostrar\n");
+ 		
+     }
      
      else if(de->d_parent->d_parent->d_inode->i_ino == rkfs_root_inode->i_ino) // Estem a un node 
***************
*** 328,374 ****
  	// Obtenim tots els clusters i busquem en quin estem
  	num = num_clusters();
! 	llista = (struct cluster_t *)kmalloc(sizeof(struct cluster_t)*num ,GFP_KERNEL);	
! 	llistar_clusters(llista);
! 	
! 	while (llista != NULL && i==0) {	
! 		
! 		printk(" readdir: Busquem el cluster\n");
! 		
! 		if (!strcmp(de->d_parent->d_name.name, llista->nom)) i=1;
! 		else llista = llista->next;
! 	} 
  
! 	// Obtenim  tots els nodes del cluster i busquem en quin estem
! 	i = 0; 
! 	num = num_nodes(llista);	
! 	llista1 = (struct node_t *)kmalloc(sizeof(struct node_t)*num ,GFP_KERNEL);
! 	llistar_nodes(llista,llista1);
  
! 	while (llista1 != NULL && i==0) {
! 		
! 		printk(" readdir: Busquem el node\n");
! 		
! 		if (!strcmp(de->d_name.name, llista1->nom)) i=1;
! 		else llista1 = llista1->next;
! 	}
!     	
! 	
! 	// LListem els processos del cluster
! 	num = num_procs(llista,llista1);	
! 	llista2 = (struct proces_t *)kmalloc(sizeof(struct proces_t)*num ,GFP_KERNEL);
! 	llistar_procs(llista,llista1,llista2);
  
! 	while (llista2 != NULL) {
! 		if(filldir(dirent, llista2->nom, strlen(llista2->nom), file->f_pos++, FILE_INODE_NUMBER, DT_REG ))
! 			return 0;
! 		llista2 = llista2->next;
  	}
- 	
- 	printk(" readdir: Fitxers per processos creats\n");
-     	
- 	
- 	kfree(llista);
- 	kfree(llista1);
- 	kfree(llista2);	
      }
      
--- 341,402 ----
  	// Obtenim tots els clusters i busquem en quin estem
  	num = num_clusters();
! 	if (num>0) {
! 		llista = (struct cluster_t *)kmalloc(sizeof(struct cluster_t)*num ,GFP_KERNEL);	
! 		llistar_clusters(llista);
  
! 		while (llista != NULL && i==0) {	
  
! 			printk(" readdir: Busquem el cluster\n");
  
! 			if (!strcmp(de->d_parent->d_name.name, llista->nom)) i=1;
! 			else llista = llista->next;
! 		} 
! 
! 		// Obtenim  tots els nodes del cluster i busquem en quin estem
! 		i = 0; 
! 		num = num_nodes(llista);	
! 		if (num>0) {
! 			llista1 = (struct node_t *)kmalloc(sizeof(struct node_t)*num ,GFP_KERNEL);
! 			llistar_nodes(llista,llista1);
! 
! 			while (llista1 != NULL && i==0) {
! 
! 				printk(" readdir: Busquem el node\n");
! 
! 				if (!strcmp(de->d_name.name, llista1->nom)) i=1;
! 				else llista1 = llista1->next;
! 			}
! 
! 
! 			// LListem els processos del cluster
! 			num = num_procs(llista,llista1);	
! 			if (num>0) {
! 				llista2 = (struct proces_t *)kmalloc(sizeof(struct proces_t)*num ,GFP_KERNEL);
! 				llistar_procs(llista,llista1,llista2);
! 
! 				while (llista2 != NULL) {
! 					if(filldir(dirent, llista2->nom, strlen(llista2->nom), file->f_pos++, FILE_INODE_NUMBER, DT_REG ))
! 					return 0;
! 					llista2 = llista2->next;
! 				}
! 				kfree (llista);
! 				kfree (llista1);
! 				kfree (llista2);
! 				printk(" readdir: Fitxers per processos creats\n");
! 			}
! 			else {
! 				printk(" readdir: No hi ha processos a mostrar\n");
! 				kfree(llista);
! 				kfree(llista1);
! 			}
! 		}
! 		else {
! 			printk(" readdir: No hi ha nodes amb processos a mostrar\n");
! 			kfree(llista);
! 		}
!     	}
! 	else {
! 		printk(" readdir: No hi ha clusters amb nodes amb processos a mostrar\n");
  	}
      }
      



From nobody at sheep.berlios.de  Mon Jun 14 20:41:48 2004
From: nobody at sheep.berlios.de (xscript)
Date: Mon, 14 Jun 2004 20:41:48 +0200
Subject: [Taca-cvs] code Makefile,1.2,1.3
Message-ID: <200406141841.i5EIfmB12940@bat.berlios.de>

Update of /cvsroot/taca/code
In directory sheep:/tmp/cvs-serv1063

Modified Files:
	Makefile 
Log Message:
Don't use standard includes on compile-time

Index: Makefile
===================================================================
RCS file: /cvsroot/taca/code/Makefile,v
retrieving revision 1.2
retrieving revision 1.3
diff -C2 -d -r1.2 -r1.3
*** Makefile	11 Jun 2004 03:10:33 -0000	1.2
--- Makefile	14 Jun 2004 18:41:45 -0000	1.3
***************
*** 6,9 ****
--- 6,10 ----
  CFLAGS  += -Wall -O2 \
  	   -D__KERNEL__ -DMODULE \
+ 	   -inostdinc \
  	   -I$(TOPDIR)/backend
  



From nobody at sheep.berlios.de  Mon Jun 14 20:44:02 2004
From: nobody at sheep.berlios.de (xscript)
Date: Mon, 14 Jun 2004 20:44:02 +0200
Subject: [Taca-cvs] code Rules.conf,1.1,1.2
Message-ID: <200406141844.i5EIi2B12971@bat.berlios.de>

Update of /cvsroot/taca/code
In directory sheep:/tmp/cvs-serv1369

Modified Files:
	Rules.conf 
Log Message:
Use openmosix kernel by default

Index: Rules.conf
===================================================================
RCS file: /cvsroot/taca/code/Rules.conf,v
retrieving revision 1.1
retrieving revision 1.2
diff -C2 -d -r1.1 -r1.2
*** Rules.conf	11 Jun 2004 02:48:47 -0000	1.1
--- Rules.conf	14 Jun 2004 18:43:59 -0000	1.2
***************
*** 19,23 ****
  MNTPOINT = /mnt/$(FSNAME)
  
! INCLUDEDIR = /usr/src/kernel-source-2.4.20/include
  
  ########################
--- 19,25 ----
  MNTPOINT = /mnt/$(FSNAME)
  
! INCLUDEDIR = /usr/src/linux-openmosix/include
! #INCLUDEDIR = /usr/src/kernel-source-2.4.20/include
! #INCLUDEDIR = /usr/src/linux/include
  
  ########################



From nobody at sheep.berlios.de  Tue Jun 15 01:48:55 2004
From: nobody at sheep.berlios.de (xscript)
Date: Tue, 15 Jun 2004 01:48:55 +0200
Subject: [Taca-cvs] code Makefile,1.3,1.4
Message-ID: <200406142348.i5ENmtB19325@bat.berlios.de>

Update of /cvsroot/taca/code
In directory sheep:/tmp/cvs-serv22868

Modified Files:
	Makefile 
Log Message:
Minor fixes

Index: Makefile
===================================================================
RCS file: /cvsroot/taca/code/Makefile,v
retrieving revision 1.3
retrieving revision 1.4
diff -C2 -d -r1.3 -r1.4
*** Makefile	14 Jun 2004 18:41:45 -0000	1.3
--- Makefile	14 Jun 2004 23:48:49 -0000	1.4
***************
*** 27,31 ****
  	mount -t $(FSNAME) none $(MNTPOINT)
  
! re-run: re-$(TARGET)
  	umount $(MNTPOINT)
  	rmmod $(FSNAME)
--- 27,31 ----
  	mount -t $(FSNAME) none $(MNTPOINT)
  
! re-run: $(TARGET)
  	umount $(MNTPOINT)
  	rmmod $(FSNAME)



From nobody at sheep.berlios.de  Tue Jun 15 01:51:21 2004
From: nobody at sheep.berlios.de (xscript)
Date: Tue, 15 Jun 2004 01:51:21 +0200
Subject: [Taca-cvs] code/backend backend.h,1.2,1.3
Message-ID: <200406142351.i5ENpLB19377@bat.berlios.de>

Update of /cvsroot/taca/code/backend
In directory sheep:/tmp/cvs-serv25114/backend

Modified Files:
	backend.h 
Log Message:
Parent pointers on our structs

Index: backend.h
===================================================================
RCS file: /cvsroot/taca/code/backend/backend.h,v
retrieving revision 1.2
retrieving revision 1.3
diff -C2 -d -r1.2 -r1.3
*** backend.h	11 Jun 2004 20:07:34 -0000	1.2
--- backend.h	14 Jun 2004 23:51:18 -0000	1.3
***************
*** 1,4 ****
  struct cluster_t {
- 
  	char *nom;
  	struct cluster_t *next;
--- 1,3 ----
***************
*** 6,18 ****
  
  struct node_t {
- 
  	char *nom;
  	struct node_t *next;
  };
  
  struct proces_t {
- 	
  	char *nom;
  	struct proces_t *next;
  };
  
--- 5,17 ----
  
  struct node_t {
  	char *nom;
  	struct node_t *next;
+ 	struct cluster_t *parent;
  };
  
  struct proces_t {
  	char *nom;
  	struct proces_t *next;
+ 	struct node_t *parent;
  };
  



From nobody at sheep.berlios.de  Tue Jun 15 01:54:51 2004
From: nobody at sheep.berlios.de (xscript)
Date: Tue, 15 Jun 2004 01:54:51 +0200
Subject: [Taca-cvs] code/backend/openmosix openmosix.c,1.3,1.4
Message-ID: <200406142354.i5ENspB19438@bat.berlios.de>

Update of /cvsroot/taca/code/backend/openmosix
In directory sheep:/tmp/cvs-serv26242/backend/openmosix

Modified Files:
	openmosix.c 
Log Message:
Backport of today's work

Index: openmosix.c
===================================================================
RCS file: /cvsroot/taca/code/backend/openmosix/openmosix.c,v
retrieving revision 1.3
retrieving revision 1.4
diff -C2 -d -r1.3 -r1.4
*** openmosix.c	11 Jun 2004 20:07:35 -0000	1.3
--- openmosix.c	14 Jun 2004 23:54:48 -0000	1.4
***************
*** 2,26 ****
  #include "backend.h"
  #include <linux/mm.h>
  
  
! //struct cluster_t clus = {.nom = "123",
! //			 .next = NULL};
! /*
! struct node_t n3 = {	.nom = "n3",
! 			.next = NULL};
! struct node_t n2 = {	.nom = "n2",
! 			.next = &n3 };
! struct node_t n1 = {	.nom = "n1",
! 			.next = &n2};
! 
! struct proces_t p3 = {	.nom = "proc3",
! 			.next = NULL};
  
- struct proces_t p2 = {	.nom = "proc2",
- 			.next = &p3};
- struct proces_t p1 = {	.nom = "proc1",
- 			.next = &p2};
  
- */			
  int num_clusters() 
  {
--- 2,11 ----
  #include "backend.h"
  #include <linux/mm.h>
+ #include <linux/proc_fs.h>
  
  
! struct proc_dir_entry* cerca_proc(struct proc_dir_entry *parent, char *nom);
  
  
  int num_clusters() 
  {
***************
*** 38,53 ****
  int num_nodes (struct cluster_t *cluster_id)
  {
! 	return 3;
  }
  
  int llistar_nodes (struct cluster_t *cluster_id, struct node_t *llista)
  {
- 	llista[0].nom = "n0";
- 	llista[0].next = &llista[1];
- 	llista[1].nom = "n1";
- 	llista[1].next = &llista[2];
- 	llista[2].nom = "n2";
- 	llista[2].next = NULL;
  
  	return 0;
  }
--- 23,76 ----
  int num_nodes (struct cluster_t *cluster_id)
  {
! 	
! 	struct proc_dir_entry *aux;
! 	int res = 0;
! 
! 	printk (" **mosix.c: num_nodes\n");
! 	
! 	// Busquem el proc_dir_entry de /proc/hpc
! 	aux = cerca_proc(&proc_root,"hpc");
! 	
! 	// Entrem al directori nodes
! 	aux = cerca_proc(aux,"nodes");
! 	
! 	// Comptem els nodes que te
! 	aux = aux->subdir;
! 	
! 	while (aux != NULL ) {
! 		res++;
! 		aux = aux->next;
! 	}
! 	
! 	printk("  ** mosix.c:  El numero de nodes es: %d\n",res);
! 	return res;
  }
  
  int llistar_nodes (struct cluster_t *cluster_id, struct node_t *llista)
  {
  
+ 	struct proc_dir_entry *aux;
+ 	int i;
+ 	
+ 	printk (" ** mosix.c: llistar_nodes\n");
+ 	
+ 	// Busquem el proc_dir_entry de /proc/hpc
+ 	aux = cerca_proc(&proc_root,"hpc");
+ 	
+ 	// Entrem al directori nodes
+ 	aux = cerca_proc(aux,"nodes");
+ 	
+ 	// Assignem els noms dels nodes que te
+ 	aux = aux->subdir;
+ 	i=0;
+ 	while (aux != NULL ) {		
+ 		printk("  ** mosix.c: llistar_nodes -> generando nodo:%s\n", aux->name);
+ 		llista[i].nom=aux->name;
+ 		if (aux->next==NULL)
+ 			llista[i].next=NULL;
+ 		else llista[i].next=&llista[i+1];
+ 		aux = aux->next;
+ 	}
+ 	
  	return 0;
  }
***************
*** 82,83 ****
--- 105,127 ----
  //int proces_bloquejat (struct proces_t *proc);
  
+ 
+ 
+ // Funcions auxiliars
+ 
+ // Funcio que donat un directori pare i un nom, retorna el proc_dir_entry corresponent
+ // al subdirectori de nom = <nom>
+ struct proc_dir_entry* cerca_proc(struct proc_dir_entry *parent, char *nom) {	
+ 	
+ 	int trobat = 0;
+ 	struct proc_dir_entry *aux = parent->subdir; 
+ 	
+ 	while (aux != NULL && trobat==0) {
+ 		printk("  ** mosix.c: cerca_proc Estoy en:%s\n",aux->name);
+ 		if (!strcmp(aux->name,nom)) trobat = 1;
+ 		else aux = aux->next;
+ 	}
+ 	
+ 	if (aux==NULL) printk("  ** mosix.c : cerca_proc -> Ha pasado algo mu malo!\n");
+ 	else printk("  ** mosix.c : cerca_proc -> directorio buscado:%s, encontrado:%s\n",nom,aux->name);
+ 	return aux;
+ }



From nobody at sheep.berlios.de  Tue Jun 15 01:54:51 2004
From: nobody at sheep.berlios.de (xscript)
Date: Tue, 15 Jun 2004 01:54:51 +0200
Subject: [Taca-cvs] code/frontend/linux linux.c,1.2,1.3
Message-ID: <200406142354.i5ENspB19441@bat.berlios.de>

Update of /cvsroot/taca/code/frontend/linux
In directory sheep:/tmp/cvs-serv26242/frontend/linux

Modified Files:
	linux.c 
Log Message:
Backport of today's work

Index: linux.c
===================================================================
RCS file: /cvsroot/taca/code/frontend/linux/linux.c,v
retrieving revision 1.2
retrieving revision 1.3
diff -C2 -d -r1.2 -r1.3
*** linux.c	11 Jun 2004 20:05:41 -0000	1.2
--- linux.c	14 Jun 2004 23:54:49 -0000	1.3
***************
*** 1,3 ****
--- 1,7 ----
  /**
+  *
+  * XXX
+  * dentry -> d_fsdata : fs-specific data
+  *
   * Notes:
   * Implementing a small filesystem having one file
***************
*** 105,109 ****
  void rkfs_s_readinode( struct inode *inode ) {
      inode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME;
!     printk( "rkfs: super_operations.readinode called\n" );
  }
  
--- 109,113 ----
  void rkfs_s_readinode( struct inode *inode ) {
      inode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME;
!     printk("rkfs: super_operations.readinode called\n");
  }
  
***************
*** 256,270 ****
  	
  	num = num_clusters();
! 	llista = (struct cluster_t *)kmalloc(sizeof(struct cluster_t)*num ,GFP_KERNEL);	
! 	llistar_clusters(llista);
  
!     	printk( " readdir: Creant clusters\n" );
! 	while (llista != NULL) {	
! 		if(filldir(dirent, llista->nom, strlen(llista->nom), file->f_pos++, DIR_INODE_NUMBER, DT_DIR ))
! 	         	return 0;
! 		llista = llista->next;
! 	} 
! 	printk(" readdir: Directoris per clusters creats\n");
! 	kfree(llista);
  		
      }
--- 260,278 ----
  	
  	num = num_clusters();
! 	if (num > 0) {
! 		llista = (struct cluster_t *)kmalloc(sizeof(struct cluster_t)*num ,GFP_KERNEL);	
! 		llistar_clusters(llista);
  
!     		printk( " readdir: Creant clusters\n" );
! 		while (llista != NULL) {	
! 			if(filldir(dirent, llista->nom, strlen(llista->nom), file->f_pos++, DIR_INODE_NUMBER, DT_DIR ))
! 	        	 	return 0;
! 			llista = llista->next;
! 		} 
! 		printk(" readdir: Directoris per clusters creats\n");
! 		kfree(llista);
! 	}
! 	else printk(" readdir: No hi ha clusters a mostrar\n");
!     
  		
      }
***************
*** 283,317 ****
  	// Obtenim tots els clusters i busquem en quin estem
  	num = num_clusters();
! 	llista = (struct cluster_t *)kmalloc(sizeof(struct cluster_t)*num ,GFP_KERNEL);	
! 	llistar_clusters(llista);
  	
! 	while (llista != NULL && i==0) {	
! 		
! 		printk(" readdir: Busquem el cluster\n");
  		
! 		if (!strcmp(de->d_name.name, llista->nom)) i=1;
! 		else llista = llista->next;
! 	} 
  
! 	// Llistem tots els nodes del cluster
! 	num = num_nodes(llista);	
! 	llista1 = (struct node_t *)kmalloc(sizeof(struct node_t)*num ,GFP_KERNEL);
! 	llistar_nodes(llista,llista1);
  
! 	while (llista1 != NULL) {
  		
! 		printk(" readdir: Creem els directoris pels nodes\n");
  		
! 		if(filldir(dirent, llista1->nom, strlen(llista1->nom), file->f_pos++, DIR_INODE_NUMBER, DT_DIR ))
! 			return 0;
! 		llista1 = llista1->next;
! 	}
!     	
! 	printk(" readdir: Directoris per nodes creats\n");
      	
! 	
! 	kfree(llista);
! 	kfree(llista1);
  	}
      
      else if(de->d_parent->d_parent->d_inode->i_ino == rkfs_root_inode->i_ino) // Estem a un node 
--- 291,334 ----
  	// Obtenim tots els clusters i busquem en quin estem
  	num = num_clusters();
! 	if (num>0) {
! 		llista = (struct cluster_t *)kmalloc(sizeof(struct cluster_t)*num ,GFP_KERNEL);	
! 		llistar_clusters(llista);
  	
! 		while (llista != NULL && i==0) {	
! 			
! 			printk(" readdir: Busquem el cluster\n");
  		
! 			if (!strcmp(de->d_name.name, llista->nom)) i=1;
! 			else llista = llista->next;
! 		} 
  
! 	
! 		// Llistem tots els nodes del cluster
! 		num = num_nodes(llista);	
! 		if (num>0) {
! 			llista1 = (struct node_t *)kmalloc(sizeof(struct node_t)*num ,GFP_KERNEL);
! 			llistar_nodes(llista,llista1);
  
! 			while (llista1 != NULL) {
  		
! 				printk(" readdir: Creem els directoris pels nodes\n");
  		
! 				if(filldir(dirent, llista1->nom, strlen(llista1->nom), file->f_pos++, DIR_INODE_NUMBER, DT_DIR ))
! 					return 0;
! 				llista1 = llista1->next;
! 			}
      	
! 			printk(" readdir: Directoris per nodes creats\n");
!     			kfree(llista);
! 			kfree(llista1);
! 		}
! 		else {
! 			printk (" readdir: No hi ha nodes a mostrar\n");
! 			kfree(llista);
! 		}
  	}
+ 	else printk (" readdir: No hi ha clusters amb nodes a mostrar\n");
+ 		
+     }
      
      else if(de->d_parent->d_parent->d_inode->i_ino == rkfs_root_inode->i_ino) // Estem a un node 
***************
*** 328,374 ****
  	// Obtenim tots els clusters i busquem en quin estem
  	num = num_clusters();
! 	llista = (struct cluster_t *)kmalloc(sizeof(struct cluster_t)*num ,GFP_KERNEL);	
! 	llistar_clusters(llista);
! 	
! 	while (llista != NULL && i==0) {	
! 		
! 		printk(" readdir: Busquem el cluster\n");
! 		
! 		if (!strcmp(de->d_parent->d_name.name, llista->nom)) i=1;
! 		else llista = llista->next;
! 	} 
  
! 	// Obtenim  tots els nodes del cluster i busquem en quin estem
! 	i = 0; 
! 	num = num_nodes(llista);	
! 	llista1 = (struct node_t *)kmalloc(sizeof(struct node_t)*num ,GFP_KERNEL);
! 	llistar_nodes(llista,llista1);
  
! 	while (llista1 != NULL && i==0) {
! 		
! 		printk(" readdir: Busquem el node\n");
! 		
! 		if (!strcmp(de->d_name.name, llista1->nom)) i=1;
! 		else llista1 = llista1->next;
! 	}
!     	
! 	
! 	// LListem els processos del cluster
! 	num = num_procs(llista,llista1);	
! 	llista2 = (struct proces_t *)kmalloc(sizeof(struct proces_t)*num ,GFP_KERNEL);
! 	llistar_procs(llista,llista1,llista2);
  
! 	while (llista2 != NULL) {
! 		if(filldir(dirent, llista2->nom, strlen(llista2->nom), file->f_pos++, FILE_INODE_NUMBER, DT_REG ))
! 			return 0;
! 		llista2 = llista2->next;
  	}
- 	
- 	printk(" readdir: Fitxers per processos creats\n");
-     	
- 	
- 	kfree(llista);
- 	kfree(llista1);
- 	kfree(llista2);	
      }
      
--- 345,406 ----
  	// Obtenim tots els clusters i busquem en quin estem
  	num = num_clusters();
! 	if (num>0) {
! 		llista = (struct cluster_t *)kmalloc(sizeof(struct cluster_t)*num ,GFP_KERNEL);	
! 		llistar_clusters(llista);
  
! 		while (llista != NULL && i==0) {	
  
! 			printk(" readdir: Busquem el cluster\n");
  
! 			if (!strcmp(de->d_parent->d_name.name, llista->nom)) i=1;
! 			else llista = llista->next;
! 		} 
! 
! 		// Obtenim  tots els nodes del cluster i busquem en quin estem
! 		i = 0; 
! 		num = num_nodes(llista);	
! 		if (num>0) {
! 			llista1 = (struct node_t *)kmalloc(sizeof(struct node_t)*num ,GFP_KERNEL);
! 			llistar_nodes(llista,llista1);
! 
! 			while (llista1 != NULL && i==0) {
! 
! 				printk(" readdir: Busquem el node\n");
! 
! 				if (!strcmp(de->d_name.name, llista1->nom)) i=1;
! 				else llista1 = llista1->next;
! 			}
! 
! 
! 			// LListem els processos del cluster
! 			num = num_procs(llista,llista1);	
! 			if (num>0) {
! 				llista2 = (struct proces_t *)kmalloc(sizeof(struct proces_t)*num ,GFP_KERNEL);
! 				llistar_procs(llista,llista1,llista2);
! 
! 				while (llista2 != NULL) {
! 					if(filldir(dirent, llista2->nom, strlen(llista2->nom), file->f_pos++, FILE_INODE_NUMBER, DT_REG ))
! 					return 0;
! 					llista2 = llista2->next;
! 				}
! 				kfree (llista);
! 				kfree (llista1);
! 				kfree (llista2);
! 				printk(" readdir: Fitxers per processos creats\n");
! 			}
! 			else {
! 				printk(" readdir: No hi ha processos a mostrar\n");
! 				kfree(llista);
! 				kfree(llista1);
! 			}
! 		}
! 		else {
! 			printk(" readdir: No hi ha nodes amb processos a mostrar\n");
! 			kfree(llista);
! 		}
!     	}
! 	else {
! 		printk(" readdir: No hi ha clusters amb nodes amb processos a mostrar\n");
  	}
      }
      



From nobody at sheep.berlios.de  Tue Jun 15 01:56:51 2004
From: nobody at sheep.berlios.de (xscript)
Date: Tue, 15 Jun 2004 01:56:51 +0200
Subject: [Taca-cvs] code/frontend/linux dummy.c,NONE,1.1
Message-ID: <200406142356.i5ENupB19529@bat.berlios.de>

Update of /cvsroot/taca/code/frontend/linux
In directory sheep:/tmp/cvs-serv26519/frontend/linux

Added Files:
	dummy.c 
Log Message:
Dummy printk's for VFS tracing

--- NEW FILE: dummy.c ---
/*
 * Dummy FS operations for tracing purposes
 */

/* super_operations */
struct inode *dummy_alloc_inode (struct super_block *sb x0) {
    printk("file_operations.%s\n",__FUNCTION__);
    return 0;
}

void dummy_destroy_inode (struct inode * x0) {
    printk("file_operations.%s\n",__FUNCTION__);
    return 0;
}

void dummy_read_inode (struct inode * x0) {
    printk("file_operations.%s\n",__FUNCTION__);
    return 0;
}

void dummy_dirty_inode (struct inode * x0) {
    printk("file_operations.%s\n",__FUNCTION__);
    return 0;
}

void dummy_write_inode (struct inode * x1| int x0) {
    printk("file_operations.%s\n",__FUNCTION__);
    return 0;
}

void dummy_put_inode (struct inode * x0) {
    printk("file_operations.%s\n",__FUNCTION__);
    return 0;
}

void dummy_drop_inode (struct inode * x0) {
    printk("file_operations.%s\n",__FUNCTION__);
    return 0;
}

void dummy_delete_inode (struct inode * x0) {
    printk("file_operations.%s\n",__FUNCTION__);
    return 0;
}

void dummy_put_super (struct super_block * x0) {
    printk("file_operations.%s\n",__FUNCTION__);
    return 0;
}

void dummy_write_super (struct super_block * x0) {
    printk("file_operations.%s\n",__FUNCTION__);
    return 0;
}

int dummy_sync_fs (struct super_block *sb x1| int wait x0) {
    printk("file_operations.%s\n",__FUNCTION__);
    return 0;
}

void dummy_write_super_lockfs (struct super_block * x0) {
    printk("file_operations.%s\n",__FUNCTION__);
    return 0;
}

void dummy_unlockfs (struct super_block * x0) {
    printk("file_operations.%s\n",__FUNCTION__);
    return 0;
}

int dummy_statfs (struct super_block * x1| struct kstatfs * x0) {
    printk("file_operations.%s\n",__FUNCTION__);
    return 0;
}

int dummy_remount_fs (struct super_block * x1| int * x2| char * x0) {
    printk("file_operations.%s\n",__FUNCTION__);
    return 0;
}

void dummy_clear_inode (struct inode * x0) {
    printk("file_operations.%s\n",__FUNCTION__);
    return 0;
}

void dummy_umount_begin (struct super_block * x0) {
    printk("file_operations.%s\n",__FUNCTION__);
    return 0;
}

int dummy_show_options (struct seq_file * x1| struct vfsmount * x0) {
    printk("file_operations.%s\n",__FUNCTION__);
    return 0;
}

/* file_operations */
loff_t dummy_llseek (struct file * x1| loff_t x2| int origin x0) {
    printk("file_operations.%s\n",__FUNCTION__);
    return 0;
}

ssize_t dummy_read (struct file * x1| char __user * x2| size_t x3| loff_t * x0) {
    printk("file_operations.%s\n",__FUNCTION__);
    return 0;
}

ssize_t dummy_aio_read (struct kiocb * x1| char __user * x2| size_t x3| loff_t x0) {
    printk("file_operations.%s\n",__FUNCTION__);
    return 0;
}

ssize_t dummy_write (struct file * x1| const char __user * x2| size_t x3| loff_t * x0) {
    printk("file_operations.%s\n",__FUNCTION__);
    return 0;
}

ssize_t dummy_aio_write (struct kiocb * x1| const char __user * x2| size_t x3| loff_t x0) {
    printk("file_operations.%s\n",__FUNCTION__);
    return 0;
}

int dummy_readdir (struct file * x1| void * x2| filldir_t x0) {
    printk("file_operations.%s\n",__FUNCTION__);
    return 0;
}

unsigned int dummy_poll (struct file * x1| struct poll_table_struct * x0) {
    printk("file_operations.%s\n",__FUNCTION__);
    return 0;
}

int dummy_ioctl (struct inode * x1| struct file * x2| unsigned int x3| unsigned long x0) {
    printk("file_operations.%s\n",__FUNCTION__);
    return 0;
}

int dummy_mmap (struct file * x1| struct vm_area_struct * x0) {
    printk("file_operations.%s\n",__FUNCTION__);
    return 0;
}

int dummy_open (struct inode * x1| struct file *file x0) {
    printk("file_operations.%s\n",__FUNCTION__);
    return 0;
}

int dummy_flush (struct file * x0) {
    printk("file_operations.%s\n",__FUNCTION__);
    return 0;
}

int dummy_release (struct inode * x1| struct file * x0) {
    printk("file_operations.%s\n",__FUNCTION__);
    return 0;
}

int dummy_fsync (struct file * x1| struct dentry * x2| int datasync x0) {
    printk("file_operations.%s\n",__FUNCTION__);
    return 0;
}

int dummy_aio_fsync (struct kiocb * x1| int datasync x0) {
    printk("file_operations.%s\n",__FUNCTION__);
    return 0;
}

int dummy_fasync (int x1| struct file * x2| int x0) {
    printk("file_operations.%s\n",__FUNCTION__);
    return 0;
}

int dummy_lock (struct file * x1| int x2| struct file_lock * x0) {
    printk("file_operations.%s\n",__FUNCTION__);
    return 0;
}

ssize_t dummy_readv (struct file * x1| const struct iovec * x2| unsigned long x3| loff_t * x0) {
    printk("file_operations.%s\n",__FUNCTION__);
    return 0;
}

ssize_t dummy_writev (struct file * x1| const struct iovec * x2| unsigned long x3| loff_t * x0) {
    printk("file_operations.%s\n",__FUNCTION__);
    return 0;
}

ssize_t dummy_sendfile (struct file * x1| loff_t * x2| size_t x3| read_actor_t x4| void __user * x0) {
    printk("file_operations.%s\n",__FUNCTION__);
    return 0;
}

ssize_t dummy_sendpage (struct file * x1| struct page * x2| int x3| size_t x4| loff_t * x5| int x0) {
    printk("file_operations.%s\n",__FUNCTION__);
    return 0;
}

unsigned long dummy_get_unmapped_area (struct file * x1| unsigned long x2| unsigned long x3| unsigned long x4| unsigned long x0) {
    printk("file_operations.%s\n",__FUNCTION__);
    return 0;
}

/* dentry_operations */
int dummy_d_revalidate (struct dentry * x1| struct nameidata * x0) {
    printk("file_operations.%s\n",__FUNCTION__);
    return 0;
}

int dummy_d_hash (struct dentry * x1| struct qstr * x0) {
    printk("file_operations.%s\n",__FUNCTION__);
    return 0;
}

int dummy_d_compare (struct dentry * x1| struct qstr * x2| struct qstr * x0) {
    printk("file_operations.%s\n",__FUNCTION__);
    return 0;
}

int dummy_d_delete (struct dentry * x0) {
    printk("file_operations.%s\n",__FUNCTION__);
    return 0;
}

void dummy_d_release (struct dentry * x0) {
    printk("file_operations.%s\n",__FUNCTION__);
    return 0;
}

void dummy_d_iput (struct dentry * x1| struct inode * x0) {
    printk("file_operations.%s\n",__FUNCTION__);
    return 0;
}


/* inode_operations */
int dummy_create (struct inode * x1|struct dentry * x2|int x3| struct nameidata * x0) {
    printk("file_operations.%s\n",__FUNCTION__);
    return 0;
}

struct dentry * dummy_lookup (struct inode * x1|struct dentry * x2| struct nameidata * x0) {
    printk("file_operations.%s\n",__FUNCTION__);
    return 0;
}

int dummy_link (struct dentry * x1|struct inode * x2|struct dentry * x0) {
    printk("file_operations.%s\n",__FUNCTION__);
    return 0;
}

int dummy_unlink (struct inode * x1|struct dentry * x0) {
    printk("file_operations.%s\n",__FUNCTION__);
    return 0;
}

int dummy_symlink (struct inode * x1|struct dentry * x2|const char * x0) {
    printk("file_operations.%s\n",__FUNCTION__);
    return 0;
}

int dummy_mkdir (struct inode * x1|struct dentry * x2|int x0) {
    printk("file_operations.%s\n",__FUNCTION__);
    return 0;
}

int dummy_rmdir (struct inode * x1|struct dentry * x0) {
    printk("file_operations.%s\n",__FUNCTION__);
    return 0;
}

int dummy_mknod (struct inode * x1|struct dentry * x2|int x3|dev_t x0) {
    printk("file_operations.%s\n",__FUNCTION__);
    return 0;
}

int dummy_rename (struct inode * x1| struct dentry * x2| struct inode * x3| struct dentry * x0) {
    printk("file_operations.%s\n",__FUNCTION__);
    return 0;
}

int dummy_readlink (struct dentry * x1| char __user * x2|int x0) {
    printk("file_operations.%s\n",__FUNCTION__);
    return 0;
}

int dummy_follow_link (struct dentry * x1| struct nameidata * x0) {
    printk("file_operations.%s\n",__FUNCTION__);
    return 0;
}

void dummy_truncate (struct inode * x0) {
    printk("file_operations.%s\n",__FUNCTION__);
    return 0;
}

int dummy_permission (struct inode * x1| int x2| struct nameidata * x0) {
    printk("file_operations.%s\n",__FUNCTION__);
    return 0;
}

int dummy_setattr (struct dentry * x1| struct iattr * x0) {
    printk("file_operations.%s\n",__FUNCTION__);
    return 0;
}

int dummy_getattr (struct vfsmount *mnt x1| struct dentry * x2| struct kstat * x0) {
    printk("file_operations.%s\n",__FUNCTION__);
    return 0;
}

int dummy_setxattr (struct dentry * x1| const char * x2|const void * x3|size_t x4|int x0) {
    printk("file_operations.%s\n",__FUNCTION__);
    return 0;
}

ssize_t dummy_getxattr (struct dentry * x1| const char * x2| void * x3| size_t x0) {
    printk("file_operations.%s\n",__FUNCTION__);
    return 0;
}

ssize_t dummy_listxattr (struct dentry * x1| char * x2| size_t x0) {
    printk("file_operations.%s\n",__FUNCTION__);
    return 0;
}

int dummy_removexattr (struct dentry * x1| const char * x0) {
    printk("file_operations.%s\n",__FUNCTION__);
    return 0;
}




From nobody at sheep.berlios.de  Tue Jun 15 19:23:07 2004
From: nobody at sheep.berlios.de (xscript)
Date: Tue, 15 Jun 2004 19:23:07 +0200
Subject: [Taca-cvs] code/backend/dummy - New directory
Message-ID: <200406151723.i5FHN7B10814@bat.berlios.de>

Update of /cvsroot/taca/code/backend/dummy
In directory sheep:/tmp/cvs-serv9062/code/backend/dummy

Log Message:
Directory /cvsroot/taca/code/backend/dummy added to the repository




From nobody at sheep.berlios.de  Tue Jun 15 19:24:57 2004
From: nobody at sheep.berlios.de (xscript)
Date: Tue, 15 Jun 2004 19:24:57 +0200
Subject: [Taca-cvs] code Rules.conf,1.2,1.3
Message-ID: <200406151724.i5FHOvB10837@bat.berlios.de>

Update of /cvsroot/taca/code
In directory sheep:/tmp/cvs-serv9134/code

Modified Files:
	Rules.conf 
Log Message:
OpenMosix definitivament es resisteix

Index: Rules.conf
===================================================================
RCS file: /cvsroot/taca/code/Rules.conf,v
retrieving revision 1.2
retrieving revision 1.3
diff -C2 -d -r1.2 -r1.3
*** Rules.conf	14 Jun 2004 18:43:59 -0000	1.2
--- Rules.conf	15 Jun 2004 17:24:54 -0000	1.3
***************
*** 10,14 ****
  # Available Backends:
  # - openmosix.o
! BACKEND  = openmosix.o
  # (!)
  BACKVER  = $($(BACKEND:.o=)_VER)
--- 10,15 ----
  # Available Backends:
  # - openmosix.o
! #BACKEND  = openmosix.o
! BACKEND  = dummy.o
  # (!)
  BACKVER  = $($(BACKEND:.o=)_VER)
***************
*** 39,45 ****
  OPENMOSIX_CFLAGS += -I$(INCLUDEDIR)
  
  #########
  # Exports
  # (!)
! export FSNAME BACKVER LINUX_CFLAGS OPENMOSIX_CFLAGS
  
--- 40,50 ----
  OPENMOSIX_CFLAGS += -I$(INCLUDEDIR)
  
+ # Dummy
+ # (!)
+ DUMMY_CFLAGS += -I$(INCLUDEDIR)
+ 
  #########
  # Exports
  # (!)
! export FSNAME BACKVER LINUX_CFLAGS OPENMOSIX_CFLAGS DUMMY_CFLAGS
  



From nobody at sheep.berlios.de  Tue Jun 15 19:24:57 2004
From: nobody at sheep.berlios.de (xscript)
Date: Tue, 15 Jun 2004 19:24:57 +0200
Subject: [Taca-cvs] code/frontend/linux linux.c,1.3,1.4
Message-ID: <200406151724.i5FHOvB10844@bat.berlios.de>

Update of /cvsroot/taca/code/frontend/linux
In directory sheep:/tmp/cvs-serv9134/code/frontend/linux

Modified Files:
	linux.c 
Log Message:
OpenMosix definitivament es resisteix

Index: linux.c
===================================================================
RCS file: /cvsroot/taca/code/frontend/linux/linux.c,v
retrieving revision 1.3
retrieving revision 1.4
diff -C2 -d -r1.3 -r1.4
*** linux.c	14 Jun 2004 23:54:49 -0000	1.3
--- linux.c	15 Jun 2004 17:24:55 -0000	1.4
***************
*** 69,73 ****
  
  // use this macro to declare the filesystem structure
! DECLARE_FSTYPE( rkfs, "rkfs", rkfs_read_super, 0 );
  struct inode *rkfs_root_inode;
  
--- 69,73 ----
  
  // use this macro to declare the filesystem structure
! DECLARE_FSTYPE( rkfs, "tacafs", rkfs_read_super, 0 );
  struct inode *rkfs_root_inode;
  



From nobody at sheep.berlios.de  Tue Jun 15 19:24:57 2004
From: nobody at sheep.berlios.de (xscript)
Date: Tue, 15 Jun 2004 19:24:57 +0200
Subject: [Taca-cvs] code/backend/openmosix openmosix.c,1.4,1.5
Message-ID: <200406151724.i5FHOvB10840@bat.berlios.de>

Update of /cvsroot/taca/code/backend/openmosix
In directory sheep:/tmp/cvs-serv9134/code/backend/openmosix

Modified Files:
	openmosix.c 
Log Message:
OpenMosix definitivament es resisteix

Index: openmosix.c
===================================================================
RCS file: /cvsroot/taca/code/backend/openmosix/openmosix.c,v
retrieving revision 1.4
retrieving revision 1.5
diff -C2 -d -r1.4 -r1.5
*** openmosix.c	14 Jun 2004 23:54:48 -0000	1.4
--- openmosix.c	15 Jun 2004 17:24:55 -0000	1.5
***************
*** 3,6 ****
--- 3,7 ----
  #include <linux/mm.h>
  #include <linux/proc_fs.h>
+ #include <linux/list.h>
  
  
***************
*** 27,32 ****
--- 28,39 ----
  	int res = 0;
  
+ 	
+ 	struct nameidata nd;
+ 
+ 
+ 
  	printk (" **mosix.c: num_nodes\n");
  	
+ 	/*
  	// Busquem el proc_dir_entry de /proc/hpc
  	aux = cerca_proc(&proc_root,"hpc");
***************
*** 42,46 ****
  		aux = aux->next;
  	}
! 	
  	printk("  ** mosix.c:  El numero de nodes es: %d\n",res);
  	return res;
--- 49,88 ----
  		aux = aux->next;
  	}
! 	*/
! 
! 	/*
! 	res = path_lookup("/proc/hpc/nodes/3",LOOKUP_DIRECTORY,&nd);
! 	if (res == 0) {
! 		struct list_head *head = &nd.dentry->d_subdirs;
! 		struct dentry *pos;
! 		printk("**%s: Hi ha alguna cosa\n",__FILE__);
! 		for (pos = list_entry((head)->next, typeof(*pos), d_subdirs),
! 				prefetch(pos->d_subdirs.next);
! 				&pos->d_subdirs != (head);
! 				pos = list_entry(pos->d_subdirs.next, typeof(*pos), d_subdirs),
! 				prefetch(pos->d_subdirs.next)) {
! 			printk("**%s: dentry_aux->d_name->name=%s\n",__FILE__,pos->d_name.name);
! 			res++;
! 		}
! 	}
! 	else {
! 		printk("**%s: No hem trobat res\n",__FILE__);
! 	}
! 	*/
! 
! 	res = sys_open("/proc/hpc/nodes", O_DIRECTORY, O_RDONLY);
! 	if (res > 0) {
! 		int tam = 4096;
! 		char buf[tam];
! 		printk("  ** mosix.c: sys_open OK\n");
! 		res = sys_read(res, buf, tam);
! 		printk("  ** mosix.c: sys_read=%d\n",res);
! 		if (res>0)
! 			printk("  ** mosix.c: sys_read->\n%s\n",buf);
! 	}
! 	else {
! 		printk("  ** mosix.c: sys_open KO\n");
! 	}
! 
  	printk("  ** mosix.c:  El numero de nodes es: %d\n",res);
  	return res;
***************
*** 126,127 ****
--- 168,179 ----
  	return aux;
  }
+ 
+ int path_lookup(const char *path, unsigned flags, struct nameidata *nd)
+ {
+ 	int error = 0;
+ 	if (path_init(path, flags, nd))
+ 		error = path_walk(path, nd);
+ 	return error;
+ }
+ 
+ 



From nobody at sheep.berlios.de  Tue Jun 15 19:25:43 2004
From: nobody at sheep.berlios.de (xscript)
Date: Tue, 15 Jun 2004 19:25:43 +0200
Subject: [Taca-cvs] code/backend/dummy dummy.c,NONE,1.1 Makefile,NONE,1.1
Message-ID: <200406151725.i5FHPhB10878@bat.berlios.de>

Update of /cvsroot/taca/code/backend/dummy
In directory sheep:/tmp/cvs-serv9157/code/backend/dummy

Added Files:
	dummy.c Makefile 
Log Message:
Afegit backend dummy

--- NEW FILE: dummy.c ---

#include "backend.h"
#include <linux/mm.h>


//struct cluster_t clus = {.nom = "123",
//			 .next = NULL};
/*
struct node_t n3 = {	.nom = "n3",
			.next = NULL};
struct node_t n2 = {	.nom = "n2",
			.next = &n3 };
struct node_t n1 = {	.nom = "n1",
			.next = &n2};

struct proces_t p3 = {	.nom = "proc3",
			.next = NULL};

struct proces_t p2 = {	.nom = "proc2",
			.next = &p3};
struct proces_t p1 = {	.nom = "proc1",
			.next = &p2};

*/			
int num_clusters() 
{
	return 1;
}

int llistar_clusters (struct cluster_t *llista)
{
	//llista = (struct cluster_t *)kmalloc(sizeof(struct cluster_t) ,GFP_KERNEL);	
	llista->nom = "c1" ;
	llista->next = NULL;
	return 0;
}

int num_nodes (struct cluster_t *cluster_id)
{
	return 3;
}

int llistar_nodes (struct cluster_t *cluster_id, struct node_t *llista)
{
	llista[0].nom = "n0";
	llista[0].next = &llista[1];
	llista[1].nom = "n1";
	llista[1].next = &llista[2];
	llista[2].nom = "n2";
	llista[2].next = NULL;

	return 0;
}

int num_procs (struct cluster_t *cluster_id, struct node_t *node_id) 
{
	return 3;
}

int llistar_procs (struct cluster_t *cluster_id, struct node_t *node_id, struct proces_t *llista)
{
	llista[0].nom = "p0";
	llista[0].next = &llista[1];
	llista[1].nom = "p1";
	llista[1].next = &llista[2];
	llista[2].nom = "p2";
	llista[2].next = NULL;

	return 0;
}


//int migrar (struct proces_t  *proces, struct node_t *node_desti);

/* El node pot rebre procs. nous ? */
//int node_bloquejat_rebre (struct node_t *node);

/* El node pot enviar procs. nous ? */
//int node_bloquejat_enviar (struct node_t *node);

/* El proces no es pot migrar */
//int proces_bloquejat (struct proces_t *proc);


--- NEW FILE: Makefile ---

CFLAGS += $(DUMMY_CFLAGS)

all: dummy.o
	cp dummy.o $(TOPDIR)/backend.o	

clean:
	rm -f dummy.o




From nobody at sheep.berlios.de  Tue Jun 15 19:27:49 2004
From: nobody at sheep.berlios.de (xscript)
Date: Tue, 15 Jun 2004 19:27:49 +0200
Subject: [Taca-cvs] doc 02.tex,1.4,1.5
Message-ID: <200406151727.i5FHRnB10915@bat.berlios.de>

Update of /cvsroot/taca/doc
In directory sheep:/tmp/cvs-serv9181/doc

Modified Files:
	02.tex 
Log Message:
Informacio sobre /proc

Index: 02.tex
===================================================================
RCS file: /cvsroot/taca/doc/02.tex,v
retrieving revision 1.4
retrieving revision 1.5
diff -C2 -d -r1.4 -r1.5
*** 02.tex	8 Jun 2004 21:55:43 -0000	1.4
--- 02.tex	15 Jun 2004 17:27:47 -0000	1.5
***************
*** 1,173 ****
! \chapter{Conceptes b?sics}
! 
! \section{Clustering}
! 
! \subsection{Introducci?}
! 
! En termes generals un cluster ?s un grup de sistemes independents que treballen
! junts com un sistema ?nic. El client interactua amb un cluster com si f?s un
! servidor ?nic. Les configuracions de cluster s'utilitzen per a tenir
! disponibilitat i escalabilitat:
! 
! \begin{description}
! \item[Disponibilitat:]
! Quan un sistema falla en el cluster, el programari del cluster respon
! distribuint el treball del sistema que ha fallat als sistemes que queden en el
! cluster.
! 
! \item[Escalabilitat:]
! Quan la c?rrega general excedeix les capacitats dels sistemes en el cluster, ?s
! possible afegir sistemes addicionals al mateix.  En l'actualitat, els clients
! que planegen ampliar la capacitat del seu sistema han de considerar servidors
! "high end" costosos que proporcionen espai per a CPUs, controladors i mem?ria
! addicionals. A l'utilitzar la tecnologia de clustering, els clients podran
! afegir gradualment sistemes est?ndars m?s petits, segons sigui necessari, per a
! satisfer els requeriments generals de pot?ncia de processament.
! \end{description}
! 
! 
! \subsection{Diferents implementacions}
! A continuaci? passarem a descriure per sobre algunes de les diferents
! implementacions existents en alguns sistemes operatius, les quals representen
! diferents paradigmes.
! 
! 
! \subsubsection{Linux}
! 
! \begin{itemize}
! \item \textbf{OpenMosix:}
! ?s una imlpementaci? basada en la distribuci? de processos, com a modificaci?
! per al nucli, de forma que el proc?s ?s totalment transparent a l'usuari (al
! programador* de l'aplicaci?), cosa que fa molt m?s portables els programes a
! d'altres sistemes, utilitzin o no OpenMosix, i des d'aplicacions no dissenyades
! espec?ficament per a executar-se en un cluster.
! 
! De totes maneres, per tal de poder paral?lelitzar les aplicacions, aquestes han
! d'haver estat ja programades amb diversos processos, ja que OpenMosix no
! paral?lelitza aplicacions, sin? que nom?s distribueix la c?rrega entre els
! diferents nodes.
! 
! Per exemple, si tenim deu nodes al cluster i executem un programa (amb un sol
! proc?s), tardar? el mateix que si nom?s tingu?ssim un node; per? si executem deu
! programes d'aquests, tardaran el que si nom?s n'execut?ssim un, ja que cadascun
! s'executar? en un node.
! 
! Un inconvenient, per?, ?s que tots els nodes del cluster han de tenir exactament
! el mateix nucli (sense compatibilitat de versions ni cap endavant ni cap
! enrere).
! 
! Un altre dels problemes de OpenMosix, ?s que no pot migrar cap proc?s que
! comparteixi mem?ria, de forma que tampoc podr? migrar threads, ja que aquests
! comparteixen mem?ria.
! 
! 
! \item \textbf{Beowulf:}
! \nocite{Beowulf-Home}
! \nocite{Beowulf-Howto}
! Beowulf, segons una de les definicions que hem trobat (doncs alguns diuen que es
! pot dir que un sistema ?s Beowulf nom?s si est? contru?t de la mateixa forma que
! la m?quina original de la NASA; d'altres van cap a l'altre extrem i diuen que ?s
! un sistema Beowulf tot aquell conjunt de m?quines que corren codi paral?lel), ?s
! una arquitectura multi-computador que pot ser utilitzada per a fer computacoins
! en paral?lel. Normalment consisteix en un node servidor i un o m?s nodes
! connectats via Ethernet (o qualsevol altre xarxa), per? el millor de tot ?s que
! es pot constru?r amb hardware "normal", com per exemple qualsevol PC que pugui
! utilitzar Linux, adaptadors est?ndar d'Ethernet i switchos. Beowulf tamb?
! utilitza software "com?", com el sistema operatiu Linux, PVM (Parallel Virtual
! Machine) i MPI (Message Passing Interface). Una de les grans difer?ncies entre
! Beowulf i un cluster de estacions de treball (COW - Cluster of Workstations) ?s
! el fet de qu? Beowulf es comporta com una ?nica m?quina m?s que no mas com un
! conjunt d'estacions de treball. Els nodes de Beowulf es poden pensar com un
! paquet de CPU + mem?ria que es pot connectar al cluster, tal com una CPU o un
! m?dul de mem?ria es poden connectar a una placa base.
! 
! Beowulf no ?s un paquet de software especial, una nova topologia de xarxa o
! l'?ltim hack per al kernel, sin? que ?s una tecnologia de clustering de m?quines
! Linux per a formar un supercomputador paral?lel virtual. Tot i que hi ha varis
! paquets de software com modificacions per al kernel, llibreries PVM i MPI i
! eines de configuraci? que fan l'arquitectura Beowulf m?s r?pida, m?s f?cil de
! configurar i molt m?s usable, un pot constru?r una m?quina de la classe Beowulf
! utilitzant distribucions de Linux est?ndars sense cap software addicional.
! Tenint un parell de m?quines linux en xarxa que comparteixen com a m?nim el
! /home a trav?s de NFS i es confien l'una a l'altra per executar shells remotes
! (rsh), es podria dir que es t? una m?quina Beowulf molt simple de dos nodes.
! 
! Aix? doncs, est? clar que una aplicaci?, per a funcionar en una arquitectura
! Beowulf, ha d'haver estat escrita utilitzant llibreries o m?todes
! especialitzats, no transparents a l'usuari, per? ofereix m?s rendiment que, per
! exemple, OpenMosix (tot i que aquest ?ltim ?s totalment transparent a l'usuari).
! 
! De totes maneres,
! 
! 
! \item \textbf{...Altre soft de clustering...}
! \end{itemize}
! 
! \subsubsection{Microkernels (Mach/L4)}
! 
! No existeix cap eina suficientment madura sobre microkernels que ens ofereixi
! tot el que tenim en altres sistemes com Linux. Tot i aix? si que es poden
! trobar alguns projectes d'investigaci? que fan refer?ncia a la construcci? de
! sistemes de clustering sobre microkernels. Hem trobat dos exemples:
! 
! Hurricane Operating System, cl?ster experimental orientat a la investigaci? i
! la recerca. Paper ftp://ftp.cs.toronto.edu/pub/paral?lel/Tumoral \_ Untau \_
! Caboriege \_ USENIX92.ps.Z
! 
! CHORUS/Fusion per SCO Sopen Menystens Software is una implementaci?
! multi-servidor per SCO UNIX. Aquest entend SCO Unix amb funcionalitats de
! temps real i clustering.
! 
! 
! \subsubsection{Altres Sistemes Operatius}
! 
! \begin{itemize}
! \item {\textbf{Solaris:}}
! Hem trobat exemples de cl?sters de computaci? constru?ts amb aquest Sistema
! Operatiu, per exemple, el SciClone Cluster Project. El cl?ster est? format
! exclusivament per m?quines Sun per? no donen moltes caracter?stiques del sistema
! operatiu, ni tampoc si han tingut que desenvolupar un afegit per dona suport per
! clustering.  (http://www.compsci.wm.edu/SciClone/introduction/index.html).
! 
! \item {\textbf{MacOSX:}}
! Utilitzant la bibloteca de processament carbonlib m?s un software de clustering
! anomenat pooch (http://daugerresearch.com/pooch/) ?s pot crear un cluster amb
! aquest sistema operatiu. Com passa a Beowulf per Linux, aquest sistema de
! clustering est? basat en l'?s de biblioteques de paral.leliitzaci? i per tant
! els programes s'haur?n d'escriure penssant que s'executen en un cluster no ?s
! transparent a l'usuari/aplicaci?.
! \end{itemize}
! 
! \section{Abstraccions existents en Sistemes de Fitxers}
! 
! \subsection{Translators de Hurd}
! \nocite{Hurd-Translators}
! Els translators s?n servidors de Hurd (SO basat en el micronucli gnuMach, tot i
! que s'est? migrant cap a oskit-Mach i, en un futur, cap a L4) que proporcionen
! la interf?cies b?sica del sistema de fitxers, de manera que es poden insertar
! entre el contingut real d'un fitxer (entenent com a fitxer la representaci?
! corresponent en el sistema de fitxers - inode -, doncs el fitxer real pot estar
! en una altra m?quina o, fins i tot, no ser cap fitxer, sin? la representaci?
! d'una zona de mem?ria) i l'usuari que accedeix al fitxer, de forma que
! \textit{tradueix} les peticions de l'usuari.
! 
! Els translators, a m?s am?s, tenen unes propietats molt interessants, i ?s que
! des del punt de vista del kernel, no s?n m?s que processos d'usuari, de forma
! que els pot executar qualsevol usuari, sense necessitat de tenir permisos de
! superusuari per instal?lar o modificar un translator, l'?nic que fa falta ?s
! tenir drets d'acc?s a l'inode sobre s'uneix el translator. Molts translators no
! requereixen un fitxer per a funcionar, i ?s per aix? que la informaci? sobre
! aquests es guarda a l'inode.
! 
! Els translators s?n responsables de servir totes les operacions del sistema de
! fitxers que fan refer?ncia a l'inode al que s'uneix. Per aix?, al no estar
! restringits al t?pic conjunt d'objectes (fitxer de dispositiu, link, etc.), s?n
! lliures de retornar qualsevol cosa que tingui sentit per al programador.  Un
! exemple podria ser un translator que es comport?s com un directori quan f?s
! accedit per \texttt{cd} o \texttt{ls} per? que al mateix temps es comport?s com
! un fitxer al ser accedit per \texttt{cat}.
! 
! \subsection{/proc de Linux vs. VFS de Linux}
! 
! \subsection{...Altres abstraccions en SFs...}
! 
--- 1,228 ----
! \chapter{Conceptes b?sics}
! 
! \section{Clustering}
! 
! \subsection{Introducci?}
! 
! En termes generals un cluster ?s un grup de sistemes independents que treballen
! junts com un sistema ?nic. El client interactua amb un cluster com si f?s un
! servidor ?nic. Les configuracions de cluster s'utilitzen per a tenir
! disponibilitat i escalabilitat:
! 
! \begin{description}
! \item[Disponibilitat:]
! Quan un sistema falla en el cluster, el programari del cluster respon
! distribuint el treball del sistema que ha fallat als sistemes que queden en el
! cluster.
! 
! \item[Escalabilitat:]
! Quan la c?rrega general excedeix les capacitats dels sistemes en el cluster, ?s
! possible afegir sistemes addicionals al mateix.  En l'actualitat, els clients
! que planegen ampliar la capacitat del seu sistema han de considerar servidors
! "high end" costosos que proporcionen espai per a CPUs, controladors i mem?ria
! addicionals. A l'utilitzar la tecnologia de clustering, els clients podran
! afegir gradualment sistemes est?ndars m?s petits, segons sigui necessari, per a
! satisfer els requeriments generals de pot?ncia de processament.
! \end{description}
! 
! 
! \subsection{Diferents implementacions}
! A continuaci? passarem a descriure per sobre algunes de les diferents
! implementacions existents en alguns sistemes operatius, les quals representen
! diferents paradigmes.
! 
! 
! \subsubsection{Linux}
! 
! \begin{itemize}
! \item \textbf{OpenMosix:}
! ?s una imlpementaci? basada en la distribuci? de processos, com a modificaci?
! per al nucli, de forma que el proc?s ?s totalment transparent a l'usuari (al
! programador* de l'aplicaci?), cosa que fa molt m?s portables els programes a
! d'altres sistemes, utilitzin o no OpenMosix, i des d'aplicacions no dissenyades
! espec?ficament per a executar-se en un cluster.
! 
! De totes maneres, per tal de poder paral?lelitzar les aplicacions, aquestes han
! d'haver estat ja programades amb diversos processos, ja que OpenMosix no
! paral?lelitza aplicacions, sin? que nom?s distribueix la c?rrega entre els
! diferents nodes.
! 
! Per exemple, si tenim deu nodes al cluster i executem un programa (amb un sol
! proc?s), tardar? el mateix que si nom?s tingu?ssim un node; per? si executem deu
! programes d'aquests, tardaran el que si nom?s n'execut?ssim un, ja que cadascun
! s'executar? en un node.
! 
! Un inconvenient, per?, ?s que tots els nodes del cluster han de tenir exactament
! el mateix nucli (sense compatibilitat de versions ni cap endavant ni cap
! enrere).
! 
! Un altre dels problemes de OpenMosix, ?s que no pot migrar cap proc?s que
! comparteixi mem?ria, de forma que tampoc podr? migrar threads, ja que aquests
! comparteixen mem?ria.
! 
! 
! \item \textbf{Beowulf:}
! \nocite{Beowulf-Home}
! \nocite{Beowulf-Howto}
! Beowulf, segons una de les definicions que hem trobat (doncs alguns diuen que es
! pot dir que un sistema ?s Beowulf nom?s si est? contru?t de la mateixa forma que
! la m?quina original de la NASA; d'altres van cap a l'altre extrem i diuen que ?s
! un sistema Beowulf tot aquell conjunt de m?quines que corren codi paral?lel), ?s
! una arquitectura multi-computador que pot ser utilitzada per a fer computacoins
! en paral?lel. Normalment consisteix en un node servidor i un o m?s nodes
! connectats via Ethernet (o qualsevol altre xarxa), per? el millor de tot ?s que
! es pot constru?r amb hardware "normal", com per exemple qualsevol PC que pugui
! utilitzar Linux, adaptadors est?ndar d'Ethernet i switchos. Beowulf tamb?
! utilitza software "com?", com el sistema operatiu Linux, PVM (Parallel Virtual
! Machine) i MPI (Message Passing Interface). Una de les grans difer?ncies entre
! Beowulf i un cluster de estacions de treball (COW - Cluster of Workstations) ?s
! el fet de qu? Beowulf es comporta com una ?nica m?quina m?s que no mas com un
! conjunt d'estacions de treball. Els nodes de Beowulf es poden pensar com un
! paquet de CPU + mem?ria que es pot connectar al cluster, tal com una CPU o un
! m?dul de mem?ria es poden connectar a una placa base.
! 
! Beowulf no ?s un paquet de software especial, una nova topologia de xarxa o
! l'?ltim hack per al kernel, sin? que ?s una tecnologia de clustering de m?quines
! Linux per a formar un supercomputador paral?lel virtual. Tot i que hi ha varis
! paquets de software com modificacions per al kernel, llibreries PVM i MPI i
! eines de configuraci? que fan l'arquitectura Beowulf m?s r?pida, m?s f?cil de
! configurar i molt m?s usable, un pot constru?r una m?quina de la classe Beowulf
! utilitzant distribucions de Linux est?ndars sense cap software addicional.
! Tenint un parell de m?quines linux en xarxa que comparteixen com a m?nim el
! /home a trav?s de NFS i es confien l'una a l'altra per executar shells remotes
! (rsh), es podria dir que es t? una m?quina Beowulf molt simple de dos nodes.
! 
! Aix? doncs, est? clar que una aplicaci?, per a funcionar en una arquitectura
! Beowulf, ha d'haver estat escrita utilitzant llibreries o m?todes
! especialitzats, no transparents a l'usuari, per? ofereix m?s rendiment que, per
! exemple, OpenMosix (tot i que aquest ?ltim ?s totalment transparent a l'usuari).
! 
! De totes maneres,
! 
! 
! \item \textbf{...Altre soft de clustering...}
! \end{itemize}
! 
! \subsubsection{Microkernels (Mach/L4)}
! 
! No existeix cap eina suficientment madura sobre microkernels que ens ofereixi
! tot el que tenim en altres sistemes com Linux. Tot i aix? si que es poden
! trobar alguns projectes d'investigaci? que fan refer?ncia a la construcci? de
! sistemes de clustering sobre microkernels. Hem trobat dos exemples:
! 
! Hurricane Operating System, cl?ster experimental orientat a la investigaci? i
! la recerca. Paper ftp://ftp.cs.toronto.edu/pub/paral?lel/Tumoral \_ Untau \_
! Caboriege \_ USENIX92.ps.Z
! 
! CHORUS/Fusion per SCO Sopen Menystens Software is una implementaci?
! multi-servidor per SCO UNIX. Aquest entend SCO Unix amb funcionalitats de
! temps real i clustering.
! 
! 
! \subsubsection{Altres Sistemes Operatius}
! 
! \begin{itemize}
! \item {\textbf{Solaris:}}
! Hem trobat exemples de cl?sters de computaci? constru?ts amb aquest Sistema
! Operatiu, per exemple, el SciClone Cluster Project. El cl?ster est? format
! exclusivament per m?quines Sun per? no donen moltes caracter?stiques del sistema
! operatiu, ni tampoc si han tingut que desenvolupar un afegit per dona suport per
! clustering.  (http://www.compsci.wm.edu/SciClone/introduction/index.html).
! 
! \item {\textbf{MacOSX:}}
! Utilitzant la bibloteca de processament carbonlib m?s un software de clustering
! anomenat pooch (http://daugerresearch.com/pooch/) ?s pot crear un cluster amb
! aquest sistema operatiu. Com passa a Beowulf per Linux, aquest sistema de
! clustering est? basat en l'?s de biblioteques de paral.leliitzaci? i per tant
! els programes s'haur?n d'escriure penssant que s'executen en un cluster no ?s
! transparent a l'usuari/aplicaci?.
! \end{itemize}
! 
! \section{Abstraccions existents en Sistemes de Fitxers}
! 
! \subsection{Translators de Hurd}
! \nocite{Hurd-Translators}
! Els translators s?n servidors de Hurd (SO basat en el micronucli gnuMach, tot i
! que s'est? migrant cap a oskit-Mach i, en un futur, cap a L4) que proporcionen
! la interf?cies b?sica del sistema de fitxers, de manera que es poden insertar
! entre el contingut real d'un fitxer (entenent com a fitxer la representaci?
! corresponent en el sistema de fitxers - inode -, doncs el fitxer real pot estar
! en una altra m?quina o, fins i tot, no ser cap fitxer, sin? la representaci?
! d'una zona de mem?ria) i l'usuari que accedeix al fitxer, de forma que
! \textit{tradueix} les peticions de l'usuari.
! 
! Els translators, a m?s am?s, tenen unes propietats molt interessants, i ?s que
! des del punt de vista del kernel, no s?n m?s que processos d'usuari, de forma
! que els pot executar qualsevol usuari, sense necessitat de tenir permisos de
! superusuari per instal?lar o modificar un translator, l'?nic que fa falta ?s
! tenir drets d'acc?s a l'inode sobre s'uneix el translator. Molts translators no
! requereixen un fitxer per a funcionar, i ?s per aix? que la informaci? sobre
! aquests es guarda a l'inode.
! 
! Els translators s?n responsables de servir totes les operacions del sistema de
! fitxers que fan refer?ncia a l'inode al que s'uneix. Per aix?, al no estar
! restringits al t?pic conjunt d'objectes (fitxer de dispositiu, link, etc.), s?n
! lliures de retornar qualsevol cosa que tingui sentit per al programador.  Un
! exemple podria ser un translator que es comport?s com un directori quan f?s
! accedit per \texttt{cd} o \texttt{ls} per? que al mateix temps es comport?s com
! un fitxer al ser accedit per \texttt{cat}.
! 
! \subsection{/proc de Linux}
! \subsubsection {Introducci? a \proc}
! Linux mant? una abstracci? de sistema de fitxers virtual anomenada /proc. En diem abstracci?, perqu? realment no ?s ben b? un sistema de fitxers implementat
! sobre VFS com ho poden ser: Ext2, Ext3, ReiserFS, Minix...
! A m?s /proc en podem dir que ?s un pseudo-sistema de fitxers, ja que en realitat cap dels fitxers o directoris que s'hi visualitzen existeixen realment.
! 
! /proc ?s realment un mirall on s'hi veuen reflectides algunes de les esctructures del nucli del sistema operatiu, i per mitj? del qual podem controlar alguns par?metres de seguretat tan f?cilment com resulta interectuar amb sistema de fitxers real.
! 
! 
! \subsubsection {M?s sobre \proc}
! 
! /proc est? disponible en el sistema operatiu Linux quan el nucli es compila amb la opci? CONFIG_PROC_FS=Y. Tamb? haurem de seleccionar la opci? CONFIG_SYSCTL=Y per a poder modificar el valor de determinats par?metres.
! La majoria de distribucions inclouen nuclis compilats amb aquesta opci? i en general ?s aconsellable seleccionar-la en el moment de recompilar el nucli.
! 
! \subsubsection {Com es monta?}
! 
! El pseudo-sistema de fitxers /proc es pot muntar autom?tic en el moment d'iniciar el sistema indicant-ho a /etc/fstab. En el cas que sigui necessari muntar-lo manualment utilitzar?em la seg?ent comanda:
! 
! 	mount -t proc proc /proc 
! 
! ?s aconsellable que /proc sigui muntat autom?ticament al sistema.
! En cas de no disposar del suport per a /proc, alguns programes d'administraci? del sistema (com per exemple el que nosaltres estem desenvolupant) no funcionaran ja que no podrem modificar/accedir en temps d'execuci? a alguns par?metres del nucli del sistema operatiu (molts d'ell de seguretat).
! 
! \subsubsection {Qu? cont? /proc?}
! Dins del directori /proc hi trobem dos tipus b?sics d'informaci?.
! En primer lloc, per a cada proc?s actiu existeix un directori.
! Dins del directori de cada proc?s hi ha diversos fitxers aix? com un subdirectori d'informaci? espec?fica del proc?s (par?metres passats per l?nia de comandes, enlla? al directori actual del proc?s, variables d'entorn dins del context del proc?s, els descriptors de fitxers oberts pel proc?s, mapa i informaci? sobre la utilitzaci? de la mem?ria...).
! 
! Adicionalment, existeixen una s?rie de directoris amb informaci? sobre els diferents m?duls del sistema operatiu. O tal i com veurem en aquest treball, OpenMosix proporciona un subdirectori (hpc) dins de /proc en el qual hi trobarem alguns fitxers que ens seran de gran utilitat per a implementar les funcionalitats que defineixen el nostre projecte.
! 
! Al fitxer proc.txt (disponible al directori de documentaci? de sistemes de fitxers del codi font del nucli de Linux) hi ha informaci? detallada de tot el que podem trobar dins de /proc.
! Un altre document d'inter?s ?s ip-sysctl.txt, disponible al directori de documentaci? sobre treball en xarxa.
! 
! No tots els par?metres existents en /proc s?n modificables directament per l'usuari. De fet, la majoria s?n valors de nom?s lectura i altres s?n molt millor controlar-los per mitj? del nucli amb la utilitzaci? de les divers funcions i eienes existents al sistema.
! 
! 
! \subsubsections {Exemples de directoris}
! /proc/sys/net/ipv4 
! 
! Dins d'aquest directori tenim disponibles una s?rie de fitxers amb els valors i par?metres del protocol IP versi? 4. Es tracta d'una s?rie de valors directament emprats pel nucli del sistema operatiu en les comunicacions TCP/IP basades en el protocol IP versi? 4.
! 
! Per determinar el valor d'algun d'aquests par?metres, l'?nica cosa que hem de fer ?s mirar el seu contingut. Per exemple:
! 
! $cat /proc/sys/net/ipv4/icmp_echo_ignore_all 
! 0 
! 
! Ens mostra que actualment el sistema operatiu t? assignat el valor 0 (desactivat) al par?metre ICMP_ECHO_IGNORE_ALL.
! 
! L'usuari ROOT del sistema t? el privilegi de modificar el valor d'aquesta variable:
! 
! # echo 1 > /proc/sys/net/ipv4/icmp_echo_ignore_all 
! # cat /proc/sys/net/ipv4/icmp_echo_ignore_all 
! 1 
! 
! M?s endavant, als apartats d'implementaci? amb OpenMosix, veurem com tamb? podr?em editar par?metres de fitxers del subdirectori que ofereix per a realitzar algunes de les funcions que ens proporciona (ex: Bloquejar un node per rebre processos remots)
! 
! 
! \subsection{...Altres abstraccions en SFs...}
! 



From nobody at sheep.berlios.de  Wed Jun 16 02:30:55 2004
From: nobody at sheep.berlios.de (xscript)
Date: Wed, 16 Jun 2004 02:30:55 +0200
Subject: [Taca-cvs] doc 00-taca.tex,1.1,1.2 02.tex,1.5,1.6
Message-ID: <200406160030.i5G0UtB17178@bat.berlios.de>

Update of /cvsroot/taca/doc
In directory sheep:/tmp/cvs-serv9637

Modified Files:
	00-taca.tex 02.tex 
Log Message:
Nou text i capc,aleres

Index: 00-taca.tex
===================================================================
RCS file: /cvsroot/taca/doc/00-taca.tex,v
retrieving revision 1.1
retrieving revision 1.2
diff -C2 -d -r1.1 -r1.2
*** 00-taca.tex	6 Jun 2004 21:37:28 -0000	1.1
--- 00-taca.tex	16 Jun 2004 00:30:51 -0000	1.2
***************
*** 7,10 ****
--- 7,11 ----
  \usepackage{graphicx}
  \usepackage[catalan]{babel}
+ \usepackage{fancyhdr}
  
  % Salto de l?nea tras t?tulo de secciones \paragraph
***************
*** 38,41 ****
--- 39,58 ----
  \tableofcontents
  
+ % Cabeceras
+ \pagestyle{fancy}
+ %\fancyhf{} % borrar todos los ajustes
+ % En lo siguiente, fancyhead sirve para configurar la cabecera, fancyfoot para
+ % el pie.
+ % Justificaci?n: C=centered, R=right, L=left, (nada)=LRC
+ % P?gina: O=odd, E=even, (nada)=OE
+ \fancyhead[]{}  % n?mero de cap?tulo
+ \fancyhead[L]{\leftmark}  % n?mero de cap?tulo
+ %\fancyhead[R]{\thepage} % n?mero de p?gina
+ % Modifica el ancho de las l?neas de cabecera y pie
+ \renewcommand{\chaptermark}[1]{
+ 	\markboth{\chaptername\  \thechapter. #1}{}
+ }
+ \renewcommand{\headrulewidth}{0.4pt}
+ 
  \input{01.tex}
  \input{02.tex}
***************
*** 43,46 ****
--- 60,64 ----
  \input{04.tex}
  \input{05.tex}
+ \input{06.tex}
  
  \pagebreak 

Index: 02.tex
===================================================================
RCS file: /cvsroot/taca/doc/02.tex,v
retrieving revision 1.5
retrieving revision 1.6
diff -C2 -d -r1.5 -r1.6
*** 02.tex	15 Jun 2004 17:27:47 -0000	1.5
--- 02.tex	16 Jun 2004 00:30:52 -0000	1.6
***************
*** 1,228 ****
! \chapter{Conceptes b?sics}
! 
! \section{Clustering}
! 
! \subsection{Introducci?}
! 
! En termes generals un cluster ?s un grup de sistemes independents que treballen
! junts com un sistema ?nic. El client interactua amb un cluster com si f?s un
! servidor ?nic. Les configuracions de cluster s'utilitzen per a tenir
! disponibilitat i escalabilitat:
! 
! \begin{description}
! \item[Disponibilitat:]
! Quan un sistema falla en el cluster, el programari del cluster respon
! distribuint el treball del sistema que ha fallat als sistemes que queden en el
! cluster.
! 
! \item[Escalabilitat:]
! Quan la c?rrega general excedeix les capacitats dels sistemes en el cluster, ?s
! possible afegir sistemes addicionals al mateix.  En l'actualitat, els clients
! que planegen ampliar la capacitat del seu sistema han de considerar servidors
! "high end" costosos que proporcionen espai per a CPUs, controladors i mem?ria
! addicionals. A l'utilitzar la tecnologia de clustering, els clients podran
! afegir gradualment sistemes est?ndars m?s petits, segons sigui necessari, per a
! satisfer els requeriments generals de pot?ncia de processament.
! \end{description}
! 
! 
! \subsection{Diferents implementacions}
! A continuaci? passarem a descriure per sobre algunes de les diferents
! implementacions existents en alguns sistemes operatius, les quals representen
! diferents paradigmes.
! 
! 
! \subsubsection{Linux}
! 
! \begin{itemize}
! \item \textbf{OpenMosix:}
! ?s una imlpementaci? basada en la distribuci? de processos, com a modificaci?
! per al nucli, de forma que el proc?s ?s totalment transparent a l'usuari (al
! programador* de l'aplicaci?), cosa que fa molt m?s portables els programes a
! d'altres sistemes, utilitzin o no OpenMosix, i des d'aplicacions no dissenyades
! espec?ficament per a executar-se en un cluster.
! 
! De totes maneres, per tal de poder paral?lelitzar les aplicacions, aquestes han
! d'haver estat ja programades amb diversos processos, ja que OpenMosix no
! paral?lelitza aplicacions, sin? que nom?s distribueix la c?rrega entre els
! diferents nodes.
! 
! Per exemple, si tenim deu nodes al cluster i executem un programa (amb un sol
! proc?s), tardar? el mateix que si nom?s tingu?ssim un node; per? si executem deu
! programes d'aquests, tardaran el que si nom?s n'execut?ssim un, ja que cadascun
! s'executar? en un node.
! 
! Un inconvenient, per?, ?s que tots els nodes del cluster han de tenir exactament
! el mateix nucli (sense compatibilitat de versions ni cap endavant ni cap
! enrere).
! 
! Un altre dels problemes de OpenMosix, ?s que no pot migrar cap proc?s que
! comparteixi mem?ria, de forma que tampoc podr? migrar threads, ja que aquests
! comparteixen mem?ria.
! 
! 
! \item \textbf{Beowulf:}
! \nocite{Beowulf-Home}
! \nocite{Beowulf-Howto}
! Beowulf, segons una de les definicions que hem trobat (doncs alguns diuen que es
! pot dir que un sistema ?s Beowulf nom?s si est? contru?t de la mateixa forma que
! la m?quina original de la NASA; d'altres van cap a l'altre extrem i diuen que ?s
! un sistema Beowulf tot aquell conjunt de m?quines que corren codi paral?lel), ?s
! una arquitectura multi-computador que pot ser utilitzada per a fer computacoins
! en paral?lel. Normalment consisteix en un node servidor i un o m?s nodes
! connectats via Ethernet (o qualsevol altre xarxa), per? el millor de tot ?s que
! es pot constru?r amb hardware "normal", com per exemple qualsevol PC que pugui
! utilitzar Linux, adaptadors est?ndar d'Ethernet i switchos. Beowulf tamb?
! utilitza software "com?", com el sistema operatiu Linux, PVM (Parallel Virtual
! Machine) i MPI (Message Passing Interface). Una de les grans difer?ncies entre
! Beowulf i un cluster de estacions de treball (COW - Cluster of Workstations) ?s
! el fet de qu? Beowulf es comporta com una ?nica m?quina m?s que no mas com un
! conjunt d'estacions de treball. Els nodes de Beowulf es poden pensar com un
! paquet de CPU + mem?ria que es pot connectar al cluster, tal com una CPU o un
! m?dul de mem?ria es poden connectar a una placa base.
! 
! Beowulf no ?s un paquet de software especial, una nova topologia de xarxa o
! l'?ltim hack per al kernel, sin? que ?s una tecnologia de clustering de m?quines
! Linux per a formar un supercomputador paral?lel virtual. Tot i que hi ha varis
! paquets de software com modificacions per al kernel, llibreries PVM i MPI i
! eines de configuraci? que fan l'arquitectura Beowulf m?s r?pida, m?s f?cil de
! configurar i molt m?s usable, un pot constru?r una m?quina de la classe Beowulf
! utilitzant distribucions de Linux est?ndars sense cap software addicional.
! Tenint un parell de m?quines linux en xarxa que comparteixen com a m?nim el
! /home a trav?s de NFS i es confien l'una a l'altra per executar shells remotes
! (rsh), es podria dir que es t? una m?quina Beowulf molt simple de dos nodes.
! 
! Aix? doncs, est? clar que una aplicaci?, per a funcionar en una arquitectura
! Beowulf, ha d'haver estat escrita utilitzant llibreries o m?todes
! especialitzats, no transparents a l'usuari, per? ofereix m?s rendiment que, per
! exemple, OpenMosix (tot i que aquest ?ltim ?s totalment transparent a l'usuari).
! 
! De totes maneres,
! 
! 
! \item \textbf{...Altre soft de clustering...}
! \end{itemize}
! 
! \subsubsection{Microkernels (Mach/L4)}
! 
! No existeix cap eina suficientment madura sobre microkernels que ens ofereixi
! tot el que tenim en altres sistemes com Linux. Tot i aix? si que es poden
! trobar alguns projectes d'investigaci? que fan refer?ncia a la construcci? de
! sistemes de clustering sobre microkernels. Hem trobat dos exemples:
! 
! Hurricane Operating System, cl?ster experimental orientat a la investigaci? i
! la recerca. Paper ftp://ftp.cs.toronto.edu/pub/paral?lel/Tumoral \_ Untau \_
! Caboriege \_ USENIX92.ps.Z
! 
! CHORUS/Fusion per SCO Sopen Menystens Software is una implementaci?
! multi-servidor per SCO UNIX. Aquest entend SCO Unix amb funcionalitats de
! temps real i clustering.
! 
! 
! \subsubsection{Altres Sistemes Operatius}
! 
! \begin{itemize}
! \item {\textbf{Solaris:}}
! Hem trobat exemples de cl?sters de computaci? constru?ts amb aquest Sistema
! Operatiu, per exemple, el SciClone Cluster Project. El cl?ster est? format
! exclusivament per m?quines Sun per? no donen moltes caracter?stiques del sistema
! operatiu, ni tampoc si han tingut que desenvolupar un afegit per dona suport per
! clustering.  (http://www.compsci.wm.edu/SciClone/introduction/index.html).
! 
! \item {\textbf{MacOSX:}}
! Utilitzant la bibloteca de processament carbonlib m?s un software de clustering
! anomenat pooch (http://daugerresearch.com/pooch/) ?s pot crear un cluster amb
! aquest sistema operatiu. Com passa a Beowulf per Linux, aquest sistema de
! clustering est? basat en l'?s de biblioteques de paral.leliitzaci? i per tant
! els programes s'haur?n d'escriure penssant que s'executen en un cluster no ?s
! transparent a l'usuari/aplicaci?.
! \end{itemize}
! 
! \section{Abstraccions existents en Sistemes de Fitxers}
! 
! \subsection{Translators de Hurd}
! \nocite{Hurd-Translators}
! Els translators s?n servidors de Hurd (SO basat en el micronucli gnuMach, tot i
! que s'est? migrant cap a oskit-Mach i, en un futur, cap a L4) que proporcionen
! la interf?cies b?sica del sistema de fitxers, de manera que es poden insertar
! entre el contingut real d'un fitxer (entenent com a fitxer la representaci?
! corresponent en el sistema de fitxers - inode -, doncs el fitxer real pot estar
! en una altra m?quina o, fins i tot, no ser cap fitxer, sin? la representaci?
! d'una zona de mem?ria) i l'usuari que accedeix al fitxer, de forma que
! \textit{tradueix} les peticions de l'usuari.
! 
! Els translators, a m?s am?s, tenen unes propietats molt interessants, i ?s que
! des del punt de vista del kernel, no s?n m?s que processos d'usuari, de forma
! que els pot executar qualsevol usuari, sense necessitat de tenir permisos de
! superusuari per instal?lar o modificar un translator, l'?nic que fa falta ?s
! tenir drets d'acc?s a l'inode sobre s'uneix el translator. Molts translators no
! requereixen un fitxer per a funcionar, i ?s per aix? que la informaci? sobre
! aquests es guarda a l'inode.
! 
! Els translators s?n responsables de servir totes les operacions del sistema de
! fitxers que fan refer?ncia a l'inode al que s'uneix. Per aix?, al no estar
! restringits al t?pic conjunt d'objectes (fitxer de dispositiu, link, etc.), s?n
! lliures de retornar qualsevol cosa que tingui sentit per al programador.  Un
! exemple podria ser un translator que es comport?s com un directori quan f?s
! accedit per \texttt{cd} o \texttt{ls} per? que al mateix temps es comport?s com
! un fitxer al ser accedit per \texttt{cat}.
! 
! \subsection{/proc de Linux}
! \subsubsection {Introducci? a \proc}
! Linux mant? una abstracci? de sistema de fitxers virtual anomenada /proc. En diem abstracci?, perqu? realment no ?s ben b? un sistema de fitxers implementat
! sobre VFS com ho poden ser: Ext2, Ext3, ReiserFS, Minix...
! A m?s /proc en podem dir que ?s un pseudo-sistema de fitxers, ja que en realitat cap dels fitxers o directoris que s'hi visualitzen existeixen realment.
! 
! /proc ?s realment un mirall on s'hi veuen reflectides algunes de les esctructures del nucli del sistema operatiu, i per mitj? del qual podem controlar alguns par?metres de seguretat tan f?cilment com resulta interectuar amb sistema de fitxers real.
! 
! 
! \subsubsection {M?s sobre \proc}
! 
! /proc est? disponible en el sistema operatiu Linux quan el nucli es compila amb la opci? CONFIG_PROC_FS=Y. Tamb? haurem de seleccionar la opci? CONFIG_SYSCTL=Y per a poder modificar el valor de determinats par?metres.
! La majoria de distribucions inclouen nuclis compilats amb aquesta opci? i en general ?s aconsellable seleccionar-la en el moment de recompilar el nucli.
! 
! \subsubsection {Com es monta?}
! 
! El pseudo-sistema de fitxers /proc es pot muntar autom?tic en el moment d'iniciar el sistema indicant-ho a /etc/fstab. En el cas que sigui necessari muntar-lo manualment utilitzar?em la seg?ent comanda:
! 
! 	mount -t proc proc /proc 
! 
! ?s aconsellable que /proc sigui muntat autom?ticament al sistema.
! En cas de no disposar del suport per a /proc, alguns programes d'administraci? del sistema (com per exemple el que nosaltres estem desenvolupant) no funcionaran ja que no podrem modificar/accedir en temps d'execuci? a alguns par?metres del nucli del sistema operatiu (molts d'ell de seguretat).
! 
! \subsubsection {Qu? cont? /proc?}
! Dins del directori /proc hi trobem dos tipus b?sics d'informaci?.
! En primer lloc, per a cada proc?s actiu existeix un directori.
! Dins del directori de cada proc?s hi ha diversos fitxers aix? com un subdirectori d'informaci? espec?fica del proc?s (par?metres passats per l?nia de comandes, enlla? al directori actual del proc?s, variables d'entorn dins del context del proc?s, els descriptors de fitxers oberts pel proc?s, mapa i informaci? sobre la utilitzaci? de la mem?ria...).
! 
! Adicionalment, existeixen una s?rie de directoris amb informaci? sobre els diferents m?duls del sistema operatiu. O tal i com veurem en aquest treball, OpenMosix proporciona un subdirectori (hpc) dins de /proc en el qual hi trobarem alguns fitxers que ens seran de gran utilitat per a implementar les funcionalitats que defineixen el nostre projecte.
! 
! Al fitxer proc.txt (disponible al directori de documentaci? de sistemes de fitxers del codi font del nucli de Linux) hi ha informaci? detallada de tot el que podem trobar dins de /proc.
! Un altre document d'inter?s ?s ip-sysctl.txt, disponible al directori de documentaci? sobre treball en xarxa.
! 
! No tots els par?metres existents en /proc s?n modificables directament per l'usuari. De fet, la majoria s?n valors de nom?s lectura i altres s?n molt millor controlar-los per mitj? del nucli amb la utilitzaci? de les divers funcions i eienes existents al sistema.
! 
! 
! \subsubsections {Exemples de directoris}
! /proc/sys/net/ipv4 
! 
! Dins d'aquest directori tenim disponibles una s?rie de fitxers amb els valors i par?metres del protocol IP versi? 4. Es tracta d'una s?rie de valors directament emprats pel nucli del sistema operatiu en les comunicacions TCP/IP basades en el protocol IP versi? 4.
! 
! Per determinar el valor d'algun d'aquests par?metres, l'?nica cosa que hem de fer ?s mirar el seu contingut. Per exemple:
! 
! $cat /proc/sys/net/ipv4/icmp_echo_ignore_all 
! 0 
! 
! Ens mostra que actualment el sistema operatiu t? assignat el valor 0 (desactivat) al par?metre ICMP_ECHO_IGNORE_ALL.
! 
! L'usuari ROOT del sistema t? el privilegi de modificar el valor d'aquesta variable:
! 
! # echo 1 > /proc/sys/net/ipv4/icmp_echo_ignore_all 
! # cat /proc/sys/net/ipv4/icmp_echo_ignore_all 
! 1 
! 
! M?s endavant, als apartats d'implementaci? amb OpenMosix, veurem com tamb? podr?em editar par?metres de fitxers del subdirectori que ofereix per a realitzar algunes de les funcions que ens proporciona (ex: Bloquejar un node per rebre processos remots)
! 
! 
! \subsection{...Altres abstraccions en SFs...}
! 
--- 1,280 ----
! \chapter{Conceptes b?sics}
! 
! \section{Clustering}
! 
! \subsection{Introducci?}
! 
! En termes generals un cluster ?s un grup de sistemes independents que treballen
! junts com un sistema ?nic. El client interactua amb un cluster com si f?s un
! servidor ?nic. Les configuracions de cluster s'utilitzen per a tenir
! disponibilitat i escalabilitat:
! 
! \begin{description}
! \item[Disponibilitat:]
! Quan un sistema falla en el cluster, el programari del cluster respon
! distribuint el treball del sistema que ha fallat als sistemes que queden en el
! cluster.
! 
! \item[Escalabilitat:]
! Quan la c?rrega general excedeix les capacitats dels sistemes en el cluster, ?s
! possible afegir sistemes addicionals al mateix.  En l'actualitat, els clients
! que planegen ampliar la capacitat del seu sistema han de considerar servidors
! "high end" costosos que proporcionen espai per a CPUs, controladors i mem?ria
! addicionals. A l'utilitzar la tecnologia de clustering, els clients podran
! afegir gradualment sistemes est?ndars m?s petits, segons sigui necessari, per a
! satisfer els requeriments generals de pot?ncia de processament.
! \end{description}
! 
! 
! \subsection{Diferents implementacions}
! A continuaci? passarem a descriure per sobre algunes de les diferents
! implementacions existents en alguns sistemes operatius, les quals representen
! diferents paradigmes.
! 
! 
! \subsubsection{Linux}
! 
! \begin{itemize}
! \item \textbf{OpenMosix:}
! ?s una imlpementaci? basada en la distribuci? de processos, com a modificaci?
! per al nucli, de forma que el proc?s ?s totalment transparent a l'usuari (al
! programador* de l'aplicaci?), cosa que fa molt m?s portables els programes a
! d'altres sistemes, utilitzin o no OpenMosix, i des d'aplicacions no dissenyades
! espec?ficament per a executar-se en un cluster.
! 
! De totes maneres, per tal de poder paral?lelitzar les aplicacions, aquestes han
! d'haver estat ja programades amb diversos processos, ja que OpenMosix no
! paral?lelitza aplicacions, sin? que nom?s distribueix la c?rrega entre els
! diferents nodes.
! 
! Per exemple, si tenim deu nodes al cluster i executem un programa (amb un sol
! proc?s), tardar? el mateix que si nom?s tingu?ssim un node; per? si executem deu
! programes d'aquests, tardaran el que si nom?s n'execut?ssim un, ja que cadascun
! s'executar? en un node.
! 
! Un inconvenient, per?, ?s que tots els nodes del cluster han de tenir exactament
! el mateix nucli (sense compatibilitat de versions ni cap endavant ni cap
! enrere).
! 
! Un altre dels problemes de OpenMosix, ?s que no pot migrar cap proc?s que
! comparteixi mem?ria, de forma que tampoc podr? migrar threads, ja que aquests
! comparteixen mem?ria.
! 
! 
! \item \textbf{Beowulf:}
! \nocite{Beowulf-Home}
! \nocite{Beowulf-Howto}
! Beowulf, segons una de les definicions que hem trobat (doncs alguns diuen que es
! pot dir que un sistema ?s Beowulf nom?s si est? contru?t de la mateixa forma que
! la m?quina original de la NASA; d'altres van cap a l'altre extrem i diuen que ?s
! un sistema Beowulf tot aquell conjunt de m?quines que corren codi paral?lel), ?s
! una arquitectura multi-computador que pot ser utilitzada per a fer computacoins
! en paral?lel. Normalment consisteix en un node servidor i un o m?s nodes
! connectats via Ethernet (o qualsevol altre xarxa), per? el millor de tot ?s que
! es pot constru?r amb hardware "normal", com per exemple qualsevol PC que pugui
! utilitzar Linux, adaptadors est?ndar d'Ethernet i switchos. Beowulf tamb?
! utilitza software "com?", com el sistema operatiu Linux, PVM (Parallel Virtual
! Machine) i MPI (Message Passing Interface). Una de les grans difer?ncies entre
! Beowulf i un cluster de estacions de treball (COW - Cluster of Workstations) ?s
! el fet de qu? Beowulf es comporta com una ?nica m?quina m?s que no mas com un
! conjunt d'estacions de treball. Els nodes de Beowulf es poden pensar com un
! paquet de CPU + mem?ria que es pot connectar al cluster, tal com una CPU o un
! m?dul de mem?ria es poden connectar a una placa base.
! 
! Beowulf no ?s un paquet de software especial, una nova topologia de xarxa o
! l'?ltim hack per al kernel, sin? que ?s una tecnologia de clustering de m?quines
! Linux per a formar un supercomputador paral?lel virtual. Tot i que hi ha varis
! paquets de software com modificacions per al kernel, llibreries PVM i MPI i
! eines de configuraci? que fan l'arquitectura Beowulf m?s r?pida, m?s f?cil de
! configurar i molt m?s usable, un pot constru?r una m?quina de la classe Beowulf
! utilitzant distribucions de Linux est?ndars sense cap software addicional.
! Tenint un parell de m?quines linux en xarxa que comparteixen com a m?nim el
! /home a trav?s de NFS i es confien l'una a l'altra per executar shells remotes
! (rsh), es podria dir que es t? una m?quina Beowulf molt simple de dos nodes.
! 
! Aix? doncs, est? clar que una aplicaci?, per a funcionar en una arquitectura
! Beowulf, ha d'haver estat escrita utilitzant llibreries o m?todes
! especialitzats, no transparents a l'usuari, per? ofereix m?s rendiment que, per
! exemple, OpenMosix (tot i que aquest ?ltim ?s totalment transparent a l'usuari).
! 
! De totes maneres,
! 
! 
! \item \textbf{...Altre soft de clustering...}
! \end{itemize}
! 
! 
! \subsubsection{Microkernels (Mach/L4)}
! 
! No existeix cap eina suficientment madura sobre microkernels que ens ofereixi
! tot el que tenim en altres sistemes com Linux. Tot i aix? si que es poden
! trobar alguns projectes d'investigaci? que fan refer?ncia a la construcci? de
! sistemes de clustering sobre microkernels. Hem trobat dos exemples:
! 
! Hurricane Operating System, cl?ster experimental orientat a la investigaci? i
! la recerca. Paper ftp://ftp.cs.toronto.edu/pub/paral?lel/Tumoral \_ Untau \_
! Caboriege \_ USENIX92.ps.Z
! 
! CHORUS/Fusion per SCO Sopen Menystens Software is una implementaci?
! multi-servidor per SCO UNIX. Aquest entend SCO Unix amb funcionalitats de
! temps real i clustering.
! 
! 
! \subsubsection{Altres Sistemes Operatius}
! 
! \begin{itemize}
! \item {\textbf{Solaris:}}
! Hem trobat exemples de cl?sters de computaci? constru?ts amb aquest Sistema
! Operatiu, per exemple, el SciClone Cluster Project. El cl?ster est? format
! exclusivament per m?quines Sun per? no donen moltes caracter?stiques del sistema
! operatiu, ni tampoc si han tingut que desenvolupar un afegit per dona suport per
! clustering.  (http://www.compsci.wm.edu/SciClone/introduction/index.html).
! 
! \item {\textbf{MacOSX:}}
! Utilitzant la bibloteca de processament carbonlib m?s un software de clustering
! anomenat pooch (http://daugerresearch.com/pooch/) ?s pot crear un cluster amb
! aquest sistema operatiu. Com passa a Beowulf per Linux, aquest sistema de
! clustering est? basat en l'?s de biblioteques de paral.leliitzaci? i per tant
! els programes s'haur?n d'escriure penssant que s'executen en un cluster no ?s
! transparent a l'usuari/aplicaci?.
! \end{itemize}
! 
! 
! \section{Abstraccions existents en Sistemes de Fitxers}
! 
! \subsection{Translators de Hurd}
! \nocite{Hurd-Translators}
! Els translators s?n servidors de Hurd (SO basat en el micronucli gnuMach, tot i
! que s'est? migrant cap a oskit-Mach i, en un futur, cap a L4) que proporcionen
! la interf?cies b?sica del sistema de fitxers, de manera que es poden insertar
! entre el contingut real d'un fitxer (entenent com a fitxer la representaci?
! corresponent en el sistema de fitxers - inode -, doncs el fitxer real pot estar
! en una altra m?quina o, fins i tot, no ser cap fitxer, sin? la representaci?
! d'una zona de mem?ria) i l'usuari que accedeix al fitxer, de forma que
! \textit{tradueix} les peticions de l'usuari.
! 
! Els translators, a m?s am?s, tenen unes propietats molt interessants, i ?s que
! des del punt de vista del kernel, no s?n m?s que processos d'usuari, de forma
! que els pot executar qualsevol usuari, sense necessitat de tenir permisos de
! superusuari per instal?lar o modificar un translator, l'?nic que fa falta ?s
! tenir drets d'acc?s a l'inode sobre s'uneix el translator. Molts translators no
! requereixen un fitxer per a funcionar, i ?s per aix? que la informaci? sobre
! aquests es guarda a l'inode.
! 
! Els translators s?n responsables de servir totes les operacions del sistema de
! fitxers que fan refer?ncia a l'inode al que s'uneix. Per aix?, al no estar
! restringits al t?pic conjunt d'objectes (fitxer de dispositiu, link, etc.), s?n
! lliures de retornar qualsevol cosa que tingui sentit per al programador.  Un
! exemple podria ser un translator que es comport?s com un directori quan f?s
! accedit per \texttt{cd} o \texttt{ls} per? que al mateix temps es comport?s com
! un fitxer al ser accedit per \texttt{cat}.
! 
! 
! \subsection{/proc de Linux}
! 
! \subsubsection {Introducci? a /proc}
! 
! Linux mant? una abstracci? de sistema de fitxers virtual anomenada /proc. En
! diem abstracci?, perqu? realment no ?s ben b? un sistema de fitxers implementat
! sobre VFS com ho poden ser: Ext2, Ext3, ReiserFS, Minix...
! A m?s /proc en podem dir que ?s un pseudo-sistema de fitxers, ja que en realitat
! cap dels fitxers o directoris que s'hi visualitzen existeixen realment.
! 
! /proc ?s realment un mirall on s'hi veuen reflectides algunes de les
! esctructures del nucli del sistema operatiu, i per mitj? del qual podem
! controlar alguns par?metres de seguretat tan f?cilment com resulta interectuar
! amb sistema de fitxers real.
! 
! 
! \subsubsection {M?s sobre /proc}
! 
! /proc est? disponible en el sistema operatiu Linux quan el nucli es compila amb
! la opci? CONFIG\_PROC\_FS=Y. Tamb? haurem de seleccionar la opci?
! CONFIG\_SYSCTL=Y per a poder modificar el valor de determinats par?metres.
! La majoria de distribucions inclouen nuclis compilats amb aquesta opci? i en
! general ?s aconsellable seleccionar-la en el moment de recompilar el nucli.
! 
! \subsubsection {Com es munta?}
! 
! El pseudo-sistema de fitxers /proc es pot muntar autom?tic en el moment
! d'iniciar el sistema indicant-ho a /etc/fstab. En el cas que sigui necessari
! muntar-lo manualment utilitzar?em la seg?ent comanda:
! 
! 	mount -t proc proc /proc 
! 
! ?s aconsellable que /proc sigui muntat autom?ticament al sistema.
! En cas de no disposar del suport per a /proc, alguns programes d'administraci?
! del sistema (com per exemple el que nosaltres estem desenvolupant) no
! funcionaran ja que no podrem modificar/accedir en temps d'execuci? a alguns
! par?metres del nucli del sistema operatiu (molts d'ell de seguretat).
! 
! \subsubsection {Qu? cont? /proc?}
! Dins del directori /proc hi trobem dos tipus b?sics d'informaci?.
! En primer lloc, per a cada proc?s actiu existeix un directori.
! Dins del directori de cada proc?s hi ha diversos fitxers aix? com un
! subdirectori d'informaci? espec?fica del proc?s (par?metres passats per l?nia de
! comandes, enlla? al directori actual del proc?s, variables d'entorn dins del
! context del proc?s, els descriptors de fitxers oberts pel proc?s, mapa i
! informaci? sobre la utilitzaci? de la mem?ria...).
! 
! Adicionalment, existeixen una s?rie de directoris amb informaci? sobre els
! diferents m?duls del sistema operatiu. O tal i com veurem en aquest treball,
! OpenMosix proporciona un subdirectori (hpc) dins de /proc en el qual hi trobarem
! alguns fitxers que ens seran de gran utilitat per a implementar les
! funcionalitats que defineixen el nostre projecte.
! 
! Al fitxer proc.txt (disponible al directori de documentaci? de sistemes de
! fitxers del codi font del nucli de Linux) hi ha informaci? detallada de tot el
! que podem trobar dins de /proc.
! Un altre document d'inter?s ?s ip-sysctl.txt, disponible al directori de
! documentaci? sobre treball en xarxa.
! 
! No tots els par?metres existents en /proc s?n modificables directament per
! l'usuari. De fet, la majoria s?n valors de nom?s lectura i altres s?n molt
! millor controlar-los per mitj? del nucli amb la utilitzaci? de les divers
! funcions i eienes existents al sistema.
! 
! 
! \subsubsection {Exemples de directoris}
! /proc/sys/net/ipv4 
! 
! Dins d'aquest directori tenim disponibles una s?rie de fitxers amb els valors i
! par?metres del protocol IP versi? 4. Es tracta d'una s?rie de valors directament
! emprats pel nucli del sistema operatiu en les comunicacions TCP/IP basades en el
! protocol IP versi? 4.
! 
! Per determinar el valor d'algun d'aquests par?metres, l'?nica cosa que hem de
! fer ?s mirar el seu contingut. Per exemple:
! 
! \begin{quotation}
! %\begin{verbatim}
! \$ cat /proc/sys/net/ipv4/icmp\_echo\_ignore\_all 
! \\*
! 0
! %\end{verbatim} 
! \end{quotation} 
! 
! Ens mostra que actualment el sistema operatiu t? assignat el valor 0
! (desactivat) al par?metre ICMP\_ECHO\_IGNORE\_ALL.
! 
! L'usuari \textit{root} del sistema t? el privilegi de modificar el valor
! d'aquesta variable:
! 
! \begin{quotation}
! 	\texttt{
! 		\# echo 1 \textgreater \ /proc/sys/net/ipv4/icmp\_echo\_ignore\_all
! 		\\*
! 		\# cat /proc/sys/net/ipv4/icmp\_echo\_ignore\_all 
! 		\\*
! 		1
! 	}
! \end{quotation} 
! 
! M?s endavant, als apartats d'implementaci? amb OpenMosix, veurem com tamb?
! podr?em editar par?metres de fitxers del subdirectori que ofereix per a
! realitzar algunes de les funcions que ens proporciona (ex: Bloquejar un node per
! rebre processos remots)
! 
! 
! \subsection{...Altres abstraccions en SFs...}
! 



From nobody at sheep.berlios.de  Thu Jun 17 05:31:32 2004
From: nobody at sheep.berlios.de (xscript)
Date: Thu, 17 Jun 2004 05:31:32 +0200
Subject: [Taca-cvs] code/common - New directory
Message-ID: <200406170331.i5H3VWB19657@bat.berlios.de>

Update of /cvsroot/taca/code/common
In directory sheep:/tmp/cvs-serv13910/common

Log Message:
Directory /cvsroot/taca/code/common added to the repository




From nobody at sheep.berlios.de  Thu Jun 17 05:35:44 2004
From: nobody at sheep.berlios.de (xscript)
Date: Thu, 17 Jun 2004 05:35:44 +0200
Subject: [Taca-cvs] code Rules.conf,1.3,1.4
Message-ID: <200406170335.i5H3ZiB19715@bat.berlios.de>

Update of /cvsroot/taca/code
In directory sheep:/tmp/cvs-serv14194

Modified Files:
	Rules.conf 
Log Message:
Initial linux frontend rewrite

Index: Rules.conf
===================================================================
RCS file: /cvsroot/taca/code/Rules.conf,v
retrieving revision 1.3
retrieving revision 1.4
diff -C2 -d -r1.3 -r1.4
*** Rules.conf	15 Jun 2004 17:24:54 -0000	1.3
--- Rules.conf	17 Jun 2004 03:35:42 -0000	1.4
***************
*** 21,27 ****
  
  INCLUDEDIR = /usr/src/linux-openmosix/include
! #INCLUDEDIR = /usr/src/kernel-source-2.4.20/include
  #INCLUDEDIR = /usr/src/linux/include
  
  ########################
  # Frontend specific conf
--- 21,30 ----
  
  INCLUDEDIR = /usr/src/linux-openmosix/include
! #INCLUDEDIR = /usr/src/kernel-source-2.4.22/include
  #INCLUDEDIR = /usr/src/linux/include
  
+ # (!)
+ COMMONDIR = $(shell pwd)/common
+ 
  ########################
  # Frontend specific conf
***************
*** 29,33 ****
  # Linux
  # (!)
! LINUX_CFLAGS += -I$(INCLUDEDIR)
  
  
--- 32,36 ----
  # Linux
  # (!)
! LINUX_CFLAGS += -I$(INCLUDEDIR) -I$(COMMONDIR)
  
  



From nobody at sheep.berlios.de  Thu Jun 17 05:35:43 2004
From: nobody at sheep.berlios.de (xscript)
Date: Thu, 17 Jun 2004 05:35:43 +0200
Subject: [Taca-cvs] code/common linux_debug.h,NONE,1.1
Message-ID: <200406170335.i5H3ZhB19708@bat.berlios.de>

Update of /cvsroot/taca/code/common
In directory sheep:/tmp/cvs-serv14194/common

Added Files:
	linux_debug.h 
Log Message:
Initial linux frontend rewrite

--- NEW FILE: linux_debug.h ---
/*
 * linux_debug.h
 *
 * Funcions de debug per a Linux
 */

#ifndef _linux_debug_h_
#define _linux_debug_h_

#define DEBUG_FLAG KERN_DEBUG

#ifdef DEBUG
#define dprint(msg, args...)			\
	do { printk(DEBUG_FLAG "%s.%d:%s: \n\t"msg,__FILE_,__LINE__,__FUNCTION__,##args); } while (0)
#else
#define dprint(msg, args...)			\
	do { ; } while (0)
#endif

#endif




From nobody at sheep.berlios.de  Thu Jun 17 05:35:44 2004
From: nobody at sheep.berlios.de (xscript)
Date: Thu, 17 Jun 2004 05:35:44 +0200
Subject: [Taca-cvs] code/frontend/linux linux_common.c,NONE,1.1 linux_common.h,NONE,1.1 root.c,NONE,1.1 Makefile,1.1,1.2
Message-ID: <200406170335.i5H3ZiB19711@bat.berlios.de>

Update of /cvsroot/taca/code/frontend/linux
In directory sheep:/tmp/cvs-serv14194/frontend/linux

Modified Files:
	Makefile 
Added Files:
	linux_common.c linux_common.h root.c 
Log Message:
Initial linux frontend rewrite

--- NEW FILE: linux_common.c ---
/*
 * linux_common.c
 *
 * Operacions comunes a tothom en el VFS de linux
 */

#include <linux/fs.h>
#include <linux/pagemap.h>
#include <linux/dcache.h>


/**
 * tacafs_make_inode - Crea un inode
 *
 * Crea un inode o retorna NULL en cas de no poder.
 **/
static struct inode *tacafs_make_inode (struct super_block *sb, int mode,
	struct inode_operations *iops, struct file_operations *fops)
{
    struct inode *ret = new_inode(sb);

    if (ret) {
	ret->i_mode = mode;
	ret->i_uid = ret->i_gid = 0;
	ret->i_blksize = PAGE_CACHE_SIZE;
	ret->i_blocks = 0;
	ret->i_atime = ret->i_mtime = ret->i_ctime = CURRENT_TIME;
	ret->i_op = iops;
	ret->i_fop = fops;
    }
    return ret;
}


/**
 * tacafs_create_file - Crea un fitxer i el posa a la dentry cache
 *
 * Crea el dentry i inode corresponents a un fitxer en un directori i els posa
 * a la dentry cache per a un acces mes rapid.
 **/
static struct dentry *tacafs_create_file (struct super_block *sb, int mode,
	struct inode_operations *iops, struct file_operations *fops,
	struct dentry *dir, const char *name)
{
    struct dentry *dentry;
    struct inode *inode;
    struct qstr qname;

    /*
     * Versio amb hash del nom per anar a la dentry cache
     */
    qname.name = name;
    qname.len = strlen (name);
    qname.hash = full_name_hash(name, qname.len);
    /*
     * Creem el dentry i l'inode que hi associem
     */
    dentry = d_alloc(dir, &qname);
    if (!dentry)
	goto out;
    inode = tacafs_make_inode(sb, S_IFREG | mode, iops, fops);
    if (!inode)
	goto out_dput;
    //inode->u.generic_ip = dades;
    /*
     * Ho posem tot a la dentry cache
     */
    d_add(dentry, inode);
    return dentry;
    /*
     *  Alguna cosa no ha anat be
     */
out_dput:
    dput(dentry);
out:
    return 0;
}


/*
 * Buscar les dades. Cas trivial, si el dentry no existia ja a la dentry
 * cache, es un dentry negatiu.
 */
struct dentry *simple_lookup (struct inode *dir, struct dentry *dentry)
{
    if (dentry->d_name.len > NAME_MAX)
	return ERR_PTR(-ENAMETOOLONG);
    d_add(dentry, NULL);
    return NULL;
}

struct inode_operations simple_dir_inode_operations = {
    lookup: simple_lookup
};


/**
 * tacafs_create_dir - Crea un directori i el posa a la dentry cache
 * @iops: si es NULL, utilitza les funcions per defecte que miren a la dentry
 *        cache
 * @fops: si es NULL, utilitza les funcions per defecte que miren a la dentry
 *        cache
 * 
 * Igual que amb un fitxer, crea el dentry, inode i ho posa a la dentry cache.
 **/
static struct dentry *tacafs_create_dir (struct super_block *sb, int mode,
	struct inode_operations *iops, struct file_operations *fops,
	struct dentry *parent, const char *name)
{
    struct dentry *dentry;
    struct inode *inode;
    struct qstr qname;

    qname.name = name;
    qname.len = strlen (name);
    qname.hash = full_name_hash(name, qname.len);
    dentry = d_alloc(parent, &qname);
    if (! dentry)
	goto out;

    inode = tacafs_make_inode(sb, S_IFDIR | 0644,
	    iops == NULL ? &simple_dir_inode_operations : iops,
	    fops == NULL ? &dcache_dir_ops : fops);
    if (! inode)
	goto out_dput;
    d_add(dentry, inode);
    return dentry;

out_dput:
    dput(dentry);
out:
    return 0;
}


--- NEW FILE: linux_common.h ---
/*
 * linux_common.h
 *
 * Operacions comunes a tothom en el VFS de linux
 */

#ifndef _linux_common_h_
#define _linux_common_h_

struct inode *tacafs_make_inode (struct super_block *, int,
	struct inode_operations *, struct file_operations *);
static struct dentry *tacafs_create_file (struct super_block *, int,
	struct inode_operations *, struct file_operations *, struct dentry *,
	const char *);
static struct dentry *tacafs_create_dir (struct super_block *, int,
	struct inode_operations *, struct file_operations *, struct dentry *,
	const char *);

extern struct inode_operations simple_dir_inode_operations;

#endif


--- NEW FILE: root.c ---
/*
 * root.c
 *
 * Arrel del nostre sistema de fitxers
 */

#include <linux/module.h>
#include <linux/fs.h>
#include <linux/sched.h>

#include <linux_debug.h>

#include "linux_common.h"

#define TACAFS_MAGIC 0x20040617


/*
 * Funcions
 */
static struct super_block *tacafs_read_super (struct super_block *, void *, int);
void tacafs_s_readinode (struct inode *);
int tacafs_s_statfs (struct super_block *, struct statfs *);
struct dentry *tacafs_i_lookup (struct inode *, struct dentry *);
int tacafs_f_readdir (struct file *, void *, filldir_t);

/*
 * Estructures
 */

/* declaracio del file_system_type */
DECLARE_FSTYPE (tacafs_type, "tacafs", tacafs_read_super, 0);
struct inode *tacafs_root_inode;

/* numeros d'inode */
enum {
    TACAFS_ROOT_INO = 1
};

static struct super_operations tacafs_sops = {
    read_inode: tacafs_s_readinode,
    statfs: tacafs_s_statfs
    //  put_inode: tacafs_s_putinode, // inode fora de la cache
};

static struct inode_operations tacafs_root_iops = {
    lookup: tacafs_i_lookup
};

static struct file_operations tacafs_root_fops = {
    read   : generic_read_dir,
    readdir: tacafs_f_readdir
};



/*
 * Operacions del sistema de fitxers
 */

void crea_arbre_estatic (struct super_block *sb)
{
    dprint("creant arbre estatic...\n");
    tacafs_create_dir(sb, S_IRWXUGO, NULL, NULL, sb->s_root, "c1");
}

/**
 * tacafs_read_super - Omple les dades del super bloc
 *
 * Cridat en quan el kernel prova de muntar el SF, ens passa el super block en
 * contruccio per a que l'acabem d'omplir.
 **/
static struct super_block *tacafs_read_super (struct super_block *sb, void *buf, int size)
{
    sb->s_blocksize = 1024;
    sb->s_blocksize_bits = 10;
    sb->s_magic = TACAFS_MAGIC;
    sb->s_op = &tacafs_sops; // operacions del super block
    sb->s_type = &tacafs_type; // file_system_type

    tacafs_root_inode = tacafs_make_inode(sb, S_IFDIR|S_IRWXU,
	    &simple_dir_inode_operations, &dcache_dir_ops);
	    //&tacafs_root_iops, &tacafs_root_fops);
    if (!tacafs_root_inode)
	return ERR_PTR(-ENOMEM);

    if(!(sb->s_root = d_alloc_root(tacafs_root_inode))) { // allocata un dentry
        iput(tacafs_root_inode);
	return ERR_PTR(-ENOMEM);
    }

    crea_arbre_estatic(sb);

    dprint("s'ha retornat un super_block valid\n");
    return sb;
}


/*
 * Operacions del super_block
 */


/**
 * tacafs_s_readinode - Cridat per llegir un inode del SF muntat
 **/
void tacafs_s_readinode (struct inode *inode)
{
    inode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME;
    dprint("\n");
}


/**
 * tacafs_s_statfs - Cridat per obtenir informacio del SF com tamany, etc.
 **/
int tacafs_s_statfs (struct super_block *sb, struct statfs *buf) {
    buf->f_type = TACAFS_MAGIC;
    buf->f_bsize = PAGE_SIZE/sizeof(long);
    buf->f_bfree = 0;
    buf->f_bavail = 0;
    buf->f_ffree = 0;
    buf->f_namelen = NAME_MAX;
    dprint("\n");
    return 0;
}


/*
 * Operacions sobre inodes
 */


/**
 * tacafs_i_lookup - 
 * Aquesta funcio genera el inode pel dentry que es vol mirar 
 * El inode que es vol generar ?s "fill" del parent_inode
 *
 *
 * TODO: comprovar que el directori on es vol entrar ?s correcte
 */

struct dentry *tacafs_i_lookup (struct inode *parent_inode, struct dentry *dentry)
{
  struct inode *file_inode;
  
  dprint("dentry %s\n", dentry->d_name.name);
  
  
  /* Hem de generar el inode per mostrar un clusters (el dentry) 
   * Per tant un directori
   */
  // allocate an inode object
 // if(!(file_inode = iget( parent_inode->i_sb, DIR_INODE_NUMBER)))
      return ERR_PTR(-ENOMEM);
  //file_inode->i_size = file_size;
  file_inode->i_mode = S_IFDIR|S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH;
//  file_inode->i_fop = &tacafs_dir_fops;
//  file_inode->i_op = &tacafs_iops;
  //  add the inode to the dentry object
  d_add(dentry, file_inode);

  dprint(" lookup: inode per cluster %s generat\n", dentry->d_name.name);
  return NULL;
}

//  readdir: tacafs_f_readdir

/*
 * Informacio/codi especific dels moduls de linux
 */

static int __init tacafs_init(void)
{
    	return register_filesystem(&tacafs_type);
}

static void __exit tacafs_exit(void)
{
    	unregister_filesystem(&tacafs_type);
}

module_init(tacafs_init);
module_exit(tacafs_exit);

//MODULE_INFO(tag, info);
MODULE_LICENSE("GPL");
MODULE_AUTHOR("tacafs crew");
MODULE_DESCRIPTION("taca file system module");
//MODULE_PARM_DESC(_parm, desc);


Index: Makefile
===================================================================
RCS file: /cvsroot/taca/code/frontend/linux/Makefile,v
retrieving revision 1.1
retrieving revision 1.2
diff -C2 -d -r1.1 -r1.2
*** Makefile	11 Jun 2004 02:48:48 -0000	1.1
--- Makefile	17 Jun 2004 03:35:41 -0000	1.2
***************
*** 3,7 ****
  
  TARGET = linux.o
! #OBJS   = a.c b.c
  
  all: $(TARGET)
--- 3,7 ----
  
  TARGET = linux.o
! OBJS   = linux_common.o root.o
  
  all: $(TARGET)
***************
*** 9,14 ****
  
  #$(TARGET): $(OBJS)
  
  clean:
! 	rm -f $(TARGET)
  
--- 9,15 ----
  
  #$(TARGET): $(OBJS)
+ #	ld -r -o $@ $(OBJS)
  
  clean:
! 	rm -f $(TARGET) $(OBJS)
  



From nobody at sheep.berlios.de  Thu Jun 17 05:37:33 2004
From: nobody at sheep.berlios.de (xscript)
Date: Thu, 17 Jun 2004 05:37:33 +0200
Subject: [Taca-cvs] code Makefile,1.4,1.5
Message-ID: <200406170337.i5H3bXB19770@bat.berlios.de>

Update of /cvsroot/taca/code
In directory sheep:/tmp/cvs-serv14350

Modified Files:
	Makefile 
Log Message:
cscope tags creation rule

Index: Makefile
===================================================================
RCS file: /cvsroot/taca/code/Makefile,v
retrieving revision 1.4
retrieving revision 1.5
diff -C2 -d -r1.4 -r1.5
*** Makefile	14 Jun 2004 23:48:49 -0000	1.4
--- Makefile	17 Jun 2004 03:37:31 -0000	1.5
***************
*** 28,34 ****
  
  re-run: $(TARGET)
! 	umount $(MNTPOINT)
! 	rmmod $(FSNAME)
  	make run
  
  clean:
--- 28,38 ----
  
  re-run: $(TARGET)
! 	-umount $(MNTPOINT)
! 	-rmmod $(FSNAME)
  	make run
+ 
+ tags:
+ 	find `pwd` -type f -name *.[ch] > cscope.files
+ 	cscope -q -b
  
  clean:



From nobody at sheep.berlios.de  Thu Jun 17 05:37:55 2004
From: nobody at sheep.berlios.de (xscript)
Date: Thu, 17 Jun 2004 05:37:55 +0200
Subject: [Taca-cvs] code/backend Makefile,1.2,1.3
Message-ID: <200406170337.i5H3bsB19775@bat.berlios.de>

Update of /cvsroot/taca/code/backend
In directory sheep:/tmp/cvs-serv14383/backend

Modified Files:
	Makefile 
Log Message:
Minor fixes

Index: Makefile
===================================================================
RCS file: /cvsroot/taca/code/backend/Makefile,v
retrieving revision 1.2
retrieving revision 1.3
diff -C2 -d -r1.2 -r1.3
*** Makefile	11 Jun 2004 03:10:34 -0000	1.2
--- Makefile	17 Jun 2004 03:37:52 -0000	1.3
***************
*** 4,7 ****
  
  clean:
! 	$(foreach dir,$(shell find . -type d -maxdepth 1 -mindepth 1 | grep -v CVS),make -C $(dir) clean)
  
--- 4,7 ----
  
  clean:
! 	$(foreach dir,$(shell find . -type d -maxdepth 1 -mindepth 1 | grep -v CVS),make -C $(dir) clean;)
  



From nobody at sheep.berlios.de  Thu Jun 17 05:37:55 2004
From: nobody at sheep.berlios.de (xscript)
Date: Thu, 17 Jun 2004 05:37:55 +0200
Subject: [Taca-cvs] code/frontend Makefile,1.1,1.2
Message-ID: <200406170337.i5H3btB19778@bat.berlios.de>

Update of /cvsroot/taca/code/frontend
In directory sheep:/tmp/cvs-serv14383/frontend

Modified Files:
	Makefile 
Log Message:
Minor fixes

Index: Makefile
===================================================================
RCS file: /cvsroot/taca/code/frontend/Makefile,v
retrieving revision 1.1
retrieving revision 1.2
diff -C2 -d -r1.1 -r1.2
*** Makefile	11 Jun 2004 02:48:48 -0000	1.1
--- Makefile	17 Jun 2004 03:37:52 -0000	1.2
***************
*** 4,7 ****
  
  clean:
! 	$(foreach dir,$(shell find . -type d -maxdepth 1 -mindepth 1 | grep -v CVS),make -C $(dir) clean)
  
--- 4,7 ----
  
  clean:
! 	$(foreach dir,$(shell find . -type d -maxdepth 1 -mindepth 1 | grep -v CVS),make -C $(dir) clean;)
  



From nobody at sheep.berlios.de  Thu Jun 17 21:24:10 2004
From: nobody at sheep.berlios.de (xscript)
Date: Thu, 17 Jun 2004 21:24:10 +0200
Subject: [Taca-cvs] doc solucio-espai-usuari.dia,NONE,1.1 solucio-espai-usuari.eps,NONE,1.1
Message-ID: <200406171924.i5HJOAB10216@bat.berlios.de>

Update of /cvsroot/taca/doc
In directory sheep:/tmp/cvs-serv26825

Added Files:
	solucio-espai-usuari.dia solucio-espai-usuari.eps 
Log Message:
Documentacio quasi llesta

--- NEW FILE: solucio-espai-usuari.dia ---
(This appears to be a binary file; contents omitted.)

--- NEW FILE: solucio-espai-usuari.eps ---
%!PS-Adobe-2.0 EPSF-2.0
%%Title: /home/dso/taca/doc/solucio-espai-usuari.dia
%%Creator: Dia v0.92.2
%%CreationDate: Thu Jun 17 20:09:59 2004
%%For: dso
%%Orientation: Portrait
%%Magnification: 1.0000
%%BoundingBox: 0 0 736 637
%%BeginSetup
%%EndSetup
%%EndComments
%%BeginProlog
[ /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
/.notdef /.notdef /space /exclam /quotedbl /numbersign /dollar /percent /ampersand /quoteright
/parenleft /parenright /asterisk /plus /comma /hyphen /period /slash /zero /one
/two /three /four /five /six /seven /eight /nine /colon /semicolon
/less /equal /greater /question /at /A /B /C /D /E
/F /G /H /I /J /K /L /M /N /O
/P /Q /R /S /T /U /V /W /X /Y
/Z /bracketleft /backslash /bracketright /asciicircum /underscore /quoteleft /a /b /c
/d /e /f /g /h /i /j /k /l /m
/n /o /p /q /r /s /t /u /v /w
/x /y /z /braceleft /bar /braceright /asciitilde /.notdef /.notdef /.notdef
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
/space /exclamdown /cent /sterling /currency /yen /brokenbar /section /dieresis /copyright
/ordfeminine /guillemotleft /logicalnot /hyphen /registered /macron /degree /plusminus /twosuperior /threesuperior
/acute /mu /paragraph /periodcentered /cedilla /onesuperior /ordmasculine /guillemotright /onequarter /onehalf
/threequarters /questiondown /Agrave /Aacute /Acircumflex /Atilde /Adieresis /Aring /AE /Ccedilla
/Egrave /Eacute /Ecircumflex /Edieresis /Igrave /Iacute /Icircumflex /Idieresis /Eth /Ntilde
/Ograve /Oacute /Ocircumflex /Otilde /Odieresis /multiply /Oslash /Ugrave /Uacute /Ucircumflex
/Udieresis /Yacute /Thorn /germandbls /agrave /aacute /acircumflex /atilde /adieresis /aring
/ae /ccedilla /egrave /eacute /ecircumflex /edieresis /igrave /iacute /icircumflex /idieresis
/eth /ntilde /ograve /oacute /ocircumflex /otilde /odieresis /divide /oslash /ugrave
/uacute /ucircumflex /udieresis /yacute /thorn /ydieresis] /isolatin1encoding exch def
/cp {closepath} bind def
/c {curveto} bind def
/f {fill} bind def
/a {arc} bind def
/ef {eofill} bind def
/ex {exch} bind def
/gr {grestore} bind def
/gs {gsave} bind def
/sa {save} bind def
/rs {restore} bind def
/l {lineto} bind def
/m {moveto} bind def
/rm {rmoveto} bind def
/n {newpath} bind def
/s {stroke} bind def
/sh {show} bind def
/slc {setlinecap} bind def
/slj {setlinejoin} bind def
/slw {setlinewidth} bind def
/srgb {setrgbcolor} bind def
/rot {rotate} bind def
/sc {scale} bind def
/sd {setdash} bind def
/ff {findfont} bind def
/sf {setfont} bind def
/scf {scalefont} bind def
/sw {stringwidth pop} bind def
/tr {translate} bind def

/ellipsedict 8 dict def
ellipsedict /mtrx matrix put
/ellipse
{ ellipsedict begin
   /endangle exch def
   /startangle exch def
   /yrad exch def
   /xrad exch def
   /y exch def
   /x exch def   /savematrix mtrx currentmatrix def
   x y tr xrad yrad sc
   0 0 1 startangle endangle arc
   savematrix setmatrix
   end
} def

/mergeprocs {
dup length
3 -1 roll
dup
length
dup
5 1 roll
3 -1 roll
add
array cvx
dup
3 -1 roll
0 exch
putinterval
dup
4 2 roll
putinterval
} bind def
/Times-Roman-latin1
    /Times-Roman findfont
    dup length dict begin
	{1 index /FID ne {def} {pop pop} ifelse} forall
	/Encoding isolatin1encoding def
    currentdict end
definefont pop
/Times-Italic-latin1
    /Times-Italic findfont
    dup length dict begin
	{1 index /FID ne {def} {pop pop} ifelse} forall
	/Encoding isolatin1encoding def
    currentdict end
definefont pop
/Times-Bold-latin1
    /Times-Bold findfont
    dup length dict begin
	{1 index /FID ne {def} {pop pop} ifelse} forall
	/Encoding isolatin1encoding def
    currentdict end
definefont pop
/Times-BoldItalic-latin1
    /Times-BoldItalic findfont
    dup length dict begin
	{1 index /FID ne {def} {pop pop} ifelse} forall
	/Encoding isolatin1encoding def
    currentdict end
definefont pop
/AvantGarde-Book-latin1
    /AvantGarde-Book findfont
    dup length dict begin
	{1 index /FID ne {def} {pop pop} ifelse} forall
	/Encoding isolatin1encoding def
    currentdict end
definefont pop
/AvantGarde-BookOblique-latin1
    /AvantGarde-BookOblique findfont
    dup length dict begin
	{1 index /FID ne {def} {pop pop} ifelse} forall
	/Encoding isolatin1encoding def
    currentdict end
definefont pop
/AvantGarde-Demi-latin1
    /AvantGarde-Demi findfont
    dup length dict begin
	{1 index /FID ne {def} {pop pop} ifelse} forall
	/Encoding isolatin1encoding def
    currentdict end
definefont pop
/AvantGarde-DemiOblique-latin1
    /AvantGarde-DemiOblique findfont
    dup length dict begin
	{1 index /FID ne {def} {pop pop} ifelse} forall
	/Encoding isolatin1encoding def
    currentdict end
definefont pop
/Bookman-Light-latin1
    /Bookman-Light findfont
    dup length dict begin
	{1 index /FID ne {def} {pop pop} ifelse} forall
	/Encoding isolatin1encoding def
    currentdict end
definefont pop
/Bookman-LightItalic-latin1
    /Bookman-LightItalic findfont
    dup length dict begin
	{1 index /FID ne {def} {pop pop} ifelse} forall
	/Encoding isolatin1encoding def
    currentdict end
definefont pop
/Bookman-Demi-latin1
    /Bookman-Demi findfont
    dup length dict begin
	{1 index /FID ne {def} {pop pop} ifelse} forall
	/Encoding isolatin1encoding def
    currentdict end
definefont pop
/Bookman-DemiItalic-latin1
    /Bookman-DemiItalic findfont
    dup length dict begin
	{1 index /FID ne {def} {pop pop} ifelse} forall
	/Encoding isolatin1encoding def
    currentdict end
definefont pop
/Courier-latin1
    /Courier findfont
    dup length dict begin
	{1 index /FID ne {def} {pop pop} ifelse} forall
	/Encoding isolatin1encoding def
    currentdict end
definefont pop
/Courier-Oblique-latin1
    /Courier-Oblique findfont
    dup length dict begin
	{1 index /FID ne {def} {pop pop} ifelse} forall
	/Encoding isolatin1encoding def
    currentdict end
definefont pop
/Courier-Bold-latin1
    /Courier-Bold findfont
    dup length dict begin
	{1 index /FID ne {def} {pop pop} ifelse} forall
	/Encoding isolatin1encoding def
    currentdict end
definefont pop
/Courier-BoldOblique-latin1
    /Courier-BoldOblique findfont
    dup length dict begin
	{1 index /FID ne {def} {pop pop} ifelse} forall
	/Encoding isolatin1encoding def
    currentdict end
definefont pop
/Helvetica-latin1
    /Helvetica findfont
    dup length dict begin
	{1 index /FID ne {def} {pop pop} ifelse} forall
	/Encoding isolatin1encoding def
    currentdict end
definefont pop
/Helvetica-Oblique-latin1
    /Helvetica-Oblique findfont
    dup length dict begin
	{1 index /FID ne {def} {pop pop} ifelse} forall
	/Encoding isolatin1encoding def
    currentdict end
definefont pop
/Helvetica-Bold-latin1
    /Helvetica-Bold findfont
    dup length dict begin
	{1 index /FID ne {def} {pop pop} ifelse} forall
	/Encoding isolatin1encoding def
    currentdict end
definefont pop
/Helvetica-BoldOblique-latin1
    /Helvetica-BoldOblique findfont
    dup length dict begin
	{1 index /FID ne {def} {pop pop} ifelse} forall
	/Encoding isolatin1encoding def
    currentdict end
definefont pop
/Helvetica-Narrow-latin1
    /Helvetica-Narrow findfont
    dup length dict begin
	{1 index /FID ne {def} {pop pop} ifelse} forall
	/Encoding isolatin1encoding def
    currentdict end
definefont pop
/Helvetica-Narrow-Oblique-latin1
    /Helvetica-Narrow-Oblique findfont
    dup length dict begin
	{1 index /FID ne {def} {pop pop} ifelse} forall
	/Encoding isolatin1encoding def
    currentdict end
definefont pop
/Helvetica-Narrow-Bold-latin1
    /Helvetica-Narrow-Bold findfont
    dup length dict begin
	{1 index /FID ne {def} {pop pop} ifelse} forall
	/Encoding isolatin1encoding def
    currentdict end
definefont pop
/Helvetica-Narrow-BoldOblique-latin1
    /Helvetica-Narrow-BoldOblique findfont
    dup length dict begin
	{1 index /FID ne {def} {pop pop} ifelse} forall
	/Encoding isolatin1encoding def
    currentdict end
definefont pop
/NewCenturySchoolbook-Roman-latin1
    /NewCenturySchoolbook-Roman findfont
    dup length dict begin
	{1 index /FID ne {def} {pop pop} ifelse} forall
	/Encoding isolatin1encoding def
    currentdict end
definefont pop
/NewCenturySchoolbook-Italic-latin1
    /NewCenturySchoolbook-Italic findfont
    dup length dict begin
	{1 index /FID ne {def} {pop pop} ifelse} forall
	/Encoding isolatin1encoding def
    currentdict end
definefont pop
/NewCenturySchoolbook-Bold-latin1
    /NewCenturySchoolbook-Bold findfont
    dup length dict begin
	{1 index /FID ne {def} {pop pop} ifelse} forall
	/Encoding isolatin1encoding def
    currentdict end
definefont pop
/NewCenturySchoolbook-BoldItalic-latin1
    /NewCenturySchoolbook-BoldItalic findfont
    dup length dict begin
	{1 index /FID ne {def} {pop pop} ifelse} forall
	/Encoding isolatin1encoding def
    currentdict end
definefont pop
/Palatino-Roman-latin1
    /Palatino-Roman findfont
    dup length dict begin
	{1 index /FID ne {def} {pop pop} ifelse} forall
	/Encoding isolatin1encoding def
    currentdict end
definefont pop
/Palatino-Italic-latin1
    /Palatino-Italic findfont
    dup length dict begin
	{1 index /FID ne {def} {pop pop} ifelse} forall
	/Encoding isolatin1encoding def
    currentdict end
definefont pop
/Palatino-Bold-latin1
    /Palatino-Bold findfont
    dup length dict begin
	{1 index /FID ne {def} {pop pop} ifelse} forall
	/Encoding isolatin1encoding def
    currentdict end
definefont pop
/Palatino-BoldItalic-latin1
    /Palatino-BoldItalic findfont
    dup length dict begin
	{1 index /FID ne {def} {pop pop} ifelse} forall
	/Encoding isolatin1encoding def
    currentdict end
definefont pop
/Symbol-latin1
    /Symbol findfont
definefont pop
/ZapfChancery-MediumItalic-latin1
    /ZapfChancery-MediumItalic findfont
    dup length dict begin
	{1 index /FID ne {def} {pop pop} ifelse} forall
	/Encoding isolatin1encoding def
    currentdict end
definefont pop
/ZapfDingbats-latin1
    /ZapfDingbats findfont
    dup length dict begin
	{1 index /FID ne {def} {pop pop} ifelse} forall
	/Encoding isolatin1encoding def
    currentdict end
definefont pop
28.346000 -28.346000 scale
-2.949934 -24.315298 translate
%%EndProlog


0.100000 slw
[] 0 sd
[] 0 sd
0.000000 0.000000 0.000000 srgb
n 12.550000 12.525000 7.450000 7.475000 0 360 ellipse cp s
0.100000 slw
[] 0 sd
[] 0 sd
0 slj
n 7.100000 9.050000 m 7.100000 10.950000 l 18.050000 10.950000 l 18.050000 9.050000 l cp s
0.100000 slw
[] 0 sd
[] 0 sd
0 slj
n 7.110000 14.075000 m 7.110000 15.975000 l 18.060000 15.975000 l 18.060000 14.075000 l cp s
/Helvetica-latin1 ff 0.910000 scf sf
(FRONTEND) 10.050000 10.400000 m gs 1 -1 sc sh gr
/Helvetica-latin1 ff 0.910000 scf sf
(BACKEND) 10.400000 15.400000 m gs 1 -1 sc sh gr
0.100000 slw
[] 0 sd
[] 0 sd
0 slc
n 13.450000 11.000000 m 13.450000 13.814739 l s
0.100000 slw
[] 0 sd
0 slj
0 slc
n 13.200000 13.182369 m 13.450000 13.982369 l 13.700000 13.182369 l s
0.100000 slw
[] 0 sd
[] 0 sd
0 slc
n 11.810000 11.210261 m 11.810000 14.025000 l s
0.100000 slw
[] 0 sd
0 slj
0 slc
n 12.060000 11.842631 m 11.810000 11.042631 l 11.560000 11.842631 l s
/Helvetica-latin1 ff 0.700000 scf sf
(petici?) 13.800000 12.650000 m gs 1 -1 sc sh gr
/Helvetica-latin1 ff 0.700000 scf sf
(resposta) 8.300000 12.700000 m gs 1 -1 sc sh gr
0.100000 slw
[] 0 sd
[] 0 sd
0 slc
n 3.100000 4.000000 m 22.100000 3.950000 l s
0.100000 slw
[] 0 sd
[] 0 sd
0 slc
n 3.000000 21.000000 m 22.110125 21.025125 l s
0.100000 slw
[] 0 sd
[] 0 sd
0 slc
n 12.600000 1.900000 m 12.575782 8.826395 l s
0.100000 slw
[] 0 sd
0 slj
0 slc
n 12.178191 8.136804 m 12.575391 8.938197 l 12.978186 8.139601 l s
0.100000 slw
[] 0 sd
[] 0 sd
0 slc
n 12.758927 23.470317 m 23.720162 19.289786 l s
0.100000 slw
[] 0 sd
0 slj
0 slc
n 13.259403 22.851335 m 12.654464 23.510158 l 13.544486 23.598815 l s
0.100000 slw
[] 0 sd
0 slj
0 slc
n 23.219686 19.908768 m 23.824625 19.249944 l 22.934603 19.161287 l s
/Helvetica-latin1 ff 1.120000 scf sf
(KERNEL \(VFS\)) 13.250000 3.450000 m gs 1 -1 sc sh gr
/Helvetica-latin1 ff 1.120000 scf sf
(Sist. Clustering) 3.400000 22.300000 m gs 1 -1 sc sh gr
0.100000 slw
[] 0 sd
[] 0 sd
n 25.904089 17.110103 2.793072 2.969848 0 360 ellipse cp s
/Helvetica-latin1 ff 0.700000 scf sf
(Programa amb) 23.393860 17.021714 m gs 1 -1 sc sh gr
( context propi) 23.393860 18.021714 m gs 1 -1 sc sh gr
0.100000 slw
[] 0 sd
[] 0 sd
0 slc
n 18.283606 15.024432 m 23.593829 15.010954 l s
0.100000 slw
[] 0 sd
0 slj
0 slc
n 18.970785 14.622687 m 18.171803 15.024716 l 18.972816 15.422684 l s
0.100000 slw
[] 0 sd
0 slj
0 slc
n 22.962096 15.262558 m 23.761459 15.010528 l 22.960827 14.762560 l s
showpage



From nobody at sheep.berlios.de  Fri Jun 18 00:47:47 2004
From: nobody at sheep.berlios.de (xscript)
Date: Fri, 18 Jun 2004 00:47:47 +0200
Subject: [Taca-cvs] doc esquema-supcl.dia,1.1,NONE esquema-supcl.eps,1.1,NONE esquema-utilcl.dia,1.2,NONE esquema-utilcl.eps,1.1,NONE
Message-ID: <200406172247.i5HMllB15088@bat.berlios.de>

Update of /cvsroot/taca/doc
In directory sheep:/tmp/cvs-serv31321

Removed Files:
	esquema-supcl.dia esquema-supcl.eps esquema-utilcl.dia 
	esquema-utilcl.eps 
Log Message:
Eliminacio d'imatges velles


--- esquema-supcl.dia DELETED ---

--- esquema-supcl.eps DELETED ---

--- esquema-utilcl.dia DELETED ---

--- esquema-utilcl.eps DELETED ---



From nobody at sheep.berlios.de  Fri Jun 18 00:49:54 2004
From: nobody at sheep.berlios.de (xscript)
Date: Fri, 18 Jun 2004 00:49:54 +0200
Subject: [Taca-cvs] codi Makefile,1.1,NONE generic.h,1.2,NONE inode.c,1.1,NONE linux_tacafs.c,1.1,NONE mosix.c,1.4,NONE rkfs.c,1.3,NONE
Message-ID: <200406172249.i5HMnsB15139@bat.berlios.de>

Update of /cvsroot/taca/codi
In directory sheep:/tmp/cvs-serv31541/codi

Removed Files:
	Makefile generic.h inode.c linux_tacafs.c mosix.c rkfs.c 
Log Message:
Eliminacio del directori de codi vell


--- Makefile DELETED ---

--- generic.h DELETED ---

--- inode.c DELETED ---

--- linux_tacafs.c DELETED ---

--- mosix.c DELETED ---

--- rkfs.c DELETED ---



From nobody at sheep.berlios.de  Sat Jun 19 15:24:17 2004
From: nobody at sheep.berlios.de (albertfc)
Date: Sat, 19 Jun 2004 15:24:17 +0200
Subject: [Taca-cvs] doc 01.tex,1.2,1.3 02.tex,1.7,1.8 03.tex,1.5,1.6 04.tex,1.3,1.4 05.tex,1.2,1.3
Message-ID: <200406191324.i5JDOHB06397@bat.berlios.de>

Update of /cvsroot/taca/doc
In directory sheep:/tmp/cvs-serv4602/doc

Modified Files:
	01.tex 02.tex 03.tex 04.tex 05.tex 
Log Message:
Passat el corrector ortogr?fic
A veure i apreneu a escriu-re amb accents, que no ?s tant dif?cil!!1



Index: 01.tex
===================================================================
RCS file: /cvsroot/taca/doc/01.tex,v
retrieving revision 1.2
retrieving revision 1.3
diff -C2 -d -r1.2 -r1.3
*** 01.tex	17 Jun 2004 19:23:39 -0000	1.2
--- 01.tex	19 Jun 2004 13:24:15 -0000	1.3
***************
*** 14,22 ****
  interf?cie comuna.
  
! Hem anomenat al sistema TACA, que v? de l'angl?s Transparent Architecture for
  Cluster Administration (Arquitectura Transparent per a l'Administraci? de
  Cl?sters).
  
  Tant la documentaci? com la implementaci? es troben disponibles a la p?gina del
! projecte, que es troba a \textit{http://developer.berlios.de/projects/taca}.
  
--- 14,22 ----
  interf?cie comuna.
  
! Hem anomenat al sistema TACA, que ve de l'angl?s Transparent Architecture for
  Cluster Administration (Arquitectura Transparent per a l'Administraci? de
  Cl?sters).
  
  Tant la documentaci? com la implementaci? es troben disponibles a la p?gina del
! projecte, que es troba a \textbf{http://developer.berlios.de/projects/taca}.
  

Index: 02.tex
===================================================================
RCS file: /cvsroot/taca/doc/02.tex,v
retrieving revision 1.7
retrieving revision 1.8
diff -C2 -d -r1.7 -r1.8
*** 02.tex	17 Jun 2004 19:23:39 -0000	1.7
--- 02.tex	19 Jun 2004 13:24:15 -0000	1.8
***************
*** 21,26 ****
  que planegen ampliar la capacitat del seu sistema han de considerar servidors
  "high end" costosos que proporcionen espai per a CPUs, controladors i mem?ria
! addicionals. A l'utilitzar la tecnologia de clustering, els clients podran
! afegir gradualment sistemes est?ndars m?s petits, segons sigui necessari, per a
  satisfer els requeriments generals de pot?ncia de processament.
  \end{description}
--- 21,26 ----
  que planegen ampliar la capacitat del seu sistema han de considerar servidors
  "high end" costosos que proporcionen espai per a CPUs, controladors i mem?ria
! addicionals. Al utilitzar la tecnologia de clustering, els clients podran
! afegir gradualment sistemes est?ndards m?s petits, segons sigui necessari, per a
  satisfer els requeriments generals de pot?ncia de processament.
  \end{description}
***************
*** 37,41 ****
  \begin{itemize}
  \item \textbf{OpenMosix:}
! ?s una imlpementaci? basada en la distribuci? de processos, com a modificaci?
  per al nucli, de forma que el proc?s ?s totalment transparent a l'usuari (al
  programador* de l'aplicaci?), cosa que fa molt m?s portables els programes a
--- 37,41 ----
  \begin{itemize}
  \item \textbf{OpenMosix:}
! ?s una implementaci? basada en la distribuci? de processos, com a modificaci?
  per al nucli, de forma que el proc?s ?s totalment transparent a l'usuari (al
  programador* de l'aplicaci?), cosa que fa molt m?s portables els programes a
***************
*** 66,77 ****
  \nocite{Beowulf-Howto}
  Beowulf, segons una de les definicions que hem trobat (doncs alguns diuen que es
! pot dir que un sistema ?s Beowulf nom?s si est? contru?t de la mateixa forma que
  la m?quina original de la NASA; d'altres van cap a l'altre extrem i diuen que ?s
  un sistema Beowulf tot aquell conjunt de m?quines que corren codi paral?lel), ?s
! una arquitectura multi-computador que pot ser utilitzada per a fer computacoins
  en paral?lel. Normalment consisteix en un node servidor i un o m?s nodes
  connectats via Ethernet (o qualsevol altre xarxa), per? el millor de tot ?s que
! es pot constru?r amb hardware "normal", com per exemple qualsevol PC que pugui
! utilitzar Linux, adaptadors est?ndar d'Ethernet i switchos. Beowulf tamb?
  utilitza software "com?", com el sistema operatiu Linux, PVM (Parallel Virtual
  Machine) i MPI (Message Passing Interface). Una de les grans difer?ncies entre
--- 66,77 ----
  \nocite{Beowulf-Howto}
  Beowulf, segons una de les definicions que hem trobat (doncs alguns diuen que es
! pot dir que un sistema ?s Beowulf nom?s si est? constru?t de la mateixa forma que
  la m?quina original de la NASA; d'altres van cap a l'altre extrem i diuen que ?s
  un sistema Beowulf tot aquell conjunt de m?quines que corren codi paral?lel), ?s
! una arquitectura multi-computador que pot ser utilitzada per a fer computacions
  en paral?lel. Normalment consisteix en un node servidor i un o m?s nodes
  connectats via Ethernet (o qualsevol altre xarxa), per? el millor de tot ?s que
! es pot construir amb hardware "normal", com per exemple qualsevol PC que pugui
! utilitzar Linux, adaptadors est?ndard d'Ethernet i switchos. Beowulf tamb?
  utilitza software "com?", com el sistema operatiu Linux, PVM (Parallel Virtual
  Machine) i MPI (Message Passing Interface). Una de les grans difer?ncies entre
***************
*** 88,92 ****
  eines de configuraci? que fan l'arquitectura Beowulf m?s r?pida, m?s f?cil de
  configurar i molt m?s usable, un pot constru?r una m?quina de la classe Beowulf
! utilitzant distribucions de Linux est?ndars sense cap software addicional.
  Tenint un parell de m?quines linux en xarxa que comparteixen com a m?nim el
  /home a trav?s de NFS i es confien l'una a l'altra per executar shells remotes
--- 88,92 ----
  eines de configuraci? que fan l'arquitectura Beowulf m?s r?pida, m?s f?cil de
  configurar i molt m?s usable, un pot constru?r una m?quina de la classe Beowulf
! utilitzant distribucions de Linux est?ndards sense cap software addicional.
  Tenint un parell de m?quines linux en xarxa que comparteixen com a m?nim el
  /home a trav?s de NFS i es confien l'una a l'altra per executar shells remotes
***************
*** 98,105 ****
  exemple, OpenMosix (tot i que aquest ?ltim ?s totalment transparent a l'usuari).
  
- De totes maneres,
  
  
! \item \textbf{Altre soft de clustering:}
  Tot i buscar per Internet la exist?ncia d'altre software de clustering, no hem trobat res excepte distribucions basades en el software que ja hem comentat.
  \end{itemize}
--- 98,104 ----
  exemple, OpenMosix (tot i que aquest ?ltim ?s totalment transparent a l'usuari).
  
  
  
! \item \textbf{Altre software de clustering:}
  Tot i buscar per Internet la exist?ncia d'altre software de clustering, no hem trobat res excepte distribucions basades en el software que ja hem comentat.
  \end{itemize}
***************
*** 135,140 ****
  anomenat pooch \cite{AltresSO-MacOS} es pot crear un cluster amb
  aquest sistema operatiu. Com passa a Beowulf per Linux, aquest sistema de
! clustering est? basat en l'?s de biblioteques de paral.leliitzaci? i per tant
! els programes s'haur?n d'escriure penssant que s'executen en un cluster no ?s
  transparent a l'usuari/aplicaci?.
  \end{itemize}
--- 134,139 ----
  anomenat pooch \cite{AltresSO-MacOS} es pot crear un cluster amb
  aquest sistema operatiu. Com passa a Beowulf per Linux, aquest sistema de
! clustering est? basat en l'?s de biblioteques de paral?leliitzaci? i per tant
! els programes s'hauran d'escriure pensant que s'executen en un cluster no ?s
  transparent a l'usuari/aplicaci?.
  \end{itemize}
***************
*** 147,151 ****
  Els translators s?n servidors de Hurd (SO basat en el micronucli gnuMach, tot i
  que s'est? migrant cap a oskit-Mach i, en un futur, cap a L4) que proporcionen
! la interf?cies b?sica del sistema de fitxers, de manera que es poden insertar
  entre el contingut real d'un fitxer (entenent com a fitxer la representaci?
  corresponent en el sistema de fitxers - inode -, doncs el fitxer real pot estar
--- 146,150 ----
  Els translators s?n servidors de Hurd (SO basat en el micronucli gnuMach, tot i
  que s'est? migrant cap a oskit-Mach i, en un futur, cap a L4) que proporcionen
! la interf?cies b?sica del sistema de fitxers, de manera que es poden inserir
  entre el contingut real d'un fitxer (entenent com a fitxer la representaci?
  corresponent en el sistema de fitxers - inode -, doncs el fitxer real pot estar
***************
*** 166,170 ****
  restringits al t?pic conjunt d'objectes (fitxer de dispositiu, link, etc.), s?n
  lliures de retornar qualsevol cosa que tingui sentit per al programador.  Un
! exemple podria ser un translator que es comport?s com un directori quan f?s
  accedit per \texttt{cd} o \texttt{ls} per? que al mateix temps es comport?s com
  un fitxer al ser accedit per \texttt{cat}.
--- 165,169 ----
  restringits al t?pic conjunt d'objectes (fitxer de dispositiu, link, etc.), s?n
  lliures de retornar qualsevol cosa que tingui sentit per al programador.  Un
! exemple podria ser un translator que es comport?s com un directori quan fos
  accedit per \texttt{cd} o \texttt{ls} per? que al mateix temps es comport?s com
  un fitxer al ser accedit per \texttt{cat}.
***************
*** 182,187 ****
  
  /proc ?s realment un mirall on s'hi veuen reflectides algunes de les
! esctructures del nucli del sistema operatiu, i per mitj? del qual podem
! controlar alguns par?metres de seguretat tan f?cilment com resulta interectuar
  amb sistema de fitxers real.
  
--- 181,186 ----
  
  /proc ?s realment un mirall on s'hi veuen reflectides algunes de les
! estructures del nucli del sistema operatiu, i per mitj? del qual podem
! controlar alguns par?metres de seguretat tan f?cilment com resulta interactuar
  amb sistema de fitxers real.
  
***************
*** 189,193 ****
  \subsubsection {M?s sobre /proc}
  
! /proc est? disponible en el sistema operatiu Linux quan el nucli es compila amb
  la opci? CONFIG\_PROC\_FS=Y. Tamb? haurem de seleccionar la opci?
  CONFIG\_SYSCTL=Y per a poder modificar el valor de determinats par?metres.
--- 188,192 ----
  \subsubsection {M?s sobre /proc}
  
! /proc est? disponible en el sistema operatiu Linux quan el nucli es compila amb
  la opci? CONFIG\_PROC\_FS=Y. Tamb? haurem de seleccionar la opci?
  CONFIG\_SYSCTL=Y per a poder modificar el valor de determinats par?metres.
***************
*** 235,239 ****
  l'usuari. De fet, la majoria s?n valors de nom?s lectura i altres s?n molt
  millor controlar-los per mitj? del nucli amb la utilitzaci? de les divers
! funcions i eienes existents al sistema.
  
  
--- 234,238 ----
  l'usuari. De fet, la majoria s?n valors de nom?s lectura i altres s?n molt
  millor controlar-los per mitj? del nucli amb la utilitzaci? de les divers
! funcions i eines existents al sistema.
  
  

Index: 03.tex
===================================================================
RCS file: /cvsroot/taca/doc/03.tex,v
retrieving revision 1.5
retrieving revision 1.6
diff -C2 -d -r1.5 -r1.6
*** 03.tex	17 Jun 2004 19:23:39 -0000	1.5
--- 03.tex	19 Jun 2004 13:24:15 -0000	1.6
***************
*** 14,51 ****
  \item Consultar c?rrega del node
  \item Consultar estat de mem?ria
! \item Bloquejar l'arribada de nous processos remots
! \item Bloquejar la migracio de processos locals
! \item Activar/Desactivar la migraci? automatica de processos
! \item Demanar que els processos que ha creat un node i han migrat, tornin  a
  aquest node (come back home)
! \item Expulsar els "processos convidats" a casa
  \item Saber quin identificador te un node
  \item Modificar/Consultar la velocitat d'un node
! \item Consultar informacio de processos (resum de l'estat de processos locals, i
  remots)
  \item Consultar resum de l'estat del node
  \end{itemize}
  
! \subsection {A nivell de proces...}
  \begin{itemize}
! \item Moure processos d'un node a un altre \\
! 	=> Esborrar els fitxers relatius al proces del node origen \\
! 	=> Generar els fitxers relatius al proces al node desti
! \item Bloquejar un proces en un node concret
! \item Crear un nou proces en una maquina (crear un fitxer) \\
! 	=> Generar els fitxers relatius al proces en aquest node.
! \item Matar un proces (esborrar un fitxer) \\
! 	=> Esborrar els fitxers relatius al proces al node on s'esta executant.
! \item Copiar un proces (arrencar una nova execuci? del programa)
! \item Modificar/veure memoria del proces
! \item Consultar la linia de comandes amb la que s'ha executat
! \item Consultar estat del proces
! \item Consultar quants cops s'ha migrat el proces
! \item Consultar on s'esta computant actualment
  \item Consultar quin node el va crear
! \item Saber l'identificador de proces (ID global)
! \item Saber l'identificador local d'un proces (ex: PID)
  \item Consultar resum de us de CPU
! \item Consultar resum de us de Memoria
  \end{itemize}
  
--- 14,51 ----
  \item Consultar c?rrega del node
  \item Consultar estat de mem?ria
! \item Bloquejar l'arribada de nous proc?ssos remots
! \item Bloquejar la migraci? de proc?ssos locals
! \item Activar/Desactivar la migraci? autom?tica de proc?ssos
! \item Demanar que els proc?ssos que ha creat un node i han migrat, tornin  a
  aquest node (come back home)
! \item Expulsar els "proc?ssos convidats" a casa
  \item Saber quin identificador te un node
  \item Modificar/Consultar la velocitat d'un node
! \item Consultar informaci? de proc?ssos (resum de l'estat de proc?ssos locals, i
  remots)
  \item Consultar resum de l'estat del node
  \end{itemize}
  
! \subsection {A nivell de proc?s ...}
  \begin{itemize}
! \item Moure proc?ssos d'un node a un altre \\
! 	=> Esborrar els fitxers relatius al proc?s del node origen \\
! 	=> Generar els fitxers relatius al proc?s al node dest?
! \item Bloquejar un proc?s en un node concret
! \item Crear un nou proc?s en una maquina (crear un fitxer) \\
! 	=> Generar els fitxers relatius al proc?s en aquest node.
! \item Matar un proc?s (esborrar un fitxer) \\
! 	=> Esborrar els fitxers relatius al proc?s al node on s'est? executant.
! \item Copiar un proc?s (arrencar una nova execuci? del programa)
! \item Modificar/veure mem?ria del proc?s
! \item Consultar la l?nia de comandes amb la que s'ha executat
! \item Consultar estat del proc?s
! \item Consultar quants cops s'ha migrat el proc?s
! \item Consultar on s'est? computant actualment
  \item Consultar quin node el va crear
! \item Saber l'identificador de proc?s (ID global)
! \item Saber l'identificador local d'un proc?s (ex: PID)
  \item Consultar resum de us de CPU
! \item Consultar resum de us de Mem?ria
  \end{itemize}
  
***************
*** 57,61 ****
  \subsubsection{OpenMosix}
  
! El software que volem contru?r est? lligat al node on s'executa per la definici?
  de l'arquitectura d'OpenMosix, fem difer?ncia entre node local i nodes remots.
  
--- 57,61 ----
  \subsubsection{OpenMosix}
  
! El software que volem construir est? lligat al node on s'executa per la definici?
  de l'arquitectura d'OpenMosix, fem difer?ncia entre node local i nodes remots.
  
***************
*** 63,71 ****
  troba l'usuari), la resta s?n els nodes remots.
  
! Per aquest motiu, suposarem que tots els processos tenen com a punt d'entrada
  (s'inicia la seva execuci?) en el node local (que ?s la soluci? adoptada en la
  majoria dels centres on s'utilitza OpenMosix).
  
! Fem aquesta suposici? precisament perqu? els processos que tenen un node
  \textit{home} (el node des d'on es llencen) diferent del node local ofereixen
  menys possibilitats d'administraci? i monitoritzaci?.
--- 63,71 ----
  troba l'usuari), la resta s?n els nodes remots.
  
! Per aquest motiu, suposarem que tots els proc?ssos tenen com a punt d'entrada
  (s'inicia la seva execuci?) en el node local (que ?s la soluci? adoptada en la
  majoria dels centres on s'utilitza OpenMosix).
  
! Fem aquesta suposici? precisament perqu? els proc?ssos que tenen un node
  \textit{home} (el node des d'on es llencen) diferent del node local ofereixen
  menys possibilitats d'administraci? i monitoritzaci?.
***************
*** 89,103 ****
  \item Consultar estat de memoria \\
  	Consultant el fitxer /proc/hpc/nodes/\textless opMosix\_ID\textgreater/mem
! \item Bloquejar l'arribada de nous processos remots (tant el node local com els
  altres) \\
  	Consultant el fitxer /proc/hpc/admin/block
! \item Bloquejar la migracio de processos locals \\
  	Bloquejar cada proc?s del node (mirar seg?ent secci?)
! \item Activar/Desactivar la migraci? automatica de processos \\
  	Modificar el fitxer /proc/hpc/admin/stay
! \item Demanar que els processos que ha creat un node i han migrat, tornin  a
  aquest node (come back home) \\
  	Modificar el fitxer /proc/hpc/admin/bring
! \item Expulsar els "processos convidats" a casa \\
  	Modificar el fitxer /proc/hpc/admin/expel
  \item Saber quin identificador t? un node \\
--- 89,103 ----
  \item Consultar estat de memoria \\
  	Consultant el fitxer /proc/hpc/nodes/\textless opMosix\_ID\textgreater/mem
! \item Bloquejar l'arribada de nous proc?ssos remots (tant el node local com els
  altres) \\
  	Consultant el fitxer /proc/hpc/admin/block
! \item Bloquejar la migraci? de proc?ssos locals \\
  	Bloquejar cada proc?s del node (mirar seg?ent secci?)
! \item Activar/Desactivar la migraci? autom?tica de proc?ssos \\
  	Modificar el fitxer /proc/hpc/admin/stay
! \item Demanar que els proc?ssos que ha creat un node i han migrat, tornin  a
  aquest node (come back home) \\
  	Modificar el fitxer /proc/hpc/admin/bring
! \item Expulsar els "proc?ssos convidats" a casa \\
  	Modificar el fitxer /proc/hpc/admin/expel
  \item Saber quin identificador t? un node \\
***************
*** 106,113 ****
  \item Modificar/Consultar la velocitat d'un node \\
  	Consultar el fitxer /proc/hpc/admin/speed
! \item Consultar informacio de processos (resum de l'estat de processos locals, i
  remots) \\
  	Generar un resum consultant la informaci? de cada proc?s del node amb les
! operacions de consulta de informaci? de proces (mirar seg?ent secci?)
  \item Consultar resum de l'estat del node \\
  	Generar un resum amb la informaci? sobre el node descrita a les funcionalitats
--- 106,113 ----
  \item Modificar/Consultar la velocitat d'un node \\
  	Consultar el fitxer /proc/hpc/admin/speed
! \item Consultar informaci? de proc?ssos (resum de l'estat de proc?ssos locals, i
  remots) \\
  	Generar un resum consultant la informaci? de cada proc?s del node amb les
! operacions de consulta de informaci? de proc?s (mirar seg?ent secci?)
  \item Consultar resum de l'estat del node \\
  	Generar un resum amb la informaci? sobre el node descrita a les funcionalitats
***************
*** 115,147 ****
  \end{itemize}
  
! \item A nivell de proces...
  \begin{itemize}
! \item Moure processos d'un node a un altre \\
! 	Fer un \textit{migrate} del proces que volem moure al node on ha d'anar
! \item Bloquejar un proces en un node concret \\
  	Modificar el fitxer /proc/\textless PID\textgreater/lock
! \item Crear un nou proces en una maquina (crear un fitxer) \\
! 	Posar en execucio el proces al node on volem que s'executi
! \item Matar un proces (esborrar un fitxer) \\
! 	Fer un "kill" del proces
! \item Copiar un proces (arrencar una nova execuci? del programa) \\
  	Aix? no ?s ofert directament per OpenMosix, sin? que es tracta
  	simplement de tornar a executar el programa
! \item Modificar/veure memoria del proces \\
  	Consultar el fitxer /proc/\textless PID\textgreater/mem
! \item Consultar la linia de comandes amb la que s'ha executat \\
  	Consultar el fitxer /proc/\textless PID\textgreater/cmdline
! \item Consultar estat del proces \\
  	Consultar el fitxer /proc/\textless PID\textgreater/status
! \item Consultar quants cops s'ha migrat el proces \\
  	Consultar el fitxer /proc/\textless PID\textgreater/nmigs
! \item Consultar on s'esta computant actualment \\
  	Consultar el fitxer /proc/\textless PID\textgreater/where (o mirar el directori pare)
! \item Consultar quin node va crear el proces \\
  	Segons la suposici? inicial, tots es creen al node local
! \item Saber l'identificador de proces (ID global) \\
  	El propi \textit{PID} ens serveix d'ID global perqu? el propi OpenMosix
  	ja s'encarrega de mantenir la coher?ncia
! \item Saber l'identificador local d'un proces \\
  	En OpenMosix tots els identificadors dels processos migrables s?n
  	globals, de forma que ja s?n els mateixos que els locals (es troben a
--- 115,147 ----
  \end{itemize}
  
! \item A nivell de proc?s...
  \begin{itemize}
! \item Moure proc?ssos d'un node a un altre \\
! 	Fer un \textit{migrate} del proc?s que volem moure al node on ha d'anar
! \item Bloquejar un proc?s en un node concret \\
  	Modificar el fitxer /proc/\textless PID\textgreater/lock
! \item Crear un nou proc?s en una maquina (crear un fitxer) \\
! 	Posar en execuci? el proc?s al node on volem que s'executi
! \item Matar un proc?s (esborrar un fitxer) \\
! 	Fer un "kill" del proc?s
! \item Copiar un proc?s (arrencar una nova execuci? del programa) \\
  	Aix? no ?s ofert directament per OpenMosix, sin? que es tracta
  	simplement de tornar a executar el programa
! \item Modificar/veure mem?ria del proc?s \\
  	Consultar el fitxer /proc/\textless PID\textgreater/mem
! \item Consultar la l?nia de comandes amb la que s'ha executat \\
  	Consultar el fitxer /proc/\textless PID\textgreater/cmdline
! \item Consultar estat del proc?s \\
  	Consultar el fitxer /proc/\textless PID\textgreater/status
! \item Consultar quants cops s'ha migrat el proc?s \\
  	Consultar el fitxer /proc/\textless PID\textgreater/nmigs
! \item Consultar on s'est? computant actualment \\
  	Consultar el fitxer /proc/\textless PID\textgreater/where (o mirar el directori pare)
! \item Consultar quin node va crear el proc?s \\
  	Segons la suposici? inicial, tots es creen al node local
! \item Saber l'identificador de proc?s (ID global) \\
  	El propi \textit{PID} ens serveix d'ID global perqu? el propi OpenMosix
  	ja s'encarrega de mantenir la coher?ncia
! \item Saber l'identificador local d'un proc?s \\
  	En OpenMosix tots els identificadors dels processos migrables s?n
  	globals, de forma que ja s?n els mateixos que els locals (es troben a
***************
*** 160,164 ****
  Tal com s'ha explicat anteriorment, Beowulf ?s una arquitectura i no un paquet
  de software, de manera que hi ha diverses eines o distribucions que permeten
! contru?r aquesta arquitectura:
  
  \begin{itemize}
--- 160,164 ----
  Tal com s'ha explicat anteriorment, Beowulf ?s una arquitectura i no un paquet
  de software, de manera que hi ha diverses eines o distribucions que permeten
! construir aquesta arquitectura:
  
  \begin{itemize}

Index: 04.tex
===================================================================
RCS file: /cvsroot/taca/doc/04.tex,v
retrieving revision 1.3
retrieving revision 1.4
diff -C2 -d -r1.3 -r1.4
*** 04.tex	17 Jun 2004 19:23:39 -0000	1.3
--- 04.tex	19 Jun 2004 13:24:15 -0000	1.4
***************
*** 12,17 ****
  ofereix el software de clustering.
  
! Per exemple, quan es vol migrar un proces, es a dir, es vol moure un fitxer que
! representa el proces en el sistema de fitxers que ofereix TACA, d'un node a un
  altre, el que faria el software del nostre m?dul seria utilitzar la comanda
  "migrate" de les \textit{OpenMosix Tools} (utilitats de clustering).
--- 12,17 ----
  ofereix el software de clustering.
  
! Per exemple, quan es vol migrar un proc?s, es a dir, es vol moure un fitxer que
! representa el proc?s en el sistema de fitxers que ofereix TACA, d'un node a un
  altre, el que faria el software del nostre m?dul seria utilitzar la comanda
  "migrate" de les \textit{OpenMosix Tools} (utilitats de clustering).
***************
*** 39,43 ****
  Aquest disseny, respecte l'anterior, aporta independ?ncia respecte les OpenMosix
  Tools i efici?ncia ja que no cal que cada cop que volem fer alguna operaci?
! haguem de crear un proc?s que executi una comanda de les utilitats de
  clustering.
  
--- 39,43 ----
  Aquest disseny, respecte l'anterior, aporta independ?ncia respecte les OpenMosix
  Tools i efici?ncia ja que no cal que cada cop que volem fer alguna operaci?
! hagim de crear un proc?s que executi una comanda de les utilitats de
  clustering.
  
***************
*** 121,133 ****
          |   |-- ncpu		Numero de CPUs al node
          |   |-- load		Carrega del node
!         |   |-- mem		Estat de la memoria
          |   |-- block_new	Bloqueja l'arribada de processos nous
          |   |-- block_mig	Bloqueja la migraci? de processos locals
!         |   |-- auto_mig	Bloqueja la migracio automatica de processos
          |   |-- come_home	Fa que els processos que ha llen?at aquest node tornin
          |   |-- go_home		Expulsar els processos convidats
          |   |-- speed		Velocitat del node
          |   `-- status		Estat del node i dels processos
!         `-- <IDProces>
              |-- block           Bloqueja el proc?s en el node actual
              |-- mem		Mem?ria del proc?s
--- 121,133 ----
          |   |-- ncpu		Numero de CPUs al node
          |   |-- load		Carrega del node
!         |   |-- mem		Estat de la mem?ria
          |   |-- block_new	Bloqueja l'arribada de processos nous
          |   |-- block_mig	Bloqueja la migraci? de processos locals
!         |   |-- auto_mig	Bloqueja la migraci? autom?tica de processos
          |   |-- come_home	Fa que els processos que ha llen?at aquest node tornin
          |   |-- go_home		Expulsar els processos convidats
          |   |-- speed		Velocitat del node
          |   `-- status		Estat del node i dels processos
!         `-- <IDproc?s>
              |-- block           Bloqueja el proc?s en el node actual
              |-- mem		Mem?ria del proc?s

Index: 05.tex
===================================================================
RCS file: /cvsroot/taca/doc/05.tex,v
retrieving revision 1.2
retrieving revision 1.3
diff -C2 -d -r1.2 -r1.3
*** 05.tex	17 Jun 2004 19:23:39 -0000	1.2
--- 05.tex	19 Jun 2004 13:24:15 -0000	1.3
***************
*** 13,17 ****
  
  A l'hora de crear la implementaci?, hem pensat en un objectiu molt concret per
! tal de redu?r el tamany de la implementaci? (doncs fer-la completa requereix
  molt de temps i no ?s l'objectiu d'aquesta pr?ctica).
  
--- 13,17 ----
  
  A l'hora de crear la implementaci?, hem pensat en un objectiu molt concret per
! tal de reduir el tamany de la implementaci? (doncs fer-la completa requereix
  molt de temps i no ?s l'objectiu d'aquesta pr?ctica).
  
***************
*** 32,36 ****
  File System}) que proporciona Linux.
  
! Al ser un sistema de fitxers virtual, tota la inforaci? mostrada es genera de
  forma din?mica amb les dades obtingudes del \textit{backend}.
  
--- 32,36 ----
  File System}) que proporciona Linux.
  
! Al ser un sistema de fitxers virtual, tota la informaci? mostrada es genera de
  forma din?mica amb les dades obtingudes del \textit{backend}.
  
***************
*** 166,170 ****
  \subsubsection{Exemple \textit{dummy}}
  
! Primerament hem implementat un petit backend d'exemple que crea sempre les
  mateixes dades per tal de comprovar que la part que hem implementat del
  \textit{frontend} funciona correctament, ?s a dir, tenim un sistema de fitxers
--- 166,170 ----
  \subsubsection{Exemple \textit{dummy}}
  
! Primerament hem implementat un petit \textit{backend} d'exemple que crea sempre les
  mateixes dades per tal de comprovar que la part que hem implementat del
  \textit{frontend} funciona correctament, ?s a dir, tenim un sistema de fitxers
***************
*** 183,187 ****
  \verb"/proc/hpc", sense exportar cap s?mbol utilitzable des del propi nucli, de
  forma que l'?nica manera d'accedir-hi ?s a trav?s del VFS, el qual nom?s ?s
! accessible a trav?s de programes amb un contexte propi (com serien programes en
  mode usuari o threads de kernel).
  
--- 183,187 ----
  \verb"/proc/hpc", sense exportar cap s?mbol utilitzable des del propi nucli, de
  forma que l'?nica manera d'accedir-hi ?s a trav?s del VFS, el qual nom?s ?s
! accessible a trav?s de programes amb un context propi (com serien programes en
  mode usuari o threads de kernel).
  
***************
*** 213,220 ****
  d'OpenMosix i exportar aquestes funcions que ens proporcionarien just el que
  volem, que seria com una extensi? del nostre \textit{backend} que entraria a
! dins del codi.
  \\
  A m?s a m?s aquestes dues ?ltimes solucions no s?n molt viables pel fet de qu? la
! documentaci? tant externa com a dins del propi codi ?s molt minsa.
  
  \item
--- 213,220 ----
  d'OpenMosix i exportar aquestes funcions que ens proporcionarien just el que
  volem, que seria com una extensi? del nostre \textit{backend} que entraria a
! dins del codi del kernel.
  \\
  A m?s a m?s aquestes dues ?ltimes solucions no s?n molt viables pel fet de qu? la
! documentaci? d'OpenMosix tant externa com a dins del propi codi ?s molt minsa.
  
  \item



From nobody at sheep.berlios.de  Sat Jun 19 17:32:46 2004
From: nobody at sheep.berlios.de (xscript)
Date: Sat, 19 Jun 2004 17:32:46 +0200
Subject: [Taca-cvs] doc 00-taca.tex,1.3,1.4
Message-ID: <200406191532.i5JFWjB10151@bat.berlios.de>

Update of /cvsroot/taca/doc
In directory sheep:/tmp/cvs-serv10106

Modified Files:
	00-taca.tex 
Log Message:
Petits canvis en el format


Index: 00-taca.tex
===================================================================
RCS file: /cvsroot/taca/doc/00-taca.tex,v
retrieving revision 1.3
retrieving revision 1.4
diff -C2 -d -r1.3 -r1.4
*** 00-taca.tex	17 Jun 2004 19:23:39 -0000	1.3
--- 00-taca.tex	19 Jun 2004 15:32:43 -0000	1.4
***************
*** 8,16 ****
  \usepackage[catalan]{babel}
  \usepackage{fancyhdr}
  
  % Salto de l?nea tras t?tulo de secciones \paragraph
! \makeatletter % necesario para que reconozca a '@' como car?cter normal
! \renewcommand{\paragraph}{\@startsection{paragraph}{4}{\z@}{-3.25ex \@plus -1ex \@minus -.2ex}{1.5ex \@plus .2ex}{\normalfont\normalsize\bfseries}}
! \makeatother % necesario para que restablezca '@' como car?cter especial
  
  
--- 8,30 ----
  \usepackage[catalan]{babel}
  \usepackage{fancyhdr}
+ \usepackage{indentfirst}
+ \usepackage{verbatim}
+ \usepackage{alltt}
+ \usepackage[vcentering,dvips]{geometry}
+ 
+ \geometry{papersize={170mm,240mm},total={124mm,185mm}}
  
  % Salto de l?nea tras t?tulo de secciones \paragraph
! %\makeatletter % necesario para que reconozca a '@' como car?cter normal
! %\renewcommand{\paragraph}{\@startsection{paragraph}{4}{\z@}{-3.25ex \@plus -1ex
! %\@minus -.2ex}{1.5ex \@plus .2ex}{\normalfont\normalsize\bfseries}}
! %\makeatother % necesario para que restablezca '@' como car?cter especial
! 
! % estil de citacio de codi
! \newenvironment{codi}
! 	{\begin{quote} \begin{alltt}}
! 	{\end{alltt}\end{quote}}
! 
! \newcommand{\proc}{\texttt{/proc}\ }
  
  
***************
*** 35,38 ****
--- 49,54 ----
  
  \begin{document}
+ 
+ \setcounter{tocdepth}{4}
  \maketitle
  
***************
*** 60,64 ****
  \input{04.tex}
  \input{05.tex}
! %\input{06.tex}
  
  \pagebreak 
--- 76,80 ----
  \input{04.tex}
  \input{05.tex}
! \input{06.tex}
  
  \pagebreak 



From nobody at sheep.berlios.de  Sun Jun 20 18:57:02 2004
From: nobody at sheep.berlios.de (xscript)
Date: Sun, 20 Jun 2004 18:57:02 +0200
Subject: [Taca-cvs] doc 02.tex,1.9,1.10 04.tex,1.5,1.6 00-taca.bib,1.3,1.4
Message-ID: <200406201657.i5KGv2B12078@bat.berlios.de>

Update of /cvsroot/taca/doc
In directory sheep:/tmp/cvs-serv30393

Modified Files:
	02.tex 04.tex 00-taca.bib 
Log Message:
Mes bibliografia

Index: 02.tex
===================================================================
RCS file: /cvsroot/taca/doc/02.tex,v
retrieving revision 1.9
retrieving revision 1.10
diff -C2 -d -r1.9 -r1.10
*** 02.tex	19 Jun 2004 19:33:12 -0000	1.9
--- 02.tex	20 Jun 2004 16:56:59 -0000	1.10
***************
*** 143,147 ****
--- 143,150 ----
  
  \subsection{Translators de Hurd}
+ \nocite{Hurd-Homepage}
+ \nocite{Hurd-Hacking}
  \nocite{Hurd-Translators}
+ \nocite{Mach-Reference}
  Els translators s?n servidors de Hurd (SO basat en el micronucli gnuMach, tot i
  que s'est? migrant cap a oskit-Mach i, en un futur, cap a L4) que proporcionen

Index: 04.tex
===================================================================
RCS file: /cvsroot/taca/doc/04.tex,v
retrieving revision 1.5
retrieving revision 1.6
diff -C2 -d -r1.5 -r1.6
*** 04.tex	19 Jun 2004 19:33:12 -0000	1.5
--- 04.tex	20 Jun 2004 16:56:59 -0000	1.6
***************
*** 117,144 ****
  `-- <IDCluster>
      |-- admin
!     |   |-- nnodes          Nombre de nodes al cluster
!     |   `-- load            C?rrega general del cluster
!     |-- self                Enlla? al propi node
      `-- <IDNode>
          |-- admin
!         |   |-- ncpu        Numero de CPUs al node
!         |   |-- load        Carrega del node
!         |   |-- mem         Estat de la mem?ria
!         |   |-- block_new   Bloqueja l'arribada de processos nous
!         |   |-- block_mig   Bloqueja la migraci? de processos locals
!         |   |-- auto_mig    Bloqueja la migraci? autom?tica de processos
!         |   |-- come_home   Fa que els processos que ha llen?at aquest node tornin
!         |   |-- go_home     Expulsar els processos convidats
!         |   |-- speed       Velocitat del node
!         |   `-- status      Estat del node i dels processos
          `-- <IDproc?s>
!             |-- block       Bloqueja el proc?s en el node actual
!             |-- mem         Mem?ria del proc?s
!             |-- cmdline     L?nia de comandes amb la que s'ha arrencat el programa
!             |-- status      Estat del proc?s
!             |-- nmig        Nombre de vegades que s'ha migrat el proc?s
!             |-- home        Node on s'ha creat el proc?s
!             |-- stat_cpu    Resum d'?s de CPU pel proc?s
!             `-- stat_mem    Resum d'?s de mem?ria pel proc?s
  \end{verbatim} 
  
--- 117,151 ----
  `-- <IDCluster>
      |-- admin
!     |   |-- nnodes           Nombre de nodes al cluster
!     |   `-- load             C?rrega general del cluster
!     |-- self                 Enlla? al propi node
      `-- <IDNode>
          |-- admin
!         |   |-- ncpu         Numero de CPUs al node
!         |   |-- load         Carrega del node
!         |   |-- mem          Estat de la mem?ria
!         |   |-- block_new    Bloqueja l'arribada de processos nous
!         |   |-- block_mig    Bloqueja la migraci? de processos locals
!         |   |-- auto_mig     Bloqueja la migraci? autom?tica de processos
!         |   |-- come_home    Fa que els processos que ha llen?at aquest node tornin
!         |   |-- go_home      Expulsar els processos convidats
!         |   |-- speed        Velocitat del node
!         |   `-- status       Estat del node i dels processos
          `-- <IDproc?s>
!             |-- <IDthread>
!             |   |-- block    Bloqueja el thread en el node actual
!             |   |-- status   Estat del thread
!             |   |-- nmig     Nombre de vegades que s'ha migrat el thread
!             |   |-- home     Node on s'ha creat el thread
!             |   |-- stat_cpu Resum d'?s de CPU pel thread
!             |   `-- stat_mem Resum d'?s de mem?ria pel thread
!             |-- block        Bloqueja el proc?s en el node actual
!             |-- mem          Mem?ria del proc?s
!             |-- cmdline      L?nia de comandes amb qu? s'ha arrencat el proc?s
!             |-- status       Estat del proc?s
!             |-- nmig         Nombre de vegades que s'ha migrat el proc?s
!             |-- home         Node on s'ha creat el proc?s
!             |-- stat_cpu     Resum d'?s de CPU pel proc?s
!             `-- stat_mem     Resum d'?s de mem?ria pel proc?s
  \end{verbatim} 
  

Index: 00-taca.bib
===================================================================
RCS file: /cvsroot/taca/doc/00-taca.bib,v
retrieving revision 1.3
retrieving revision 1.4
diff -C2 -d -r1.3 -r1.4
*** 00-taca.bib	19 Jun 2004 19:33:12 -0000	1.3
--- 00-taca.bib	20 Jun 2004 16:56:59 -0000	1.4
***************
*** 24,30 ****
--- 24,45 ----
  }
  
+ @manual{Hurd-Hacking,
+ 	title = {The Hurd Hacking Guide},
+ 	note = {\\http://www.gnu.org/software/hurd/hacking-guide/hhg.html}
+ }
+ 
+ @manual{Hurd-Homepage,
+ 	title = {The GNU Hurd - GNU Project - Free Software Foundation (FSF)},
+ 	note = {\\http://www.gnu.org/software/hurd/}
+ }
+ 
  @manual{Hurd-Translators,
  	title = {Debian GNU/Hurd - Translators},
  	note = {\\http://www.debian.org/ports/hurd/hurd-doc-translator}
+ }
+ 
+ @manual{Mach-Reference,
+ 	title = {The GNU Mach Reference Manual},
+ 	note = {\\http://www.gnu.org/software/hurd/gnumach-doc/mach.html}
  }
  



From nobody at sheep.berlios.de  Sun Jun 20 18:58:43 2004
From: nobody at sheep.berlios.de (xscript)
Date: Sun, 20 Jun 2004 18:58:43 +0200
Subject: [Taca-cvs] doc 06.tex,1.1,1.2
Message-ID: <200406201658.i5KGwhB12122@bat.berlios.de>

Update of /cvsroot/taca/doc
In directory sheep:/tmp/cvs-serv30477

Modified Files:
	06.tex 
Log Message:
Nova ampliacio: sist. fitx. translucid

Index: 06.tex
===================================================================
RCS file: /cvsroot/taca/doc/06.tex,v
retrieving revision 1.1
retrieving revision 1.2
diff -C2 -d -r1.1 -r1.2
*** 06.tex	19 Jun 2004 19:33:12 -0000	1.1
--- 06.tex	20 Jun 2004 16:58:41 -0000	1.2
***************
*** 9,13 ****
  	en el nostre arbre, se seleccionaria el \textit{backend} corresponent
  	per a dur a terme la operaci? sol?licitada.
! 	
      \item \textbf{Recol?lecci? d'informaci? remota} \\
  	Donades les limitacions d'\textit{OpenMosix} a l'hora d'accedir a la
--- 9,13 ----
  	en el nostre arbre, se seleccionaria el \textit{backend} corresponent
  	per a dur a terme la operaci? sol?licitada.
! 
      \item \textbf{Recol?lecci? d'informaci? remota} \\
  	Donades les limitacions d'\textit{OpenMosix} a l'hora d'accedir a la
***************
*** 22,25 ****
  	tamb?, la limitaci? que nosaltres mateixos hem posat de crear
  	processos des d'un sol node com a punt d'entrada.
- \end{description}
  
--- 22,47 ----
  	tamb?, la limitaci? que nosaltres mateixos hem posat de crear
  	processos des d'un sol node com a punt d'entrada.
  
+     \item \textbf{Arquitectura transl?cida} \\
+ 	A vegades es pot donar el cas de qu? un sistema de clustering concret
+ 	proporcioni uns serveis molt espec?fics d'aquest, de forma que des del
+ 	\textit{frontend} es podria oferir una interf?cie gen?rica que permet?s al
+ 	\textit{backend} definir aquesta part m?s espec?fica de l'arbre de directoris.
+ 	
+ 	Aquesta soluci?, per?, requeriria que, en major o menor mesura, el mateix
+ 	\textit{backend} proporcion?s les seves pr?pies funcions de generaci? de
+ 	l'arbre espec?fic, proporcionant quelcom semblant a una versi? redu?da del
+ 	\textit{frontend}.
+ 	
+ 	Duent-ho m?s enll?, per?, es podria arribar a crear una s?rie d'estructures i
+ 	funcions gen?riques que evitessin aquesta feina a la capa d'abaix, tot i que
+ 	un sistema de clustering sol anar molt lligat al sistema operatiu i, comparant
+ 	les dues APIs de sistemes de fitxers que hem mirat (el VFS de Linux i el de
+ 	GNU/Hurd), hem vist que, tret de petits detalls, les funcionalitats que
+ 	ofereixen s?n les mateixes o molt similars, de manera que no seria molt
+ 	dif?cil generalitzarn-ne una interf?cie i amagar-ne els detalls en camps
+ 	dedicats a la la informaci? espec?fica de cada sistema (tal com ja fa Linux
+ 	amb els sistemes de fitxers, que reserva un camp que ?s un simple apuntador a
+ 	dins dels inodes per a que cada sistema de fitxers hi posi la informaci? que
+ 	consideri necess?ria.
+ \end{description}



From nobody at sheep.berlios.de  Mon Jun 21 09:42:26 2004
From: nobody at sheep.berlios.de (albertfc)
Date: Mon, 21 Jun 2004 09:42:26 +0200
Subject: [Taca-cvs] doc 06.tex,1.2,1.3
Message-ID: <200406210742.i5L7gQB30473@bat.berlios.de>

Update of /cvsroot/taca/doc
In directory sheep:/tmp/cvs-serv21374/doc

Modified Files:
	06.tex 
Log Message:
Algunes faltes d'ortografia i parent?ssis!!!



Index: 06.tex
===================================================================
RCS file: /cvsroot/taca/doc/06.tex,v
retrieving revision 1.2
retrieving revision 1.3
diff -C2 -d -r1.2 -r1.3
*** 06.tex	20 Jun 2004 16:58:41 -0000	1.2
--- 06.tex	21 Jun 2004 07:42:23 -0000	1.3
***************
*** 40,45 ****
  	GNU/Hurd), hem vist que, tret de petits detalls, les funcionalitats que
  	ofereixen s?n les mateixes o molt similars, de manera que no seria molt
! 	dif?cil generalitzarn-ne una interf?cie i amagar-ne els detalls en camps
! 	dedicats a la la informaci? espec?fica de cada sistema (tal com ja fa Linux
  	amb els sistemes de fitxers, que reserva un camp que ?s un simple apuntador a
  	dins dels inodes per a que cada sistema de fitxers hi posi la informaci? que
--- 40,45 ----
  	GNU/Hurd), hem vist que, tret de petits detalls, les funcionalitats que
  	ofereixen s?n les mateixes o molt similars, de manera que no seria molt
! 	dif?cil generalitzar-ne una interf?cie i amagar-ne els detalls en camps
! 	dedicats a la la informaci? espec?fica de cada sistema, tal com ja fa Linux,
  	amb els sistemes de fitxers, que reserva un camp que ?s un simple apuntador a
  	dins dels inodes per a que cada sistema de fitxers hi posi la informaci? que



From nobody at sheep.berlios.de  Thu Jun 24 22:00:56 2004
From: nobody at sheep.berlios.de (xscript)
Date: Thu, 24 Jun 2004 22:00:56 +0200
Subject: [Taca-cvs] doc 00-taca.bib,1.4,1.5 05.tex,1.4,1.5
Message-ID: <200406242000.i5OK0uB16797@bat.berlios.de>

Update of /cvsroot/taca/doc
In directory sheep:/tmp/cvs-serv29213

Modified Files:
	00-taca.bib 05.tex 
Log Message:
Petits canvis a la bibliografia

Index: 00-taca.bib
===================================================================
RCS file: /cvsroot/taca/doc/00-taca.bib,v
retrieving revision 1.4
retrieving revision 1.5
diff -C2 -d -r1.4 -r1.5
*** 00-taca.bib	20 Jun 2004 16:56:59 -0000	1.4
--- 00-taca.bib	24 Jun 2004 20:00:53 -0000	1.5
***************
*** 89,100 ****
  }
  
! @manual{VFS-seq,
! 	title = {Driver porting: The seq\_file interface},
! 	note = {\\http://lwn.net/Articles/22355/}
  }
  
  @manual{VFS-tlk,
  	title = {The Linux kernel},
! 	note = {\\http://www.win.tue.nl/~aeb/linux/lk/lk.html}
  }
  
--- 89,100 ----
  }
  
! @manual{VFS-lk,
! 	title = {The Linux kernel},
! 	note = {\\http://www.win.tue.nl/~aeb/linux/lk/lk.html}
  }
  
  @manual{VFS-tlk,
  	title = {The Linux kernel},
! 	note = {\\http://en.tldp.org/LDP/tlk/}
  }
  

Index: 05.tex
===================================================================
RCS file: /cvsroot/taca/doc/05.tex,v
retrieving revision 1.4
retrieving revision 1.5
diff -C2 -d -r1.4 -r1.5
*** 05.tex	19 Jun 2004 19:33:12 -0000	1.4
--- 05.tex	24 Jun 2004 20:00:53 -0000	1.5
***************
*** 36,41 ****
  \nocite{VFS-libfs}
  \nocite{VFS-rkfs}
  \nocite{VFS-tlk}
- \nocite{VFS-seq}
  Aquest sistema de fitxers est? basat en la interf?cie del VFS (\textit{Virtual
  File System}) que proporciona Linux.
--- 36,41 ----
  \nocite{VFS-libfs}
  \nocite{VFS-rkfs}
+ \nocite{VFS-lk}
  \nocite{VFS-tlk}
  Aquest sistema de fitxers est? basat en la interf?cie del VFS (\textit{Virtual
  File System}) que proporciona Linux.



From gnome_xxi at hotmail.com  Fri Jun 25 00:47:49 2004
From: gnome_xxi at hotmail.com (=?iso-8859-1?B?Sm9uYXRoYW4gTWFydO0=?=)
Date: Thu, 24 Jun 2004 22:47:49 +0000
Subject: [Taca-cvs] doc 00-taca.bib,1.4,1.5 05.tex,1.4,1.5
Message-ID: <BAY16-F8Kxt8zPdqJL9000020e2@hotmail.com>

Ei Lluis, anir?s tu a entregar dem?? (b?, avui d'aqui unes hores)
Bona nit.
Salut!

>From: xscript <nobody at sheep.berlios.de>
>To: taca-cvs at lists.berlios.de
>Subject: [Taca-cvs] doc 00-taca.bib,1.4,1.5 05.tex,1.4,1.5
>Date: Thu, 24 Jun 2004 22:00:56 +0200
>
>Update of /cvsroot/taca/doc
>In directory sheep:/tmp/cvs-serv29213
>
>Modified Files:
>	00-taca.bib 05.tex
>Log Message:
>Petits canvis a la bibliografia
>
>Index: 00-taca.bib
>===================================================================
>RCS file: /cvsroot/taca/doc/00-taca.bib,v
>retrieving revision 1.4
>retrieving revision 1.5
>diff -C2 -d -r1.4 -r1.5
>*** 00-taca.bib	20 Jun 2004 16:56:59 -0000	1.4
>--- 00-taca.bib	24 Jun 2004 20:00:53 -0000	1.5
>***************
>*** 89,100 ****
>   }
>
>! @manual{VFS-seq,
>! 	title = {Driver porting: The seq\_file interface},
>! 	note = {\\http://lwn.net/Articles/22355/}
>   }
>
>   @manual{VFS-tlk,
>   	title = {The Linux kernel},
>! 	note = {\\http://www.win.tue.nl/~aeb/linux/lk/lk.html}
>   }
>
>--- 89,100 ----
>   }
>
>! @manual{VFS-lk,
>! 	title = {The Linux kernel},
>! 	note = {\\http://www.win.tue.nl/~aeb/linux/lk/lk.html}
>   }
>
>   @manual{VFS-tlk,
>   	title = {The Linux kernel},
>! 	note = {\\http://en.tldp.org/LDP/tlk/}
>   }
>
>
>Index: 05.tex
>===================================================================
>RCS file: /cvsroot/taca/doc/05.tex,v
>retrieving revision 1.4
>retrieving revision 1.5
>diff -C2 -d -r1.4 -r1.5
>*** 05.tex	19 Jun 2004 19:33:12 -0000	1.4
>--- 05.tex	24 Jun 2004 20:00:53 -0000	1.5
>***************
>*** 36,41 ****
>   \nocite{VFS-libfs}
>   \nocite{VFS-rkfs}
>   \nocite{VFS-tlk}
>- \nocite{VFS-seq}
>   Aquest sistema de fitxers est? basat en la interf?cie del VFS 
>(\textit{Virtual
>   File System}) que proporciona Linux.
>--- 36,41 ----
>   \nocite{VFS-libfs}
>   \nocite{VFS-rkfs}
>+ \nocite{VFS-lk}
>   \nocite{VFS-tlk}
>   Aquest sistema de fitxers est? basat en la interf?cie del VFS 
>(\textit{Virtual
>   File System}) que proporciona Linux.
>
>_______________________________________________
>Taca-cvs mailing list
>Taca-cvs at lists.berlios.de
>http://lists.berlios.de/mailman/listinfo/taca-cvs

_________________________________________________________________
Un amor, una aventura, compa??a para un viaje. Reg?strate gratis en MSN Amor 
& Amistad. http://match.msn.es/



From xscript at gmx.net  Fri Jun 25 01:12:30 2004
From: xscript at gmx.net (Lluis)
Date: Fri, 25 Jun 2004 01:12:30 +0200
Subject: [Taca-cvs] doc 00-taca.bib,1.4,1.5 05.tex,1.4,1.5
In-Reply-To: <BAY16-F8Kxt8zPdqJL9000020e2@hotmail.com>
References: <BAY16-F8Kxt8zPdqJL9000020e2@hotmail.com>
Message-ID: <20040624231230.GA843@dante.xlab.taz>

El 24/06/04, a les 22:47:49, Jonathan Mart? ens deleit? amb les seg?ents paraules:
> 
> Ei Lluis, anir?s tu a entregar dem?? (b?, avui d'aqui unes hores)
> Bona nit.
> Salut!
> 
sip, tan bon punt surti del curro

-- 
 "And it's much the same thing with knowledge, for whenever you learn
 something new, the whole world becomes that much richer."
 -- The Princess of Pure Reason, as told by Norton Juster in The Phantom
 Tollbooth 


From nobody at sheep.berlios.de  Fri Jun 25 02:20:17 2004
From: nobody at sheep.berlios.de (xscript)
Date: Fri, 25 Jun 2004 02:20:17 +0200
Subject: [Taca-cvs] code Makefile,1.5,1.6 Rules.conf,1.4,1.5
Message-ID: <200406250020.i5P0KHB22824@bat.berlios.de>

Update of /cvsroot/taca/code
In directory sheep:/tmp/cvs-serv29371

Modified Files:
	Makefile Rules.conf 
Log Message:
Neteja de cara al frontend


Index: Makefile
===================================================================
RCS file: /cvsroot/taca/code/Makefile,v
retrieving revision 1.5
retrieving revision 1.6
diff -C2 -d -r1.5 -r1.6
*** Makefile	17 Jun 2004 03:37:31 -0000	1.5
--- Makefile	25 Jun 2004 00:20:14 -0000	1.6
***************
*** 5,8 ****
--- 5,9 ----
  # global flags definitions
  CFLAGS  += -Wall -O2 \
+ 	   $(DEBUG) \
  	   -D__KERNEL__ -DMODULE \
  	   -inostdinc \

Index: Rules.conf
===================================================================
RCS file: /cvsroot/taca/code/Rules.conf,v
retrieving revision 1.4
retrieving revision 1.5
diff -C2 -d -r1.4 -r1.5
*** Rules.conf	17 Jun 2004 03:35:42 -0000	1.4
--- Rules.conf	25 Jun 2004 00:20:14 -0000	1.5
***************
*** 4,7 ****
--- 4,10 ----
  # General conf
  
+ # uncomment to see debugging messages on syslog
+ DEBUG = -DDEBUG
+ 
  # Available Frontends:
  # - linux.o
***************
*** 9,14 ****
  
  # Available Backends:
  # - openmosix.o
- #BACKEND  = openmosix.o
  BACKEND  = dummy.o
  # (!)
--- 12,17 ----
  
  # Available Backends:
+ # - dummy.o
  # - openmosix.o
  BACKEND  = dummy.o
  # (!)
***************
*** 20,25 ****
  MNTPOINT = /mnt/$(FSNAME)
  
! INCLUDEDIR = /usr/src/linux-openmosix/include
! #INCLUDEDIR = /usr/src/kernel-source-2.4.22/include
  #INCLUDEDIR = /usr/src/linux/include
  
--- 23,28 ----
  MNTPOINT = /mnt/$(FSNAME)
  
! #INCLUDEDIR = /usr/src/linux-openmosix/include
! INCLUDEDIR = /usr/src/kernel-source-2.4.22/include
  #INCLUDEDIR = /usr/src/linux/include
  
***************
*** 39,43 ****
  
  # OpenMosix
! openmosix_VER = 2.4.22# version to use
  # (!)
  OPENMOSIX_CFLAGS += -I$(INCLUDEDIR)
--- 42,47 ----
  
  # OpenMosix
! # version to use
! openmosix_VER = 2.4.22
  # (!)
  OPENMOSIX_CFLAGS += -I$(INCLUDEDIR)
***************
*** 50,53 ****
  # Exports
  # (!)
! export FSNAME BACKVER LINUX_CFLAGS OPENMOSIX_CFLAGS DUMMY_CFLAGS
  
--- 54,57 ----
  # Exports
  # (!)
! export FSNAME BACKVER LINUX_CFLAGS OPENMOSIX_CFLAGS DUMMY_CFLAGS DEBUG
  



From nobody at sheep.berlios.de  Fri Jun 25 02:20:18 2004
From: nobody at sheep.berlios.de (xscript)
Date: Fri, 25 Jun 2004 02:20:18 +0200
Subject: [Taca-cvs] code/common linux_debug.h,1.1,1.2
Message-ID: <200406250020.i5P0KIB22833@bat.berlios.de>

Update of /cvsroot/taca/code/common
In directory sheep:/tmp/cvs-serv29371/common

Modified Files:
	linux_debug.h 
Log Message:
Neteja de cara al frontend


Index: linux_debug.h
===================================================================
RCS file: /cvsroot/taca/code/common/linux_debug.h,v
retrieving revision 1.1
retrieving revision 1.2
diff -C2 -d -r1.1 -r1.2
*** linux_debug.h	17 Jun 2004 03:35:41 -0000	1.1
--- linux_debug.h	25 Jun 2004 00:20:15 -0000	1.2
***************
*** 8,18 ****
  #define _linux_debug_h_
  
! #define DEBUG_FLAG KERN_DEBUG
  
  #ifdef DEBUG
! #define dprint(msg, args...)			\
! 	do { printk(DEBUG_FLAG "%s.%d:%s: \n\t"msg,__FILE_,__LINE__,__FUNCTION__,##args); } while (0)
  #else
  #define dprint(msg, args...)			\
  	do { ; } while (0)
  #endif
--- 8,24 ----
  #define _linux_debug_h_
  
! #define DEBUG_FLAG KERN_INFO
  
  #ifdef DEBUG
! #define dprint(msg, args...)									\
! 	do {											\
! 	    printk(DEBUG_FLAG "%s.%d:%s: "msg,__FILE__,__LINE__,__FUNCTION__,##args);	\
! 	} while (0)
! #define dprint2(msg)										\
! 	do { printk(DEBUG_FLAG "%s.%d:%s: "msg,__FILE__,__LINE__,__FUNCTION__); } while (0)
  #else
  #define dprint(msg, args...)			\
+ 	do { ; } while (0)
+ #define dprint2(msg)			\
  	do { ; } while (0)
  #endif



From nobody at sheep.berlios.de  Fri Jun 25 02:20:17 2004
From: nobody at sheep.berlios.de (xscript)
Date: Fri, 25 Jun 2004 02:20:17 +0200
Subject: [Taca-cvs] code/backend backend.h,1.3,1.4
Message-ID: <200406250020.i5P0KHB22827@bat.berlios.de>

Update of /cvsroot/taca/code/backend
In directory sheep:/tmp/cvs-serv29371/backend

Modified Files:
	backend.h 
Log Message:
Neteja de cara al frontend


Index: backend.h
===================================================================
RCS file: /cvsroot/taca/code/backend/backend.h,v
retrieving revision 1.3
retrieving revision 1.4
diff -C2 -d -r1.3 -r1.4
*** backend.h	14 Jun 2004 23:51:18 -0000	1.3
--- backend.h	25 Jun 2004 00:20:15 -0000	1.4
***************
*** 1,28 ****
  struct cluster_t {
! 	char *nom;
! 	struct cluster_t *next;
  };
  
  struct node_t {
! 	char *nom;
! 	struct node_t *next;
! 	struct cluster_t *parent;
  };
  
  struct proces_t {
! 	char *nom;
! 	struct proces_t *next;
! 	struct node_t *parent;
  };
  
  
! int num_clusters();
! int llistar_clusters (struct cluster_t *llista);
! 
! int num_nodes(struct cluster_t *cluster_id);
! int llistar_nodes (struct cluster_t *cluster_id, struct node_t *llista);
  
! int num_procs(struct cluster_t *cluster_id, struct node_t *node_id);
! int llistar_procs (struct cluster_t *cluster_id, struct node_t *node_id, struct proces_t *lista);
  
  
--- 1,39 ----
+ 
+ #ifndef _backend_h_
+ #define _backend_h_
+ 
+ #define MAXSTR 256
+ 
  struct cluster_t {
!     char nom[MAXSTR];
!     struct cluster_t *next;
  };
  
  struct node_t {
!     char nom[MAXSTR];
!     struct node_t *next;
!     struct cluster_t *parent;
  };
  
  struct proces_t {
!     char nom[MAXSTR];
!     struct proces_t *next;
!     struct node_t *parent;
  };
  
+ int num_clusters ();
+ int llistar_clusters (struct cluster_t *llista, int maxnum);
+ int obtenir_cluster (const char *nom, struct cluster_t *cluster);
+ int cluster_valid (struct cluster_t *cluster);
  
! int num_nodes (struct cluster_t *cluster_id);
! int llistar_nodes (struct cluster_t *cluster_id, struct node_t *llista, int maxnum);
! int obtenir_node (struct cluster_t *cluster_id, const char *nom, struct node_t *node);
! int node_valid (struct node_t *node);
  
! int num_procs (struct node_t *node_id);
! int llistar_procs (struct node_t *node_id, struct proces_t *lista, int maxnum);
! int obtenir_proc (struct node_t *node_id, const char *nom, struct proces_t *proces);
! int proc_valid (struct proces_t *proces);
  
  
***************
*** 38,40 ****
--- 49,53 ----
  /* El proces no es pot migrar */
  int proces_bloquejat (struct proces_t *proc);
+ 
+ #endif
  



From nobody at sheep.berlios.de  Fri Jun 25 02:20:18 2004
From: nobody at sheep.berlios.de (xscript)
Date: Fri, 25 Jun 2004 02:20:18 +0200
Subject: [Taca-cvs] code/backend/dummy dummy.c,1.1,1.2
Message-ID: <200406250020.i5P0KIB22830@bat.berlios.de>

Update of /cvsroot/taca/code/backend/dummy
In directory sheep:/tmp/cvs-serv29371/backend/dummy

Modified Files:
	dummy.c 
Log Message:
Neteja de cara al frontend


Index: dummy.c
===================================================================
RCS file: /cvsroot/taca/code/backend/dummy/dummy.c,v
retrieving revision 1.1
retrieving revision 1.2
diff -C2 -d -r1.1 -r1.2
*** dummy.c	15 Jun 2004 17:25:41 -0000	1.1
--- dummy.c	25 Jun 2004 00:20:15 -0000	1.2
***************
*** 1,73 ****
  
  #include "backend.h"
! #include <linux/mm.h>
  
  
! //struct cluster_t clus = {.nom = "123",
! //			 .next = NULL};
! /*
! struct node_t n3 = {	.nom = "n3",
! 			.next = NULL};
! struct node_t n2 = {	.nom = "n2",
! 			.next = &n3 };
! struct node_t n1 = {	.nom = "n1",
! 			.next = &n2};
  
! struct proces_t p3 = {	.nom = "proc3",
! 			.next = NULL};
  
! struct proces_t p2 = {	.nom = "proc2",
! 			.next = &p3};
! struct proces_t p1 = {	.nom = "proc1",
! 			.next = &p2};
  
! */			
! int num_clusters() 
  {
! 	return 1;
  }
  
! int llistar_clusters (struct cluster_t *llista)
  {
! 	//llista = (struct cluster_t *)kmalloc(sizeof(struct cluster_t) ,GFP_KERNEL);	
! 	llista->nom = "c1" ;
! 	llista->next = NULL;
! 	return 0;
  }
  
  int num_nodes (struct cluster_t *cluster_id)
  {
! 	return 3;
  }
  
! int llistar_nodes (struct cluster_t *cluster_id, struct node_t *llista)
  {
! 	llista[0].nom = "n0";
! 	llista[0].next = &llista[1];
! 	llista[1].nom = "n1";
! 	llista[1].next = &llista[2];
! 	llista[2].nom = "n2";
! 	llista[2].next = NULL;
  
  	return 0;
  }
  
! int num_procs (struct cluster_t *cluster_id, struct node_t *node_id) 
  {
! 	return 3;
  }
  
! int llistar_procs (struct cluster_t *cluster_id, struct node_t *node_id, struct proces_t *llista)
  {
! 	llista[0].nom = "p0";
! 	llista[0].next = &llista[1];
! 	llista[1].nom = "p1";
  	llista[1].next = &llista[2];
! 	llista[2].nom = "p2";
  	llista[2].next = NULL;
  
! 	return 0;
  }
  
  
  //int migrar (struct proces_t  *proces, struct node_t *node_desti);
--- 1,152 ----
  
  #include "backend.h"
! #include <linux/slab.h>
! #include <asm/string.h>
  
  
! int num_clusters() 
! {
!     return 1;
! }
  
! int llistar_clusters (struct cluster_t *llista, int maxnum)
! {
!     int num = num_clusters();
  
!     if (num > maxnum)
! 	return 0;
!     strcpy(llista->nom,"c1");
!     llista->next = NULL;
  
!     return num;
! }
! 
! int obtenir_cluster (const char *nom, struct cluster_t *cluster)
  {
!     int num = num_clusters();
!     struct cluster_t *ptr, *llista = kmalloc(sizeof(struct cluster_t)*num, GFP_KERNEL);
!     llistar_clusters(llista, num);
!     for (ptr = llista; ptr != NULL; ptr = ptr->next) {
! 	if (!strcmp(ptr->nom, nom)) {
! 	    strcpy(cluster->nom, nom);
! 	    break;
! 	}
!     }
!     kfree(llista);
!     return ptr != NULL;
  }
  
! int cluster_valid (struct cluster_t *cluster)
  {
!     return 1;
  }
  
  int num_nodes (struct cluster_t *cluster_id)
  {
!     return 3;
  }
  
! int llistar_nodes (struct cluster_t *cluster_id, struct node_t *llista, int maxnum)
  {
!     int num = num_nodes(cluster_id);
  
+     if (num > maxnum)
  	return 0;
+     strcpy(llista[0].nom, "n0");
+     llista[0].next = &llista[1];
+     llista[0].parent = cluster_id;
+     strcpy(llista[1].nom, "n1");
+     llista[1].next = &llista[2];
+     llista[1].parent = cluster_id;
+     strcpy(llista[2].nom, "n2");
+     llista[2].next = NULL;
+     llista[2].parent = cluster_id;
+ 
+     return num;
  }
  
! int obtenir_node (struct cluster_t *cluster_id, const char *nom, struct node_t *node)
  {
!     int num = num_nodes(cluster_id);
!     struct node_t *ptr, *llista = kmalloc(sizeof(struct node_t)*num, GFP_KERNEL);
!     llistar_nodes(cluster_id, llista, num);
!     for (ptr = llista; ptr != NULL; ptr = ptr->next) {
! 	if (!strcmp(ptr->nom, nom)) {
! 	    strcpy(node->nom, nom);
! 	    node->parent = cluster_id;
! 	    break;
! 	}
!     }
!     kfree(llista);
!     return ptr != NULL;
  }
  
! int node_valid (struct node_t *node)
  {
!     return 1;
! }
! 
! /* cada quan volem que canvii l'estat dels "p2" (aparicio/desaparicio) */
! #define MODUL 15
! static int emulador ()
! {
!     struct timeval tv;
!     do_gettimeofday(&tv);
!     return tv.tv_sec%MODUL;
! }
! 
! int num_procs (struct node_t *node_id) 
! {
!     return 2 + emulador();
! }
! 
! int llistar_procs (struct node_t *node_id, struct proces_t *llista, int maxnum)
! {
!     int num = num_procs(node_id);
! 
!     if (num > maxnum)
! 	return 0;
!     strcpy(llista[0].nom, "p0");
!     llista[0].next = &llista[1];
!     llista[0].parent = node_id;
!     strcpy(llista[1].nom, "p1");
!     llista[1].parent = node_id;
!     if (emulador()) {
  	llista[1].next = &llista[2];
! 	strcpy(llista[2].nom, "p2");
  	llista[2].next = NULL;
+ 	llista[2].parent = node_id;
+     }
+     else
+ 	llista[1].next = NULL;
  
!     return num;
  }
  
+ int obtenir_proc (struct node_t *node_id, const char *nom, struct proces_t *proces)
+ {
+     int num = num_procs(node_id);
+     struct proces_t *ptr, *llista = kmalloc(sizeof(struct proces_t)*num, GFP_KERNEL);
+     llistar_procs(node_id, llista, num);
+     for (ptr = llista; ptr != NULL; ptr = ptr->next) {
+ 	if (!strcmp(ptr->nom, nom)) {
+ 	    strcpy(proces->nom, nom);
+ 	    proces->parent = node_id;
+ 	    if (!strcmp(nom, "p2") && !emulador())
+ 		ptr = NULL;
+ 	    break;
+ 	}
+     }
+     kfree(llista);
+     return ptr != NULL;
+ }
+ 
+ int proc_valid (struct proces_t *proces)
+ {
+     if (!strcmp(proces->nom, "p2") && !emulador())
+ 	return 0;
+     else
+ 	return 1;
+ }
  
  //int migrar (struct proces_t  *proces, struct node_t *node_desti);



From nobody at sheep.berlios.de  Fri Jun 25 03:09:39 2004
From: nobody at sheep.berlios.de (xscript)
Date: Fri, 25 Jun 2004 03:09:39 +0200
Subject: [Taca-cvs] doc 05.tex,1.5,1.6
Message-ID: <200406250109.i5P19dB23682@bat.berlios.de>

Update of /cvsroot/taca/doc
In directory sheep:/tmp/cvs-serv30917

Modified Files:
	05.tex 
Log Message:
Reflectint els canvis del codi

Index: 05.tex
===================================================================
RCS file: /cvsroot/taca/doc/05.tex,v
retrieving revision 1.5
retrieving revision 1.6
diff -C2 -d -r1.5 -r1.6
*** 05.tex	24 Jun 2004 20:00:53 -0000	1.5
--- 05.tex	25 Jun 2004 01:09:37 -0000	1.6
***************
*** 50,59 ****
  static int __init tacafs_init(void)
  \{
!    return register_filesystem(&tacafs_type);
  \}
  
  static void __exit tacafs_exit(void)
  \{
!    unregister_filesystem(&tacafs_type);
  \}
  \end{codi}
--- 50,59 ----
  static int __init tacafs_init(void)
  \{
!    [...] return register_filesystem(&tacafs_type);
  \}
  
  static void __exit tacafs_exit(void)
  \{
!    unregister_filesystem(&tacafs_type); [...]
  \}
  \end{codi}
***************
*** 90,101 ****
        return 0;
     [...]
!    num = num_clusters();      // CRIDA AL BACKEND
     [...]
!    llistar_clusters(llista);  // CRIDA AL BACKEND
!    while (llista != NULL) \{
!       if(filldir(dirent, llista->nom, strlen(llista->nom),
!                  file->f_pos++, DIR_INODE_NUMBER, DT_DIR))
!          return 0;
!       llista = llista->next;
     \}
     [...]
--- 90,103 ----
        return 0;
     [...]
!    num = num_clusters();                    // CRIDA AL BACKEND
     [...]
!    if (llistar_clusters(llista, num) > 0) \{ // CRIDA AL BACKEND
!        num = 0;
!        while (llista != NULL) \{
!            if(filldir(dirent, llista->nom, strlen(llista->nom),
! 	              file->f_pos++, INO(++num,INODE_CLUSTER), DT_DIR))
!                 return 0;
!            llista = llista->next;
!        \}
     \}
     [...]
***************
*** 107,111 ****
  representar la jerarquia de fitxers, i el inode pare al que pertany el dentry,
  crea un inode, li associa les operacions corresponents, el mode i finalment
! associa l'inode al dentry.
  
  Aquesta funci? seria cridada en accedir al directori en q?esti?.
--- 109,114 ----
  representar la jerarquia de fitxers, i el inode pare al que pertany el dentry,
  crea un inode, li associa les operacions corresponents, el mode i finalment
! associa l'inode al dentry (la major part d'aquesta tasca la duu a terme la
! funci? \verb"tacafs_fill_dentry" i les que aquesta crida).
  
  Aquesta funci? seria cridada en accedir al directori en q?esti?.
***************
*** 115,128 ****
                                  struct dentry *dentry)
  \{
!    [...]
!    if(!(file_inode = iget(parent_inode->i_sb, DIR_INODE_NUMBER)))
!       return ERR_PTR(-ENOMEM);
!    file_inode->i_mode = S_IFDIR|S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH;
!    // file_operations
!    file_inode->i_fop = &tacafs_dir_fops;
!    // inode_operations
!    file_inode->i_op = &tacafs_iops;
!    // afegir el inode al dentry
!    d_add(dentry, file_inode);
  \}
  \end{codi}
--- 118,158 ----
                                  struct dentry *dentry)
  \{
!     struct dentry *res = ERR_PTR(-ENOENT);
!     struct cluster_t cluster;
!     
!     if (!obtenir_cluster(dentry->d_name.name, &cluster))
!         goto out;
!     /*
!      * Hem de generar el inode per mostrar un cluster (el dentry)
!      * Per tant un directori
!      */
!     res = tacafs_fill_dentry(parent_inode->i_sb, dentry, INODE_CLUSTER,
!             MODE_DIR, &cluster, sizeof(cluster), &tacafs_cluster_iops,
!             &tacafs_cluster_dops, &tacafs_cluster_fops);
! out:
!     return res;
! \}
! 
! struct dentry *tacafs_fill_dentry (struct super_block *sb,
!          struct dentry *dentry, int inobase, int mode, void *data,
! 	 int datasize, struct inode_operations *iops, 
! 	 struct dentry_operations *dops, struct file_operations *fops)
! \{
!     [...]
!     inode = tacafs_make_inode(sb, INO(name2ino,inobase), mode,
! 	                      iops, fops);
!     if (!inode)
! 	return ERR_PTR(-ENOMEM);
! 
!     dentry->d_op = dops;
! 
!     if (!tacafs_write_data(inode, data, datasize)) \{
! 	iput(inode);
! 	return ERR_PTR(-ENOMEM);
!     \}
! 
!     d_add(dentry, inode);
! 
!     return NULL;
  \}
  \end{codi}
***************
*** 156,167 ****
  
  \begin{codi}
! int num_clusters();
! int llistar_clusters (struct cluster_t *llista);
  int num_nodes (struct cluster_t *cluster_id);
! int llistar_nodes (struct cluster_t *cluster_id,
!                    struct node_t *llista);
! int num_procs (struct cluster_t *cluster_id, struct node_t *node_id);
! int llistar_procs (struct cluster_t *cluster_id, struct node_t *node_id,
!                    struct proces_t *lista);
  \end{codi}
  
--- 186,207 ----
  
  \begin{codi}
! int num_clusters ();
! int llistar_clusters (struct cluster_t *llista, int maxnum);
! int obtenir_cluster (const char *nom, struct cluster_t *cluster);
! int cluster_valid (struct cluster_t *cluster);
! 
  int num_nodes (struct cluster_t *cluster_id);
! int llistar_nodes (struct cluster_t *cluster_id, struct node_t *llista,
!                    int maxnum);
! int obtenir_node (struct cluster_t *cluster_id, const char *nom,
!                   struct node_t *node);
! int node_valid (struct node_t *node);
! 
! int num_procs (struct node_t *node_id);
! int llistar_procs (struct node_t *node_id, struct proces_t *lista,
!                    int maxnum);
! int obtenir_proc (struct node_t *node_id, const char *nom,
!                   struct proces_t *proces);
! int proc_valid (struct proces_t *proces);
  \end{codi}
  



From xscript at gmx.net  Fri Jun 25 13:59:58 2004
From: xscript at gmx.net (Lluis)
Date: Fri, 25 Jun 2004 13:59:58 +0200 (MEST)
Subject: [Taca-cvs] doc 00-taca.bib,1.4,1.5 05.tex,1.4,1.5
References: <BAY16-F75SjMKtWNymW00002358@hotmail.com>
Message-ID: <23186.1088164798@www30.gmx.net>

> D'acord.
> No se si coincidirem en horaris dem?, per? si vols t'envio un email
> dient-te 
> a quina hora plego i t'acompanyo a entregar-ho si plegues a la mateixa
> hora.
> SALUT!
> 
res, ja ho he pujat ara un momentet i ho he deixat a la bustia

apa!

-- 
+++ Jetzt WLAN-Router f?r alle DSL-Einsteiger und Wechsler +++
GMX DSL-Powertarife zudem 3 Monate gratis* http://www.gmx.net/dsl



From nobody at sheep.berlios.de  Wed Jun 30 22:32:45 2004
From: nobody at sheep.berlios.de (xscript)
Date: Wed, 30 Jun 2004 22:32:45 +0200
Subject: [Taca-cvs] code/frontend/linux linux_common.c,1.2,1.3 root.c,1.2,1.3
Message-ID: <200406302032.i5UKWjB21786@bat.berlios.de>

Update of /cvsroot/taca/code/frontend/linux
In directory sheep:/tmp/cvs-serv23620/frontend/linux

Modified Files:
	linux_common.c root.c 
Log Message:
Fixed memory leak

Index: linux_common.c
===================================================================
RCS file: /cvsroot/taca/code/frontend/linux/linux_common.c,v
retrieving revision 1.2
retrieving revision 1.3
diff -C2 -d -r1.2 -r1.3
*** linux_common.c	25 Jun 2004 00:20:16 -0000	1.2
--- linux_common.c	30 Jun 2004 20:32:43 -0000	1.3
***************
*** 40,46 ****
  	ret->i_blocks = 0;
  	ret->i_atime = ret->i_mtime = ret->i_ctime = CURRENT_TIME;
! 	if (iops)
  	    ret->i_op = iops;
! 	if (fops)
  	    ret->i_fop = fops;
      }
--- 40,46 ----
  	ret->i_blocks = 0;
  	ret->i_atime = ret->i_mtime = ret->i_ctime = CURRENT_TIME;
! 	//if (iops)
  	    ret->i_op = iops;
! 	//if (fops)
  	    ret->i_fop = fops;
      }

Index: root.c
===================================================================
RCS file: /cvsroot/taca/code/frontend/linux/root.c,v
retrieving revision 1.2
retrieving revision 1.3
diff -C2 -d -r1.2 -r1.3
*** root.c	25 Jun 2004 00:20:16 -0000	1.2
--- root.c	30 Jun 2004 20:32:43 -0000	1.3
***************
*** 40,45 ****
  
  static struct super_operations tacafs_sops = {
! put_inode: dummy_put_inode,
! delete_inode: dummy_delete_inode,
      clear_inode: tacafs_s_clear_inode,
      read_inode: tacafs_s_read_inode,
--- 40,45 ----
  
  static struct super_operations tacafs_sops = {
! //put_inode: dummy_put_inode,
! //delete_inode: dummy_delete_inode,
      clear_inode: tacafs_s_clear_inode,
      read_inode: tacafs_s_read_inode,
***************
*** 105,109 ****
      if (inode != tacafs_root_inode) {
  	dprint("%s\n",((struct cluster_t*)inode->u.generic_ip)->nom);
! 	kmem_cache_free(tacafs_inode_cachep, inode);
      }
  }
--- 105,109 ----
      if (inode != tacafs_root_inode) {
  	dprint("%s\n",((struct cluster_t*)inode->u.generic_ip)->nom);
! 	kmem_cache_free(tacafs_inode_cachep, inode->u.generic_ip);
      }
  }



